<?xml version="1.0" encoding="utf-8"?>
<docs>
  <types>
    <type name="PFN_vkAllocationFunction" summary="Application-defined memory allocation function.">
      <specification />
      <members>
        <member name="pUserData">pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.</member>
        <member name="size">pname:size is the size in bytes of the requested allocation.</member>
        <member name="alignment">pname:alignment is the requested alignment of the allocation in bytes and must: be a power of two.</member>
        <member name="allocationScope">pname:allocationScope is a elink:VkSystemAllocationScope value specifying the scope of the lifetime of the allocation, as described &lt;&lt;memory-host-allocation-scope,here&gt;&gt;.</member>
      </members>
    </type>
    <type name="PFN_vkFreeFunction" summary="Application-defined memory free function.">
      <specification />
      <members>
        <member name="pUserData">pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.</member>
        <member name="pMemory">pname:pMemory is the allocation to be freed.</member>
      </members>
    </type>
    <type name="PFN_vkInternalAllocationNotification" summary="Application-defined memory allocation notification function.">
      <specification />
      <members>
        <member name="pUserData">pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.</member>
        <member name="size">pname:size is the requested size of an allocation.</member>
        <member name="allocationType">pname:allocationType is the requested type of an allocation.</member>
        <member name="allocationScope">pname:allocationScope is a elink:VkSystemAllocationScope value specifying the scope of the lifetime of the allocation, as described &lt;&lt;memory-host-allocation-scope,here&gt;&gt;.</member>
      </members>
    </type>
    <type name="PFN_vkInternalFreeNotification" summary="Application-defined memory free notification function.">
      <specification />
      <members>
        <member name="pUserData">pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.</member>
        <member name="size">pname:size is the requested size of an allocation.</member>
        <member name="allocationType">pname:allocationType is the requested type of an allocation.</member>
        <member name="allocationScope">pname:allocationScope is a elink:VkSystemAllocationScope value specifying the scope of the lifetime of the allocation, as described &lt;&lt;memory-host-allocation-scope,here&gt;&gt;.</member>
      </members>
    </type>
    <type name="PFN_vkReallocationFunction" summary="Application-defined memory reallocation function.">
      <specification />
      <members>
        <member name="pUserData">pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.</member>
        <member name="pOriginal">pname:pOriginal must: be either `NULL` or a pointer previously returned by pname:pfnReallocation or pname:pfnAllocation of the same allocator.</member>
        <member name="size">pname:size is the size in bytes of the requested allocation.</member>
        <member name="alignment">pname:alignment is the requested alignment of the allocation in bytes and must: be a power of two.</member>
        <member name="allocationScope">pname:allocationScope is a elink:VkSystemAllocationScope value specifying the scope of the lifetime of the allocation, as described &lt;&lt;memory-host-allocation-scope,here&gt;&gt;.</member>
      </members>
    </type>
    <type name="PFN_vkVoidFunction" summary="Dummy function pointer type returned by queries.">
      <specification />
      <members />
    </type>
    <type name="VkAccessFlagBits" summary="Bitmask specifying classes of memory access the will participate in a memory barrier dependency.">
      <specification />
      <members>
        <member name="VK_ACCESS_INDIRECT_COMMAND_READ_BIT">ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT indicates that the access is an indirect command structure read as part of an indirect drawing command.</member>
        <member name="VK_ACCESS_INDEX_READ_BIT">ename:VK_ACCESS_INDEX_READ_BIT indicates that the access is an index buffer read.</member>
        <member name="VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT">ename:VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT indicates that the access is a read via the vertex input bindings.</member>
        <member name="VK_ACCESS_UNIFORM_READ_BIT">ename:VK_ACCESS_UNIFORM_READ_BIT indicates that the access is a read via a uniform buffer or dynamic uniform buffer descriptor.</member>
        <member name="VK_ACCESS_INPUT_ATTACHMENT_READ_BIT">ename:VK_ACCESS_INPUT_ATTACHMENT_READ_BIT indicates that the access is a read via an input attachment descriptor.</member>
        <member name="VK_ACCESS_SHADER_READ_BIT">ename:VK_ACCESS_SHADER_READ_BIT indicates that the access is a read from a shader via any other descriptor type.</member>
        <member name="VK_ACCESS_SHADER_WRITE_BIT">ename:VK_ACCESS_SHADER_WRITE_BIT indicates that the access is a write or atomic from a shader via the same descriptor types as in ename:VK_ACCESS_SHADER_READ_BIT.</member>
        <member name="VK_ACCESS_COLOR_ATTACHMENT_READ_BIT">ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT indicates that the access is a read via a color attachment.</member>
        <member name="VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT">ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT indicates that the access is a write via a color or resolve attachment.</member>
        <member name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT">ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT indicates that the access is a read via a depth/stencil attachment.</member>
        <member name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT">ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT indicates that the access is a write via a depth/stencil attachment.</member>
        <member name="VK_ACCESS_TRANSFER_READ_BIT">ename:VK_ACCESS_TRANSFER_READ_BIT indicates that the access is a read from a transfer (copy, blit, resolve, etc.) operation. For the complete set of transfer operations, see &lt;&lt;synchronization-transfer,ename:VK_PIPELINE_STAGE_TRANSFER_BIT&gt;&gt;.</member>
        <member name="VK_ACCESS_TRANSFER_WRITE_BIT">ename:VK_ACCESS_TRANSFER_WRITE_BIT indicates that the access is a write from a transfer (copy, blit, resolve, etc.) operation. For the complete set of transfer operations, see &lt;&lt;synchronization-transfer,ename:VK_PIPELINE_STAGE_TRANSFER_BIT&gt;&gt;.</member>
        <member name="VK_ACCESS_HOST_READ_BIT">ename:VK_ACCESS_HOST_READ_BIT indicates that the access is a read via the host.</member>
        <member name="VK_ACCESS_HOST_WRITE_BIT">ename:VK_ACCESS_HOST_WRITE_BIT indicates that the access is a write via the host.</member>
        <member name="VK_ACCESS_MEMORY_READ_BIT">ename:VK_ACCESS_MEMORY_READ_BIT indicates that the access is a read via a non-specific unit attached to the memory. This unit may: be external to the Vulkan device or otherwise not part of the core Vulkan pipeline. When included in pname:dstAccessMask, all writes using access types in pname:srcAccessMask performed by pipeline stages in pname:srcStageMask must: be visible in memory.</member>
        <member name="VK_ACCESS_MEMORY_WRITE_BIT">ename:VK_ACCESS_MEMORY_WRITE_BIT indicates that the access is a write via a non-specific unit attached to the memory. This unit may: be external to the Vulkan device or otherwise not part of the core Vulkan pipeline. When included in pname:srcAccessMask, all access types in pname:dstAccessMask from pipeline stages in pname:dstStageMask will observe the side effects of commands that executed before the barrier. When included in pname:dstAccessMask all writes using access types in pname:srcAccessMask performed by pipeline stages in pname:srcStageMask must: be visible in memory.</member>
      </members>
    </type>
    <type name="VkAllocationCallbacks" summary="Structure containing callback function pointers for memory allocation.">
      <specification />
      <members>
        <member name="pUserData">pname:pUserData is a value to be interpreted by the implementation of the callbacks. When any of the callbacks in sname:VkAllocationCallbacks are called, the Vulkan implementation will pass this value as the first parameter to the callback. This value can: vary each time an allocator is passed into a command, even when the same object takes an allocator in multiple commands.</member>
        <member name="pfnAllocation">pname:pfnAllocation is a pointer to an application-defined memory allocation function of type tlink:PFN_vkAllocationFunction.</member>
        <member name="pfnReallocation">pname:pfnReallocation is a pointer to an application-defined memory reallocation function of type tlink:PFN_vkReallocationFunction.</member>
        <member name="pfnFree">pname:pfnFree is a pointer to an application-defined memory free function of type tlink:PFN_vkFreeFunction.</member>
        <member name="pfnInternalAllocation">pname:pfnInternalAllocation is a pointer to an application-defined function that is called by the implementation when the implementation makes internal allocations, and it is of type tlink:PFN_vkInternalAllocationNotification.</member>
        <member name="pfnInternalFree">pname:pfnInternalFree is a pointer to an application-defined function that is called by the implementation when the implementation frees internal allocations, and it is of type tlink:PFN_vkInternalFreeNotification.</member>
      </members>
    </type>
    <type name="VkAndroidSurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created Android surface object.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="window">pname:window is a pointer to the ANativeWindow to associate the surface with.</member>
      </members>
    </type>
    <type name="VkApplicationInfo" summary="Structure specifying application info.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="pApplicationName">pname:pApplicationName is a pointer to a null-terminated UTF-8 string containing the name of the application.</member>
        <member name="applicationVersion">pname:applicationVersion is an unsigned integer variable containing the developer-supplied version number of the application.</member>
        <member name="pEngineName">pname:pEngineName is a pointer to a null-terminated UTF-8 string containing the name of the engine (if any) used to create the application.</member>
        <member name="engineVersion">pname:engineVersion is an unsigned integer variable containing the developer-supplied version number of the engine used to create the application.</member>
        <member name="apiVersion">pname:apiVersion is the version of the Vulkan API against which the application expects to run, encoded as described in the &lt;&lt;fundamentals-versionnum,API Version Numbers and Semantics&gt;&gt; section. If pname:apiVersion is 0 the implementation must: ignore it, otherwise if the implementation does not support the requested pname:apiVersion it must: return ename:VK_ERROR_INCOMPATIBLE_DRIVER. The patch version number specified in pname:apiVersion is ignored when creating an instance object. Only the major and minor versions of the instance must: match those requested in pname:apiVersion.</member>
      </members>
    </type>
    <type name="VkAttachmentDescription" summary="Structure specifying an attachment description.">
      <specification />
      <members>
        <member name="flags">pname:flags is a bitmask describing additional properties of the attachment. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkAttachmentDescriptionFlagBits" summary="Bitmask specifying additional properties of an attachment.">
      <specification />
      <members />
    </type>
    <type name="VkAttachmentLoadOp" summary="Specify how contents of an attachment are treated at the beginning of a subpass.">
      <specification />
      <members />
    </type>
    <type name="VkAttachmentReference" summary="Structure specifying an attachment reference.">
      <specification />
      <members>
        <member name="attachment">pname:attachment is the index of the attachment of the render pass, and corresponds to the index of the corresponding element in the pname:pAttachments array of the sname:VkRenderPassCreateInfo structure. If any color or depth/stencil attachments are ename:VK_ATTACHMENT_UNUSED, then no writes occur for those attachments.</member>
        <member name="layout">pname:layout is a elink:VkImageLayout value specifying the layout the attachment uses during the subpass. The implementation will automatically perform layout transitions as needed between subpasses to make each subpass use the requested layouts.</member>
      </members>
    </type>
    <type name="VkAttachmentStoreOp" summary="Specify how contents of an attachment are treated at the end of a subpass.">
      <specification />
      <members />
    </type>
    <type name="VkBindSparseInfo" summary="Structure specifying a sparse binding operation.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="waitSemaphoreCount">pname:waitSemaphoreCount is the number of semaphores upon which to wait before executing the sparse binding operations for the batch.</member>
        <member name="pWaitSemaphores">pname:pWaitSemaphores is a pointer to an array of semaphores upon which to wait on before the sparse binding operations for this batch begin execution. If semaphores to wait on are provided, they define a &lt;&lt;synchronization-semaphores-waiting, semaphore wait operation&gt;&gt;.</member>
        <member name="bufferBindCount">pname:bufferBindCount is the number of sparse buffer bindings to perform in the batch.</member>
        <member name="pBufferBinds">pname:pBufferBinds is a pointer to an array of slink:VkSparseBufferMemoryBindInfo structures.</member>
        <member name="imageOpaqueBindCount">pname:imageOpaqueBindCount is the number of opaque sparse image bindings to perform.</member>
        <member name="pImageOpaqueBinds">pname:pImageOpaqueBinds is a pointer to an array of slink:VkSparseImageOpaqueMemoryBindInfo structures, indicating opaque sparse image bindings to perform.</member>
        <member name="imageBindCount">pname:imageBindCount is the number of sparse image bindings to perform.</member>
        <member name="pImageBinds">pname:pImageBinds is a pointer to an array of slink:VkSparseImageMemoryBindInfo structures, indicating sparse image bindings to perform.</member>
        <member name="signalSemaphoreCount">pname:signalSemaphoreCount is the number of semaphores to be signaled once the sparse binding operations specified by the structure have completed execution.</member>
        <member name="pSignalSemaphores">pname:pSignalSemaphores is a pointer to an array of semaphores which will be signaled when the sparse binding operations for this batch have completed execution. If semaphores to be signaled are provided, they define a &lt;&lt;synchronization-semaphores-signaling, semaphore signal operation&gt;&gt;.</member>
      </members>
    </type>
    <type name="VkBlendFactor" summary="Framebuffer blending factors.">
      <specification />
      <members />
    </type>
    <type name="VkBlendOp" summary="Framebuffer blending operations.">
      <specification />
      <members />
    </type>
    <type name="VkBool32" summary="Vulkan boolean type.">
      <specification />
      <members />
    </type>
    <type name="VkBorderColor" summary="Specify border color used for texture lookups.">
      <specification />
      <members />
    </type>
    <type name="VkBuffer" summary="Opaque handle to a buffer object.">
      <specification>
        <para>Buffers represent linear arrays of data which are used for various purposes by binding them to a graphics or compute pipeline via descriptor sets or via certain commands, or by directly specifying them as parameters to certain commands.</para>
      </specification>
      <members />
    </type>
    <type name="VkBufferCopy" summary="Structure specifying a buffer copy operation.">
      <specification />
      <members>
        <member name="srcOffset">pname:srcOffset is the starting offset in bytes from the start of pname:srcBuffer.</member>
        <member name="dstOffset">pname:dstOffset is the starting offset in bytes from the start of pname:dstBuffer.</member>
        <member name="size">pname:size is the number of bytes to copy.</member>
      </members>
    </type>
    <type name="VkBufferCreateFlagBits" summary="Bitmask specifying additional parameters of a buffer.">
      <specification />
      <members />
    </type>
    <type name="VkBufferCreateInfo" summary="Structure specifying the parameters of a newly created buffer object.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is a bitmask describing additional parameters of the buffer. See elink:VkBufferCreateFlagBits below for a description of the supported bits.</member>
        <member name="size">pname:size is the size in bytes of the buffer to be created.</member>
        <member name="usage">pname:usage is a bitmask describing the allowed usages of the buffer. See elink:VkBufferUsageFlagBits below for a description of the supported bits.</member>
        <member name="sharingMode">pname:sharingMode is the sharing mode of the buffer when it will be accessed by multiple queue families, see elink:VkSharingMode in the &lt;&lt;resources-sharing,Resource Sharing&gt;&gt; section below for supported values.</member>
        <member name="queueFamilyIndexCount">pname:queueFamilyIndexCount is the number of entries in the pname:pQueueFamilyIndices array.</member>
        <member name="pQueueFamilyIndices">pname:pQueueFamilyIndices is a list of queue families that will access this buffer (ignored if pname:sharingMode is not ename:VK_SHARING_MODE_CONCURRENT).</member>
      </members>
    </type>
    <type name="VkBufferImageCopy" summary="Structure specifying a buffer image copy operation.">
      <specification />
      <members>
        <member name="bufferOffset">pname:bufferOffset is the offset in bytes from the start of the buffer object where the image data is copied from or to.</member>
        <member name="bufferRowLength">pname:bufferRowLength and pname:bufferImageHeight specify the data in buffer memory as a subregion of a larger two- or three-dimensional image, and control the addressing calculations of data in buffer memory. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the pname:imageExtent.</member>
        <member name="imageSubresource">pname:imageSubresource is a slink:VkImageSubresourceLayers used to specify the specific image subresources of the image used for the source or destination image data.</member>
        <member name="imageOffset">pname:imageOffset selects the initial x, y, z offsets in texels of the sub-region of the source or destination image data.</member>
        <member name="imageExtent">pname:imageExtent is the size in texels of the image to copy in pname:width, pname:height and pname:depth. 1D images use only pname:x and pname:width. 2D images use pname:x, pname:y, pname:width and pname:height. 3D images use pname:x, pname:y, pname:z, pname:width, pname:height and pname:depth.</member>
      </members>
    </type>
    <type name="VkBufferMemoryBarrier" summary="Structure specifying the parameters of a buffer memory barrier.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="srcAccessMask">pname:srcAccessMask is a bitmask of the classes of memory accesses performed by the first set of commands that will participate in the dependency.</member>
        <member name="dstAccessMask">pname:dstAccessMask is a bitmask of the classes of memory accesses performed by the second set of commands that will participate in the dependency.</member>
        <member name="srcQueueFamilyIndex">pname:srcQueueFamilyIndex is the queue family that is relinquishing ownership of the range of pname:buffer to another queue, or ename:VK_QUEUE_FAMILY_IGNORED if there is no transfer of ownership.</member>
        <member name="dstQueueFamilyIndex">pname:dstQueueFamilyIndex is the queue family that is acquiring ownership of the range of pname:buffer from another queue, or ename:VK_QUEUE_FAMILY_IGNORED if there is no transfer of ownership.</member>
        <member name="buffer">pname:buffer is a handle to the buffer whose backing memory is affected by the barrier.</member>
        <member name="offset">pname:offset is an offset in bytes into the backing memory for pname:buffer; this is relative to the base offset as bound to the buffer (see flink:vkBindBufferMemory).</member>
        <member name="size">pname:size is a size in bytes of the affected area of backing memory for pname:buffer, or ename:VK_WHOLE_SIZE to use the range from pname:offset to the end of the buffer.</member>
      </members>
    </type>
    <type name="VkBufferUsageFlagBits" summary="Bitmask specifying allowed usage of a buffer.">
      <specification />
      <members>
        <member name="VK_BUFFER_USAGE_TRANSFER_SRC_BIT">ename:VK_BUFFER_USAGE_TRANSFER_SRC_BIT indicates that the buffer can: be used as the source of a _transfer command_ (see the definition of &lt;&lt;synchronization-transfer,ename:VK_PIPELINE_STAGE_TRANSFER_BIT&gt;&gt;).</member>
        <member name="VK_BUFFER_USAGE_TRANSFER_DST_BIT">ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT indicates that the buffer can: be used as the destination of a transfer command.</member>
        <member name="VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT">ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT indicates that the buffer can: be used to create a sname:VkBufferView suitable for occupying a sname:VkDescriptorSet slot of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.</member>
        <member name="VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT">ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT indicates that the buffer can: be used to create a sname:VkBufferView suitable for occupying a sname:VkDescriptorSet slot of type ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.</member>
        <member name="VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT">ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT indicates that the buffer can: be used in a sname:VkDescriptorBufferInfo suitable for occupying a sname:VkDescriptorSet slot either of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.</member>
        <member name="VK_BUFFER_USAGE_STORAGE_BUFFER_BIT">ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT indicates that the buffer can: be used in a sname:VkDescriptorBufferInfo suitable for occupying a sname:VkDescriptorSet slot either of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.</member>
        <member name="VK_BUFFER_USAGE_INDEX_BUFFER_BIT">ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT indicates that the buffer is suitable for passing as the pname:buffer parameter to fname:vkCmdBindIndexBuffer.</member>
        <member name="VK_BUFFER_USAGE_VERTEX_BUFFER_BIT">ename:VK_BUFFER_USAGE_VERTEX_BUFFER_BIT indicates that the buffer is suitable for passing as an element of the pname:pBuffers array to fname:vkCmdBindVertexBuffers.</member>
        <member name="VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT">ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT indicates that the buffer is suitable for passing as the pname:buffer parameter to fname:vkCmdDrawIndirect, fname:vkCmdDrawIndexedIndirect, or fname:vkCmdDispatchIndirect.</member>
      </members>
    </type>
    <type name="VkBufferView" summary="Opaque handle to a buffer view object.">
      <specification>
        <para>A _buffer view_ represents a contiguous range of a buffer and a specific format to be used to interpret the data. Buffer views are used to enable shaders to access buffer contents interpreted as formatted data. In order to create a valid buffer view, the buffer must: have been created with at least one of the following usage flags:</para>
        <para>  * ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT   * ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</para>
      </specification>
      <members />
    </type>
    <type name="VkBufferViewCreateInfo" summary="Structure specifying parameters of a newly created buffer view.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="buffer">pname:buffer is a sname:VkBuffer on which the view will be created.</member>
        <member name="format">pname:format is a elink:VkFormat describing the format of the data elements in the buffer.</member>
        <member name="offset">pname:offset is an offset in bytes from the base address of the buffer. Accesses to the buffer view from shaders use addressing that is relative to this starting offset.</member>
        <member name="range">pname:range is a size in bytes of the buffer view. If pname:range is equal to ename:VK_WHOLE_SIZE, the range from pname:offset to the end of the buffer is used. If ename:VK_WHOLE_SIZE is used and the remaining size of the buffer is not a multiple of the element size of pname:format, then the nearest smaller multiple is used.</member>
      </members>
    </type>
    <type name="VkClearAttachment" summary="Structure specifying a clear attachment.">
      <specification />
      <members>
        <member name="aspectMask">pname:aspectMask is a mask selecting the color, depth and/or stencil aspects of the attachment to be cleared. pname:aspectMask can: include ename:VK_IMAGE_ASPECT_COLOR_BIT for color attachments, ename:VK_IMAGE_ASPECT_DEPTH_BIT for depth/stencil attachments with a depth component, and ename:VK_IMAGE_ASPECT_STENCIL_BIT for depth/stencil attachments with a stencil component. If the subpass's depth/stencil attachment is ename:VK_ATTACHMENT_UNUSED, then the clear has no effect.</member>
        <member name="colorAttachment">pname:colorAttachment is only meaningful if ename:VK_IMAGE_ASPECT_COLOR_BIT is set in pname:aspectMask, in which case it is an index to the pname:pColorAttachments array in the slink:VkSubpassDescription structure of the current subpass which selects the color attachment to clear. If pname:colorAttachment is ename:VK_ATTACHMENT_UNUSED or is greater than or equal to sname:VkSubpassDescription::pname:colorAttachmentCount, then the clear has no effect.</member>
        <member name="clearValue">pname:clearValue is the color or depth/stencil value to clear the attachment to, as described in &lt;&lt;clears-values,Clear Values&gt;&gt; below.</member>
      </members>
    </type>
    <type name="VkClearColorValue" summary="Structure specifying a clear color value.">
      <specification />
      <members>
        <member name="float32">pname:float32 are the color clear values when the format of the image or attachment is floating point, unorm, snorm, uscaled, packed float, or sRGB. Floating point values are automatically converted to the format of the image, with the clear value being treated as linear if the image is sRGB.</member>
        <member name="int32">pname:int32 are the color clear values when the format of the image or attachment is signed integer. Signed integer values are converted to the format of the image by casting to the smaller type (with negative 32-bit values mapping to negative values in the smaller type). If the integer clear value is not representable in the target type (e.g. would overflow in conversion to that type), the clear value is undefined.</member>
        <member name="uint32">pname:uint32 are the color clear values when the format of the image or attachment is unsigned integer. Unsigned integer values are converted to the format of the image by casting to the integer type with fewer bits.</member>
      </members>
    </type>
    <type name="VkClearDepthStencilValue" summary="Structure specifying a clear depth stencil value.">
      <specification />
      <members>
        <member name="depth">pname:depth is the clear value for the depth aspect of the depth/stencil attachment. It is a floating-point value which is automatically converted to the attachment's format.</member>
        <member name="stencil">pname:stencil is the clear value for the stencil aspect of the depth/stencil attachment. It is a 32-bit integer value which is converted to the attachment's format by taking the appropriate number of LSBs.</member>
      </members>
    </type>
    <type name="VkClearRect" summary="Structure specifying a clear rectangle.">
      <specification />
      <members>
        <member name="rect">pname:rect is the two-dimensional region to be cleared.</member>
        <member name="baseArrayLayer">pname:baseArrayLayer is the first layer to be cleared.</member>
        <member name="layerCount">pname:layerCount is the number of layers to clear.</member>
      </members>
    </type>
    <type name="VkClearValue" summary="Structure specifying a clear value.">
      <specification />
      <members>
        <member name="color">pname:color specifies the color image clear values to use when clearing a color image or attachment.</member>
        <member name="depthStencil">pname:depthStencil specifies the depth and stencil clear values to use when clearing a depth/stencil image or attachment.</member>
      </members>
    </type>
    <type name="VkColorComponentFlagBits" summary="Bitmask controlling which components are written to the framebuffer.">
      <specification />
      <members />
    </type>
    <type name="VkColorSpaceKHR" summary="Supported color space of the presentation engine.">
      <specification />
      <members>
        <member name="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR">ename:VK_COLOR_SPACE_SRGB_NONLINEAR_KHR: The presentation engine supports the sRGB color space.</member>
      </members>
    </type>
    <type name="VkCommandBuffer" summary="Opaque handle to a command buffer object.">
      <specification>
        <para>Command buffers are objects used to record commands which can: be subsequently submitted to a device queue for execution. There are two levels of command buffers - _primary command buffers_, which can: execute secondary command buffers, and which are submitted to queues, and _secondary command buffers_, which can: be executed by primary command buffers, and which are not directly submitted to queues.</para>
      </specification>
      <members />
    </type>
    <type name="VkCommandBufferAllocateInfo" summary="Structure specifying the allocation parameters for command buffer object.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="commandPool">pname:commandPool is the name of the command pool that the command buffers allocate their memory from.</member>
        <member name="level">pname:level determines whether the command buffers are primary or secondary command buffers. Possible values include: + --</member>
      </members>
    </type>
    <type name="VkCommandBufferBeginInfo" summary="Structure specifying a command buffer begin operation.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is a bitmask indicating usage behavior for the command buffer. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkCommandBufferInheritanceInfo" summary="Structure specifying command buffer inheritance info.">
      <specification />
      <members>
        <member name="renderPass">pname:renderPass is a sname:VkRenderPass object defining which render passes the sname:VkCommandBuffer will be &lt;&lt;renderpass-compatibility, compatible&gt;&gt; with and can: be executed within. If the sname:VkCommandBuffer will not be executed within a render pass instance, pname:renderPass is ignored.</member>
        <member name="subpass">pname:subpass is the index of the subpass within pname:renderPass that the sname:VkCommandBuffer will be executed within. If the sname:VkCommandBuffer will not be executed within a render pass instance, pname:subpass is ignored.</member>
        <member name="framebuffer">pname:framebuffer optionally refers to the sname:VkFramebuffer object that the sname:VkCommandBuffer will be rendering to if it is executed within a render pass instance. It can: be dlink:VK_NULL_HANDLE if the framebuffer is not known, or if the sname:VkCommandBuffer will not be executed within a render pass instance. + [NOTE] .Note ==== Specifying the exact framebuffer that the secondary command buffer will be executed with may: result in better performance at command buffer execution time. ====</member>
        <member name="occlusionQueryEnable">pname:occlusionQueryEnable indicates whether the command buffer can: be executed while an occlusion query is active in the primary command buffer. If this is ename:VK_TRUE, then this command buffer can: be executed whether the primary command buffer has an occlusion query active or not. If this is ename:VK_FALSE, then the primary command buffer must: not have an occlusion query active.</member>
        <member name="queryFlags">pname:queryFlags indicates the query flags that can: be used by an active occlusion query in the primary command buffer when this secondary command buffer is executed. If this value includes the ename:VK_QUERY_CONTROL_PRECISE_BIT bit, then the active query can: return boolean results or actual sample counts. If this bit is not set, then the active query must: not use the ename:VK_QUERY_CONTROL_PRECISE_BIT bit. If this is a primary command buffer, then this value is ignored.</member>
        <member name="pipelineStatistics">pname:pipelineStatistics indicates the set of pipeline statistics that can: be counted by an active query in the primary command buffer when this secondary command buffer is executed. If this value includes a given bit, then this command buffer can: be executed whether the primary command buffer has a pipeline statistics query active that includes this bit or not. If this value excludes a given bit, then the active pipeline statistics query must: not be from a query pool that counts that statistic.</member>
      </members>
    </type>
    <type name="VkCommandBufferLevel" summary="Structure specifying a command buffer level.">
      <specification />
      <members />
    </type>
    <type name="VkCommandBufferResetFlagBits" summary="Bitmask controlling behavior of a command buffer reset.">
      <specification />
      <members />
    </type>
    <type name="VkCommandBufferUsageFlagBits" summary="Bitmask specifying usage behavior for command buffer.">
      <specification />
      <members />
    </type>
    <type name="VkCommandPool" summary="Opaque handle to a command pool object.">
      <specification>
        <para>Command pools are opaque objects that command buffer memory is allocated from, and which allow the implementation to amortize the cost of resource creation across multiple command buffers. Command pools are application-synchronized, meaning that a command pool must: not be used concurrently in multiple threads. That includes use via recording commands on any command buffers allocated from the pool, as well as operations that allocate, free, and reset command buffers or the pool itself.</para>
      </specification>
      <members />
    </type>
    <type name="VkCommandPoolCreateFlagBits" summary="Bitmask specifying usage behavior for a command pool.">
      <specification />
      <members />
    </type>
    <type name="VkCommandPoolCreateInfo" summary="Structure specifying parameters of a newly created command pool.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is a bitmask indicating usage behavior for the pool and command buffers allocated from it. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkCommandPoolResetFlagBits" summary="Bitmask controlling behavior of a command pool reset.">
      <specification />
      <members />
    </type>
    <type name="VkCompareOp" summary="Stencil comparison function.">
      <specification />
      <members>
        <member name="VK_COMPARE_OP_NEVER">ename:VK_COMPARE_OP_NEVER: the test never passes.</member>
        <member name="VK_COMPARE_OP_LESS">ename:VK_COMPARE_OP_LESS: the test passes when latexmath:[$R \lt S$].</member>
        <member name="VK_COMPARE_OP_EQUAL">ename:VK_COMPARE_OP_EQUAL: the test passes when latexmath:[$R = S$].</member>
        <member name="VK_COMPARE_OP_LESS_OR_EQUAL">ename:VK_COMPARE_OP_LESS_OR_EQUAL: the test passes when latexmath:[$R \leq S$].</member>
        <member name="VK_COMPARE_OP_GREATER">ename:VK_COMPARE_OP_GREATER: the test passes when latexmath:[$R \gt S$].</member>
        <member name="VK_COMPARE_OP_NOT_EQUAL">ename:VK_COMPARE_OP_NOT_EQUAL: the test passes when latexmath:[$R \neq S$].</member>
        <member name="VK_COMPARE_OP_GREATER_OR_EQUAL">ename:VK_COMPARE_OP_GREATER_OR_EQUAL: the test passes when latexmath:[$R \geq S$].</member>
        <member name="VK_COMPARE_OP_ALWAYS">ename:VK_COMPARE_OP_ALWAYS: the test always passes.</member>
      </members>
    </type>
    <type name="VkComponentMapping" summary="Structure specifying a color component mapping.">
      <specification />
      <members>
        <member name="r">pname:r determines the component value placed in the R component of the output vector.</member>
        <member name="g">pname:g determines the component value placed in the G component of the output vector.</member>
        <member name="b">pname:b determines the component value placed in the B component of the output vector.</member>
        <member name="a">pname:a determines the component value placed in the A component of the output vector.</member>
      </members>
    </type>
    <type name="VkComponentSwizzle" summary="Specify how a component is swizzled.">
      <specification />
      <members>
        <member name="VK_COMPONENT_SWIZZLE_IDENTITY">ename:VK_COMPONENT_SWIZZLE_IDENTITY: the component is set to the identity swizzle.</member>
        <member name="VK_COMPONENT_SWIZZLE_ZERO">ename:VK_COMPONENT_SWIZZLE_ZERO: the component is set to zero.</member>
        <member name="VK_COMPONENT_SWIZZLE_ONE">ename:VK_COMPONENT_SWIZZLE_ONE: the component is set to either 1 or 1.0 depending on whether the type of the image view format is integer or floating-point respectively, as determined by the &lt;&lt;features-formats-definition,Format Definition&gt;&gt; section for each elink:VkFormat.</member>
        <member name="VK_COMPONENT_SWIZZLE_R">ename:VK_COMPONENT_SWIZZLE_R: the component is set to the value of the R component of the image.</member>
        <member name="VK_COMPONENT_SWIZZLE_G">ename:VK_COMPONENT_SWIZZLE_G: the component is set to the value of the G component of the image.</member>
        <member name="VK_COMPONENT_SWIZZLE_B">ename:VK_COMPONENT_SWIZZLE_B: the component is set to the value of the B component of the image.</member>
        <member name="VK_COMPONENT_SWIZZLE_A">ename:VK_COMPONENT_SWIZZLE_A: the component is set to the value of the A component of the image.</member>
      </members>
    </type>
    <type name="VkCompositeAlphaFlagBitsKHR" summary="Alpha compositing modes supported on a device.">
      <specification />
      <members />
    </type>
    <type name="VkComputePipelineCreateInfo" summary="Structure specifying parameters of a newly created compute pipeline.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags provides options for pipeline creation, and is of type elink:VkPipelineCreateFlagBits.</member>
        <member name="stage">pname:stage is a slink:VkPipelineShaderStageCreateInfo describing the compute shader.</member>
        <member name="layout">pname:layout is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.</member>
        <member name="basePipelineHandle">pname:basePipelineHandle is a pipeline to derive from</member>
        <member name="basePipelineIndex">pname:basePipelineIndex is an index into the pname:pCreateInfos parameter to use as a pipeline to derive from</member>
      </members>
    </type>
    <type name="VkCopyDescriptorSet" summary="Structure specifying a copy descriptor set operation.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="srcSet">pname:srcSet, pname:srcBinding, and pname:srcArrayElement are the source set, binding, and array element, respectively.</member>
        <member name="dstSet">pname:dstSet, pname:dstBinding, and pname:dstArrayElement are the destination set, binding, and array element, respectively.</member>
        <member name="descriptorCount">pname:descriptorCount is the number of descriptors to copy from the source to destination. If pname:descriptorCount is greater than the number of remaining array elements in the source or destination binding, those affect consecutive bindings in a manner similar to slink:VkWriteDescriptorSet above.</member>
      </members>
    </type>
    <type name="VkCullModeFlagBits" summary="Bitmask controlling triangle culling.">
      <specification />
      <members />
    </type>
    <type name="VkDedicatedAllocationBufferCreateInfoNV" summary="Specify that a buffer is bound to a dedicated memory resource.">
      <specification>
        <para>If the pname:pNext list includes a sname:VkDedicatedAllocationBufferCreateInfoNV structure, then that structure includes an enable controlling whether the buffer will have a dedicated memory allocation bound to it.</para>
      </specification>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="dedicatedAllocation">pname:dedicatedAllocation indicates whether the buffer will have a dedicated allocation bound to it.</member>
      </members>
    </type>
    <type name="VkDedicatedAllocationImageCreateInfoNV" summary="Specify that an image is bound to a dedicated memory resource.">
      <specification>
        <para>If the pname:pNext list includes a sname:VkDedicatedAllocationImageCreateInfoNV structure, then that structure includes an enable controlling whether the image will have a dedicated memory allocation bound to it.</para>
      </specification>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="dedicatedAllocation">pname:dedicatedAllocation indicates whether the image will have a dedicated allocation bound to it.</member>
      </members>
    </type>
    <type name="VkDedicatedAllocationMemoryAllocateInfoNV" summary="Specify a dedicated memory allocation resource.">
      <specification>
        <para>If the pname:pNext list includes a sname:VkDedicatedAllocationMemoryAllocateInfoNV structure, then that structure includes a handle of the sole buffer or image resource that the memory can: be bound to.</para>
      </specification>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="image">pname:image is sname:VK_NULL_HANDLE or a handle of an image which this memory will be bound to.</member>
        <member name="buffer">pname:buffer is sname:VK_NULL_HANDLE or a handle of a buffer which this memory will be bound to.</member>
      </members>
    </type>
    <type name="VkDependencyFlagBits" summary="Bitmask specifying dependencies between subpasses.">
      <specification />
      <members />
    </type>
    <type name="VkDescriptorBufferInfo" summary="Structure specifying descriptor buffer info.">
      <specification />
      <members>
        <member name="buffer">pname:buffer is the buffer resource.</member>
        <member name="offset">pname:offset is the offset in bytes from the start of pname:buffer. Access to buffer memory via this descriptor uses addressing that is relative to this starting offset.</member>
        <member name="range">pname:range is the size in bytes that is used for this descriptor update, or ename:VK_WHOLE_SIZE to use the range from pname:offset to the end of the buffer. + -- [NOTE] .Note ==== When using ename:VK_WHOLE_SIZE, the effective range must: not be larger than the maximum range for the descriptor type (&lt;&lt;features-limits-maxUniformBufferRange, maxUniformBufferRange&gt;&gt; or &lt;&lt;features-limits-maxStorageBufferRange, maxStorageBufferRange&gt;&gt;). This means that ename:VK_WHOLE_SIZE is not typically useful in the common case where uniform buffer descriptors are suballocated from a buffer that is much larger than pname:maxUniformBufferRange. ==== -- + For ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC and ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC descriptor types, pname:offset is the base offset from which the dynamic offset is applied and pname:range is the static size used for all dynamic offsets.</member>
      </members>
    </type>
    <type name="VkDescriptorImageInfo" summary="Structure specifying descriptor image info.">
      <specification />
      <members>
        <member name="sampler">pname:sampler is a sampler handle, and is used in descriptor updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLER and ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER if the binding being updated does not use immutable samplers.</member>
        <member name="imageView">pname:imageView is an image view handle, and is used in descriptor updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.</member>
        <member name="imageLayout">pname:imageLayout is the layout that the image will be in at the time this descriptor is accessed. pname:imageLayout is used in descriptor updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.</member>
      </members>
    </type>
    <type name="VkDescriptorPool" summary="Opaque handle to a descriptor pool object.">
      <specification>
        <para>A _descriptor pool_ maintains a pool of descriptors, from which descriptor sets are allocated. Descriptor pools are externally synchronized, meaning that the application must: not allocate and/or free descriptor sets from the same pool in multiple threads simultaneously.</para>
      </specification>
      <members />
    </type>
    <type name="VkDescriptorPoolCreateFlagBits" summary="Bitmask specifying certain supported operations on a descriptor pool.">
      <specification />
      <members />
    </type>
    <type name="VkDescriptorPoolCreateInfo" summary="Structure specifying parameters of a newly created descriptor pool.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags specifies certain supported operations on the pool. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkDescriptorPoolSize" summary="Structure specifying descriptor pool size.">
      <specification />
      <members>
        <member name="type">pname:type is the type of descriptor.</member>
        <member name="descriptorCount">pname:descriptorCount is the number of descriptors of that type to allocate.</member>
      </members>
    </type>
    <type name="VkDescriptorSet" summary="Opaque handle to a descriptor set object.">
      <specification />
      <members />
    </type>
    <type name="VkDescriptorSetAllocateInfo" summary="Structure specifying the allocation parameters for descriptor sets.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="descriptorPool">pname:descriptorPool is the pool which the sets will be allocated from.</member>
        <member name="descriptorSetCount">pname:descriptorSetCount determines the number of descriptor sets to be allocated from the pool.</member>
        <member name="pSetLayouts">pname:pSetLayouts is an array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated.</member>
      </members>
    </type>
    <type name="VkDescriptorSetLayout" summary="Opaque handle to a descriptor set layout object.">
      <specification>
        <para>A descriptor set layout object is defined by an array of zero or more descriptor bindings. Each individual descriptor binding is specified by a descriptor type, a count (array size) of the number of descriptors in the binding, a set of shader stages that can: access the binding, and (if using immutable samplers) an array of sampler descriptors.</para>
      </specification>
      <members />
    </type>
    <type name="VkDescriptorSetLayoutBinding" summary="Structure specifying a descriptor set layout binding.">
      <specification />
      <members>
        <member name="binding">pname:binding is the binding number of this entry and corresponds to a resource of the same binding number in the shader stages.</member>
        <member name="descriptorType">pname:descriptorType is a elink:VkDescriptorType specifying which type of resource descriptors are used for this binding.</member>
        <member name="descriptorCount">pname:descriptorCount is the number of descriptors contained in the binding, accessed in a shader as an array. If pname:descriptorCount is zero this binding entry is reserved and the resource must: not be accessed from any stage via this binding within any pipeline using the set layout.</member>
        <member name="stageFlags">pname:stageFlags member is a bitmask of elink:VkShaderStageFlagBits specifying which pipeline shader stages can: access a resource for this binding. ename:VK_SHADER_STAGE_ALL is a shorthand specifying that all defined shader stages, including any additional stages defined by extensions, can: access the resource. + -- If a shader stage is not included in pname:stageFlags, then a resource must: not be accessed from that stage via this binding within any pipeline using the set layout. There are no limitations on what combinations of stages can: be used by a descriptor binding, and in particular a binding can: be used by both graphics stages and the compute stage. --</member>
        <member name="pImmutableSamplers">pname:pImmutableSamplers affects initialization of samplers. If pname:descriptorType specifies a ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER type descriptor, then pname:pImmutableSamplers can: be used to initialize a set of _immutable samplers_. Immutable samplers are permanently bound into the set layout; later binding a sampler into an immutable sampler slot in a descriptor set is not allowed. If pname:pImmutableSamplers is not `NULL`, then it is considered to be a pointer to an array of sampler handles that will be consumed by the set layout and used for the corresponding binding. If pname:pImmutableSamplers is `NULL`, then the sampler slots are dynamic and sampler handles must: be bound into descriptor sets using this layout. If pname:descriptorType is not one of these descriptor types, then pname:pImmutableSamplers is ignored.</member>
      </members>
    </type>
    <type name="VkDescriptorSetLayoutCreateInfo" summary="Structure specifying parameters of a newly created descriptor set layout.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="bindingCount">pname:bindingCount is the number of elements in pname:pBindings.</member>
        <member name="pBindings">pname:pBindings is a pointer to an array of slink:VkDescriptorSetLayoutBinding structures.</member>
      </members>
    </type>
    <type name="VkDescriptorType" summary="Specifies the type of a descriptor in a descriptor set.">
      <specification />
      <members />
    </type>
    <type name="VkDevice" summary="Opaque handle to a device object.">
      <specification />
      <members />
    </type>
    <type name="VkDeviceCreateInfo" summary="Structure specifying parameters of a newly created device.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="queueCreateInfoCount">pname:queueCreateInfoCount is the unsigned integer size of the pname:pQueueCreateInfos array. Refer to the &lt;&lt;devsandqueues-queue-creation,Queue Creation&gt;&gt; section below for further details.</member>
        <member name="pQueueCreateInfos">pname:pQueueCreateInfos is a pointer to an array of slink:VkDeviceQueueCreateInfo structures describing the queues that are requested to be created along with the logical device. Refer to the &lt;&lt;devsandqueues-queue-creation,Queue Creation&gt;&gt; section below for further details.</member>
        <member name="enabledLayerCount">pname:enabledLayerCount is deprecated and ignored.</member>
        <member name="ppEnabledLayerNames">pname:ppEnabledLayerNames is deprecated and ignored. See &lt;&lt;extended-functionality-device-layer-deprecation,Device Layer Deprecation&gt;&gt;.</member>
        <member name="enabledExtensionCount">pname:enabledExtensionCount is the number of device extensions to enable.</member>
        <member name="ppEnabledExtensionNames">pname:ppEnabledExtensionNames is a pointer to an array of pname:enabledExtensionCount null-terminated UTF-8 strings containing the names of extensions to enable for the created device. See the &lt;&lt;extended-functionality-extensions,Extensions&gt;&gt; section for further details.</member>
        <member name="pEnabledFeatures">pname:pEnabledFeatures is `NULL` or a pointer to a slink:VkPhysicalDeviceFeatures structure that contains boolean indicators of all the features to be enabled. Refer to the &lt;&lt;features-features,Features&gt;&gt; section for further details.</member>
      </members>
    </type>
    <type name="VkDeviceMemory" summary="Opaque handle to a device memory object.">
      <specification>
        <para>A Vulkan device operates on data in device memory via memory objects that are represented in the API by a sname:VkDeviceMemory handle.</para>
      </specification>
      <members />
    </type>
    <type name="VkDeviceQueueCreateInfo" summary="Structure specifying parameters of a newly created device queue.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="queueFamilyIndex">pname:queueFamilyIndex is an unsigned integer indicating the index of the queue family to create on this device. This index corresponds to the index of an element of the pname:pQueueFamilyProperties array that was returned by fname:vkGetPhysicalDeviceQueueFamilyProperties.</member>
        <member name="queueCount">pname:queueCount is an unsigned integer specifying the number of queues to create in the queue family indicated by pname:queueFamilyIndex.</member>
        <member name="pQueuePriorities">pname:pQueuePriorities is an array of pname:queueCount normalized floating point values, specifying priorities of work that will be submitted to each created queue. See &lt;&lt;devsandqueues-priority,Queue Priority&gt;&gt; for more information.</member>
      </members>
    </type>
    <type name="VkDeviceSize" summary="Vulkan device memory size and offsets.">
      <specification />
      <members />
    </type>
    <type name="VkDispatchIndirectCommand" summary="Structure specifying a dispatch indirect command.">
      <specification />
      <members>
        <member name="x">pname:x is the number of local workgroups to dispatch in the X dimension.</member>
        <member name="y">pname:y is the number of local workgroups to dispatch in the Y dimension.</member>
        <member name="z">pname:z is the number of local workgroups to dispatch in the Z dimension.</member>
      </members>
    </type>
    <type name="VkDisplayModeCreateInfoKHR" summary="Structure specifying parameters of a newly created display mode object.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use, and must: be zero.</member>
        <member name="parameters">pname:parameters is a sname:VkDisplayModeParametersKHR structure describing the display parameters to use in creating the new mode. If the parameters are not compatible with the specified display, the implementation must: return ename:VK_ERROR_INITIALIZATION_FAILED.</member>
      </members>
    </type>
    <type name="VkDisplayModeParametersKHR" summary="Structure describing display parameters associated with a display mode.">
      <specification />
      <members>
        <member name="visibleRegion">pname:visibleRegion is the 2D extents of the visible region.</member>
        <member name="refreshRate">pname:refreshRate is a basetype:uint32_t that is the number of times the display is refreshed each second multiplied by 1000.</member>
      </members>
    </type>
    <type name="VkDisplayModePropertiesKHR" summary="Structure describing display mode properties.">
      <specification />
      <members>
        <member name="displayMode">pname:displayMode is a handle to the display mode described in this structure.  This handle will be valid for the lifetime of the Vulkan instance.</member>
        <member name="parameters">pname:parameters is a sname:VkDisplayModeParametersKHR structure describing the display parameters associated with pname:displayMode.</member>
      </members>
    </type>
    <type name="VkDisplayPlaneAlphaFlagBitsKHR" summary="Alpha blending type.">
      <specification />
      <members />
    </type>
    <type name="VkDisplayPlaneCapabilitiesKHR" summary="Structure describing capabilities of a mode and plane combination.">
      <specification />
      <members>
        <member name="supportedAlpha">pname:supportedAlpha is a bitmask of elink:VkDisplayPlaneAlphaFlagBitsKHR describing the supported alpha blending modes.</member>
        <member name="minSrcPosition">pname:minSrcPosition is the minimum source rectangle offset supported by this plane using the specified mode.</member>
        <member name="maxSrcPosition">pname:maxSrcPosition is the maximum source rectangle offset supported by this plane using the specified mode. The pname:x and pname:y components of pname:maxSrcPosition must: each be greater than or equal to the pname:x and pname:y components of pname:minSrcPosition, respectively.</member>
        <member name="minSrcExtent">pname:minSrcExtent is the minimum source rectangle size supported by this plane using the specified mode.</member>
        <member name="maxSrcExtent">pname:maxSrcExtent is the maximum source rectangle size supported by this plane using the specified mode.</member>
        <member name="minDstPosition">pname:minDstPosition, pname:maxDstPosition, pname:minDstExtent, pname:maxDstExtent all have similar semantics to their corresponding "Src" equivalents, but apply to the output region within the mode rather than the input region within the source image. Unlike the "Src" offsets, pname:minDstPosition and pname:maxDstPosition may: contain negative values.</member>
      </members>
    </type>
    <type name="VkDisplayPlanePropertiesKHR" summary="Structure describing display plane properties.">
      <specification />
      <members>
        <member name="currentDisplay">pname:currentDisplay is the handle of the display the plane is currently associated with. If the plane is not currently attached to any displays, this will be sname:VK_NULL_HANDLE.</member>
        <member name="currentStackIndex">pname:currentStackIndex is the current z-order of the plane. This will be between 0 and the value returned by fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pname:pPropertyCount.</member>
      </members>
    </type>
    <type name="VkDisplayPresentInfoKHR" summary="Structure describing parameters of a queue presentation to a swapchain.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="srcRect">pname:srcRect is a rectangular region of pixels to present. It must: be a subset of the image being presented. If sname:VkDisplayPresentInfoKHR is not specified, this region will be assumed to be the entire presentable image.</member>
        <member name="dstRect">pname:dstRect is a rectangular region within the visible region of the swapchain's display mode. If sname:VkDisplayPresentInfoKHR is not specified, this region will be assumed to be the entire visible region of the visible region of the swapchain's mode. If the specified rectangle is a subset of the display mode's visible region, content from display planes below the swapchain's plane will be visible outside the rectangle. If there are no planes below the swapchain's, the area outside the specified rectangle will be black. If portions of the specified rectangle are outside of the display's visible region, pixels mapping only to those portions of the rectangle will be discarded.</member>
        <member name="persistent">pname:persistent: If this is ename:VK_TRUE, the display engine will enable buffered mode on displays that support it. This allows the display engine to stop sending content to the display until a new image is presented. The display will instead maintain a copy of the last presented image. This allows less power to be used, but may: increase presentation latency. If sname:VkDisplayPresentInfoKHR is not specified, persistent mode will not be used.</member>
      </members>
    </type>
    <type name="VkDisplayPropertiesKHR" summary="Structure describing an available display device.">
      <specification />
      <members>
        <member name="display">pname:display is a handle that is used to refer to the display described here. This handle will be valid for the lifetime of the Vulkan instance.</member>
        <member name="displayName">pname:displayName is a pointer to a NULL-terminated string containing the name of the display. Generally, this will be the name provided by the display's EDID. It can: be `NULL` if no suitable name is available.</member>
        <member name="physicalDimensions">pname:physicalDimensions describes the physical width and height of the visible portion of the display, in millimeters.</member>
        <member name="physicalResolution">pname:physicalResolution describes the physical, native, or preferred resolution of the display.</member>
      </members>
    </type>
    <type name="VkDisplaySurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created display plane surface object.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use, and must: be zero.</member>
        <member name="displayMode">pname:displayMode is the mode to use when displaying this surface.</member>
        <member name="planeIndex">pname:planeIndex is the plane on which this surface appears.</member>
        <member name="planeStackIndex">pname:planeStackIndex is the z-order of the plane.</member>
        <member name="transform">pname:transform is the transform to apply to the images as part of the scanout operation.</member>
        <member name="globalAlpha">pname:globalAlpha is the global alpha value.  This value is ignored if pname:alphaMode is not ename:VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR.</member>
        <member name="alphaMode">pname:alphaMode is the type of alpha blending to use.</member>
        <member name="imageSize">pname:imageSize The size of the presentable images to use with the surface.</member>
      </members>
    </type>
    <type name="VkDrawIndexedIndirectCommand" summary="Structure specifying a draw indexed indirect command.">
      <specification />
      <members>
        <member name="indexCount">pname:indexCount is the number of vertices to draw.</member>
        <member name="instanceCount">pname:instanceCount is the number of instances to draw.</member>
        <member name="firstIndex">pname:firstIndex is the base index within the index buffer.</member>
        <member name="vertexOffset">pname:vertexOffset is the value added to the vertex index before indexing into the vertex buffer.</member>
        <member name="firstInstance">pname:firstInstance is the instance ID of the first instance to draw.</member>
      </members>
    </type>
    <type name="VkDrawIndirectCommand" summary="Structure specifying a draw indirect command.">
      <specification />
      <members>
        <member name="vertexCount">pname:vertexCount is the number of vertices to draw.</member>
        <member name="instanceCount">pname:instanceCount is the number of instances to draw.</member>
        <member name="firstVertex">pname:firstVertex is the index of the first vertex to draw.</member>
        <member name="firstInstance">pname:firstInstance is the instance ID of the first instance to draw.</member>
      </members>
    </type>
    <type name="VkDynamicState" summary="Indicate which dynamic state is taken from dynamic state commands.">
      <specification />
      <members>
        <member name="VK_DYNAMIC_STATE_VIEWPORT">ename:VK_DYNAMIC_STATE_VIEWPORT indicates that the pname:pViewports state in sname:VkPipelineViewportStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetViewport before any draw commands. The number of viewports used by a pipeline is still specified by the pname:viewportCount member of sname:VkPipelineViewportStateCreateInfo.</member>
        <member name="VK_DYNAMIC_STATE_SCISSOR">ename:VK_DYNAMIC_STATE_SCISSOR indicates that the pname:pScissors state in sname:VkPipelineViewportStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetScissor before any draw commands. The number of scissor rectangles used by a pipeline is still specified by the pname:scissorCount member of sname:VkPipelineViewportStateCreateInfo.</member>
        <member name="VK_DYNAMIC_STATE_LINE_WIDTH">ename:VK_DYNAMIC_STATE_LINE_WIDTH indicates that the pname:lineWidth state in sname:VkPipelineRasterizationStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetLineWidth before any draw commands that generate line primitives for the rasterizer.</member>
        <member name="VK_DYNAMIC_STATE_DEPTH_BIAS">ename:VK_DYNAMIC_STATE_DEPTH_BIAS indicates that the pname:depthBiasConstantFactor, pname:depthBiasClamp and pname:depthBiasSlopeFactor states in sname:VkPipelineRasterizationStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetDepthBias before any draws are performed with pname:depthBiasEnable in sname:VkPipelineRasterizationStateCreateInfo set to ename:VK_TRUE.</member>
        <member name="VK_DYNAMIC_STATE_BLEND_CONSTANTS">ename:VK_DYNAMIC_STATE_BLEND_CONSTANTS indicates that the pname:blendConstants state in sname:VkPipelineColorBlendStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetBlendConstants before any draws are performed with a pipeline state with sname:VkPipelineColorBlendAttachmentState member pname:blendEnable set to ename:VK_TRUE and any of the blend functions using a constant blend color.</member>
        <member name="VK_DYNAMIC_STATE_DEPTH_BOUNDS">ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS indicates that the pname:minDepthBounds and pname:maxDepthBounds states of slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetDepthBounds before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:depthBoundsTestEnable set to ename:VK_TRUE.</member>
        <member name="VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK">ename:VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK indicates that the pname:compareMask state in sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and pname:back will be ignored and must: be set dynamically with flink:vkCmdSetStencilCompareMask before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:stencilTestEnable set to ename:VK_TRUE</member>
        <member name="VK_DYNAMIC_STATE_STENCIL_WRITE_MASK">ename:VK_DYNAMIC_STATE_STENCIL_WRITE_MASK indicates that the pname:writeMask state in sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and pname:back will be ignored and must: be set dynamically with flink:vkCmdSetStencilWriteMask before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:stencilTestEnable set to ename:VK_TRUE</member>
        <member name="VK_DYNAMIC_STATE_STENCIL_REFERENCE">ename:VK_DYNAMIC_STATE_STENCIL_REFERENCE indicates that the pname:reference state in sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and pname:back will be ignored and must: be set dynamically with flink:vkCmdSetStencilReference before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:stencilTestEnable set to ename:VK_TRUE</member>
      </members>
    </type>
    <type name="VkEvent" summary="Opaque handle to a event object.">
      <specification>
        <para>Events represent a fine-grained synchronization primitive that can: be used to gauge progress through a sequence of commands executed on a queue by Vulkan. An event is initially in the unsignaled state. It can: be signaled by a device, using commands inserted into the command buffer, or by the host. It can: also be reset to the unsignaled state by a device or the host. The host can: query the state of an event. A device can: wait for one or more events to become signaled.</para>
      </specification>
      <members />
    </type>
    <type name="VkEventCreateInfo" summary="Structure specifying parameters of a newly created event.">
      <specification />
      <members>
        <member name="flags">pname:flags is reserved for future use.</member>
      </members>
    </type>
    <type name="VkExportMemoryWin32HandleInfoNV" summary="Specify security attributes and access rights for Win32 memory handles.">
      <specification>
        <para>When slink:VkExportMemoryAllocateInfoNV::pname:handleTypes includes ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV, add a sname:VkExportMemoryWin32HandleInfoNV to the pname:pNext chain of the slink:VkExportMemoryAllocateInfoNV structure to specify security attributes and access rights for the memory object's external handle.</para>
      </specification>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="pAttributes">pname:pAttributes is a pointer to a Windows sname:SECURITY_ATTRIBUTES structure specifying security attributes of the handle.</member>
        <member name="dwAccess">pname:dwAccess is a basetype:DWORD specifying access rights of the handle.</member>
      </members>
    </type>
    <type name="VkExtensionProperties" summary="Structure specifying a extension properties.">
      <specification />
      <members>
        <member name="extensionName">pname:extensionName is a null-terminated string specifying the name of the extension.</member>
        <member name="specVersion">pname:specVersion is the version of this extension. It is an integer, incremented with backward compatible changes.</member>
      </members>
    </type>
    <type name="VkExtent2D" summary="Structure specifying a two-dimensional extent.">
      <specification />
      <members />
    </type>
    <type name="VkExtent3D" summary="Structure specifying a three-dimensional extent.">
      <specification />
      <members />
    </type>
    <type name="VkExternalImageFormatPropertiesNV" summary="Structure specifying external image format properties.">
      <specification />
      <members>
        <member name="imageFormatProperties">pname:imageFormatProperties will be filled in as when calling flink:vkGetPhysicalDeviceImageFormatProperties, but the values returned may: vary depending on the external handle type requested.</member>
        <member name="externalMemoryFeatures">pname:externalMemoryFeatures is a bitmask of elink:VkExternalMemoryFeatureFlagBitsNV indicating properties of the external memory handle type (flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType) being queried, or 0 if the external memory handle type is 0.</member>
        <member name="exportFromImportedHandleTypes">pname:exportFromImportedHandleTypes is a bitmask of elink:VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for every external handle type that may: be used to create memory from which the handles of the type specified in flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType can: be exported, or 0 if the external memory handle type is 0.</member>
        <member name="compatibleHandleTypes">pname:compatibleHandleTypes is a bitmask of elink:VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for every external handle type that may: be specified simultaneously with the handle type specified by flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType when calling flink:vkAllocateMemory, or 0 if the external memory handle type is 0. pname:compatibleHandleTypes will always contain flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType</member>
      </members>
    </type>
    <type name="VkExternalMemoryFeatureFlagBitsNV" summary="Bitmask specifying external memory features.">
      <specification />
      <members>
        <member name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV">ename:VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV: External memory of the specified type must: be created as a dedicated allocation when used in the manner specified.</member>
        <member name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV">ename:VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV: The implementation supports exporting handles of the specified type.</member>
        <member name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV">ename:VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV: The implementation supports importing handles of the specified type.</member>
      </members>
    </type>
    <type name="VkExternalMemoryHandleTypeFlagBitsNV" summary="Bitmask specifying memory handle types.">
      <specification />
      <members />
    </type>
    <type name="VkExternalMemoryImageCreateInfoNV" summary="Specify that an image may be backed by external memory.">
      <specification>
        <para>If the pname:pNext list includes a sname:VkExternalMemoryImageCreateInfoNV structure, then that structure defines a set of external memory handle types that may: be used as backing store for the image.</para>
      </specification>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="handleTypes">pname:handleTypes is a bitmask of elink:VkExternalMemoryHandleTypeFlagBitsNV specifying one or more external memory handle types. The types must: all be compatible with each other and the other image creation parameters, as reported by flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV.</member>
      </members>
    </type>
    <type name="VkFence" summary="Opaque handle to a fence object.">
      <specification>
        <para>Fences can: be used by the host to determine completion of execution of _queue operations_.</para>
        <para>A fence's status is always either _signaled_ or _unsignaled_. The host can: poll the status of a single fence, or wait for any or all of a group of fences to become signaled.</para>
      </specification>
      <members />
    </type>
    <type name="VkFenceCreateFlagBits" summary="Bitmask specifying initial state and behavior of a fence.">
      <specification />
      <members />
    </type>
    <type name="VkFenceCreateInfo" summary="Structure specifying parameters of a newly created fence.">
      <specification />
      <members>
        <member name="flags">pname:flags defines the initial state and behavior of the fence. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkFilter" summary="Specify filters used for texture lookups.">
      <specification />
      <members />
    </type>
    <type name="VkFlags" summary="Vulkan bitmasks.">
      <specification />
      <members />
    </type>
    <type name="VkFormat" summary="Available image formats.">
      <specification />
      <members />
    </type>
    <type name="VkFormatFeatureFlagBits" summary="Bitmask specifying features supported by a buffer.">
      <specification />
      <members />
    </type>
    <type name="VkFormatProperties" summary="Structure specifying image format properties.">
      <specification />
      <members>
        <member name="linearTilingFeatures">pname:linearTilingFeatures describes the features supported by ename:VK_IMAGE_TILING_LINEAR.</member>
        <member name="optimalTilingFeatures">pname:optimalTilingFeatures describes the features supported by ename:VK_IMAGE_TILING_OPTIMAL.</member>
        <member name="bufferFeatures">pname:bufferFeatures describes the features supported by buffers.</member>
      </members>
    </type>
    <type name="VkFramebuffer" summary="Opaque handle to a framebuffer object.">
      <specification>
        <para>Render passes operate in conjunction with _framebuffers_. Framebuffers represent a collection of specific memory attachments that a render pass instance uses.</para>
      </specification>
      <members />
    </type>
    <type name="VkFramebufferCreateInfo" summary="Structure specifying parameters of a newly created framebuffer.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="renderPass">pname:renderPass is a render pass that defines what render passes the framebuffer will be compatible with. See &lt;&lt;renderpass-compatibility,Render Pass Compatibility&gt;&gt; for details.</member>
        <member name="attachmentCount">pname:attachmentCount is the number of attachments.</member>
        <member name="pAttachments">pname:pAttachments is an array of sname:VkImageView handles, each of which will be used as the corresponding attachment in a render pass instance.</member>
        <member name="width">pname:width, pname:height and pname:layers define the dimensions of the framebuffer.</member>
      </members>
    </type>
    <type name="VkFrontFace" summary="Interpret polygon front-facing orientation.">
      <specification>
        <para>The first step of polygon rasterization is to determine whether the triangle is _back-facing_ or _front-facing_. This determination is made based on the sign of the (clipped or unclipped) polygon's area computed in framebuffer coordinates. One way to compute this area is:</para>
        <para>[latexmath] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ \[   a = -{1 \over 2}\sum_{i=0}^{n-1}         x_f^i y_f^{i \oplus 1} -         x_f^{i \oplus 1} y_f^i \] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</para>
        <para>where latexmath:[$x_f^i$] and latexmath:[$y_f^i$] are the latexmath:[$x$] and latexmath:[$y$] framebuffer coordinates of the latexmath:[$i$]th vertex of the latexmath:[$n$]-vertex polygon (vertices are numbered starting at zero for the purposes of this computation) and latexmath:[$i \oplus 1$] is latexmath:[$(i + 1)~ \textrm{mod}~ n$].</para>
      </specification>
      <members />
    </type>
    <type name="VkGraphicsPipelineCreateInfo" summary="Structure specifying parameters of a newly created graphics pipeline.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is a bitmask of elink:VkPipelineCreateFlagBits controlling how the pipeline will be generated, as described below.</member>
        <member name="stageCount">pname:stageCount is the number of entries in the pname:pStages array.</member>
        <member name="pStages">pname:pStages is an array of size pname:stageCount structures of type slink:VkPipelineShaderStageCreateInfo describing the set of the shader stages to be included in the graphics pipeline.</member>
        <member name="pVertexInputState">pname:pVertexInputState is a pointer to an instance of the slink:VkPipelineVertexInputStateCreateInfo structure.</member>
        <member name="pInputAssemblyState">pname:pInputAssemblyState is a pointer to an instance of the slink:VkPipelineInputAssemblyStateCreateInfo structure which determines input assembly behavior, as described in &lt;&lt;drawing, Drawing Commands&gt;&gt;.</member>
        <member name="pTessellationState">pname:pTessellationState is a pointer to an instance of the slink:VkPipelineTessellationStateCreateInfo structure, or `NULL` if the pipeline does not include a tessellation control shader stage and tessellation evaluation shader stage.</member>
        <member name="pViewportState">pname:pViewportState is a pointer to an instance of the slink:VkPipelineViewportStateCreateInfo structure, or `NULL` if the pipeline has rasterization disabled.</member>
        <member name="pRasterizationState">pname:pRasterizationState is a pointer to an instance of the slink:VkPipelineRasterizationStateCreateInfo structure.</member>
        <member name="pMultisampleState">pname:pMultisampleState is a pointer to an instance of the slink:VkPipelineMultisampleStateCreateInfo, or `NULL` if the pipeline has rasterization disabled.</member>
        <member name="pDepthStencilState">pname:pDepthStencilState is a pointer to an instance of the slink:VkPipelineDepthStencilStateCreateInfo structure, or `NULL` if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use a depth/stencil attachment.</member>
        <member name="pColorBlendState">pname:pColorBlendState is a pointer to an instance of the slink:VkPipelineColorBlendStateCreateInfo structure, or `NULL` if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use any color attachments.</member>
        <member name="pDynamicState">pname:pDynamicState is a pointer to slink:VkPipelineDynamicStateCreateInfo and is used to indicate which properties of the pipeline state object are dynamic and can: be changed independently of the pipeline state. This can: be `NULL`, which means no state in the pipeline is considered dynamic.</member>
        <member name="layout">pname:layout is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.</member>
        <member name="renderPass">pname:renderPass is a handle to a render pass object describing the environment in which the pipeline will be used; the pipeline can: be used with an instance of any render pass compatible with the one provided. See &lt;&lt;renderpass-compatibility,Render Pass Compatibility&gt;&gt; for more information.</member>
        <member name="subpass">pname:subpass is the index of the subpass in pname:renderPass where this pipeline will be used.</member>
        <member name="basePipelineHandle">pname:basePipelineHandle is a pipeline to derive from.</member>
        <member name="basePipelineIndex">pname:basePipelineIndex is an index into the pname:pCreateInfos parameter to use as a pipeline to derive from.</member>
      </members>
    </type>
    <type name="VkImage" summary="Opaque handle to a image object.">
      <specification>
        <para>Images represent multidimensional - up to 3 - arrays of data which can: be used for various purposes (e.g. attachments, textures), by binding them to a graphics or compute pipeline via descriptor sets, or by directly specifying them as parameters to certain commands.</para>
      </specification>
      <members />
    </type>
    <type name="VkImageAspectFlagBits" summary="Bitmask specifying which aspects of an image are included in a view.">
      <specification />
      <members />
    </type>
    <type name="VkImageBlit" summary="Structure specifying an image blit operation.">
      <specification />
      <members>
        <member name="srcSubresource">pname:srcSubresource is the subresource to blit from.</member>
        <member name="srcOffsets">pname:srcOffsets is an array of two slink:VkOffset3D structures specifying the bounds of the source region within pname:srcSubresource.</member>
        <member name="dstSubresource">pname:dstSubresource is the subresource to blit into.</member>
        <member name="dstOffsets">pname:dstOffsets is an array of two slink:VkOffset3D structures specifying the bounds of the destination region within pname:dstSubresource.</member>
      </members>
    </type>
    <type name="VkImageCopy" summary="Structure specifying an image copy operation.">
      <specification />
      <members>
        <member name="srcSubresource">pname:srcSubresource and pname:dstSubresource are slink:VkImageSubresourceLayers structures specifying the image subresources of the images used for the source and destination image data, respectively.</member>
        <member name="srcOffset">pname:srcOffset and pname:dstOffset select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data.</member>
        <member name="extent">pname:extent is the size in texels of the source image to copy in pname:width, pname:height and pname:depth. 1D images use only pname:x and pname:width. 2D images use pname:x, pname:y, pname:width and pname:height. 3D images use pname:x, pname:y, pname:z, pname:width, pname:height and pname:depth.</member>
      </members>
    </type>
    <type name="VkImageCreateFlagBits" summary="Bitmask specifying additional parameters of an image.">
      <specification />
      <members />
    </type>
    <type name="VkImageCreateInfo" summary="Structure specifying the parameters of a newly created image object.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is a bitmask describing additional parameters of the image. See elink:VkImageCreateFlagBits below for a description of the supported bits.</member>
        <member name="imageType">pname:imageType is a elink:VkImageType specifying the basic dimensionality of the image, as described below. Layers in array textures do not count as a dimension for the purposes of the image type.</member>
        <member name="format">pname:format is a elink:VkFormat describing the format and type of the data elements that will be contained in the image.</member>
        <member name="extent">pname:extent is a slink:VkExtent3D describing the number of data elements in each dimension of the base level.</member>
        <member name="mipLevels">pname:mipLevels describes the number of levels of detail available for minified sampling of the image.</member>
        <member name="arrayLayers">pname:arrayLayers is the number of layers in the image.</member>
        <member name="samples">pname:samples is the number of sub-data element samples in the image as defined in elink:VkSampleCountFlagBits. See &lt;&lt;primsrast-multisampling,Multisampling&gt;&gt;.</member>
        <member name="tiling">pname:tiling is a elink:VkImageTiling specifying the tiling arrangement of the data elements in memory, as described below.</member>
        <member name="usage">pname:usage is a bitmask describing the intended usage of the image. See elink:VkImageUsageFlagBits below for a description of the supported bits.</member>
        <member name="sharingMode">pname:sharingMode is the sharing mode of the image when it will be accessed by multiple queue families, and must: be one of the values described for elink:VkSharingMode in the &lt;&lt;resources-sharing,Resource Sharing&gt;&gt; section below.</member>
        <member name="queueFamilyIndexCount">pname:queueFamilyIndexCount is the number of entries in the pname:pQueueFamilyIndices array.</member>
        <member name="pQueueFamilyIndices">pname:pQueueFamilyIndices is a list of queue families that will access this image (ignored if pname:sharingMode is not ename:VK_SHARING_MODE_CONCURRENT).</member>
        <member name="initialLayout">pname:initialLayout selects the initial elink:VkImageLayout state of all image subresources of the image. See &lt;&lt;resources-image-layouts,Image Layouts&gt;&gt;. pname:initialLayout must: be ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED.</member>
      </members>
    </type>
    <type name="VkImageFormatProperties" summary="Structure specifying a image format properties.">
      <specification />
      <members>
        <member name="maxExtent">pname:maxExtent are the maximum image dimensions. See the &lt;&lt;features-extentperimagetype,Allowed Extent Values&gt;&gt; section below for how these values are constrained by pname:type.</member>
        <member name="maxMipLevels">pname:maxMipLevels is the maximum number of mipmap levels. pname:maxMipLevels must: either be equal to 1 (valid only if pname:tiling is ename:VK_IMAGE_TILING_LINEAR) or be equal to latexmath:[$\left\lceil\log_2(\max( \mathit{width},\mathit{height},\mathit{depth})) \right\rceil + 1$] where latexmath:[$\mathit{width}$], latexmath:[$\mathit{height}$], and latexmath:[$\mathit{depth}$] are taken from the corresponding members of pname:maxExtent.</member>
        <member name="maxArrayLayers">pname:maxArrayLayers is the maximum number of array layers. pname:maxArrayLayers must: either be equal to 1 or be greater than or equal to the pname:maxImageArrayLayers member of slink:VkPhysicalDeviceLimits. A value of 1 is valid only if pname:tiling is ename:VK_IMAGE_TILING_LINEAR or if pname:type is ename:VK_IMAGE_TYPE_3D.</member>
        <member name="sampleCounts">pname:sampleCounts is a bitmask of elink:VkSampleCountFlagBits specifying all the supported sample counts for this image as described &lt;&lt;features-supported-sample-counts, below&gt;&gt;.</member>
        <member name="maxResourceSize">pname:maxResourceSize is an upper bound on the total image size in bytes, inclusive of all image subresources. Implementations may: have an address space limit on total size of a resource, which is advertised by this property. pname:maxResourceSize must: be at least 2^31^.</member>
      </members>
    </type>
    <type name="VkImageLayout" summary="Layout of image and image subresources.">
      <specification />
      <members />
    </type>
    <type name="VkImageMemoryBarrier" summary="Structure specifying the parameters of an image memory barrier.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="srcAccessMask">pname:srcAccessMask is a bitmask of the classes of memory accesses performed by the first set of commands that will participate in the dependency.</member>
        <member name="dstAccessMask">pname:dstAccessMask is a bitmask of the classes of memory accesses performed by the second set of commands that will participate in the dependency.</member>
        <member name="oldLayout">pname:oldLayout describes the current layout of the image subresource(s).</member>
        <member name="newLayout">pname:newLayout describes the new layout of the image subresource(s).</member>
        <member name="srcQueueFamilyIndex">pname:srcQueueFamilyIndex is the queue family that is relinquishing ownership of the image subresource(s) to another queue, or ename:VK_QUEUE_FAMILY_IGNORED if there is no transfer of ownership).</member>
        <member name="dstQueueFamilyIndex">pname:dstQueueFamilyIndex is the queue family that is acquiring ownership of the image subresource(s) from another queue, or ename:VK_QUEUE_FAMILY_IGNORED if there is no transfer of ownership).</member>
        <member name="image">pname:image is a handle to the image whose backing memory is affected by the barrier.</member>
        <member name="subresourceRange">pname:subresourceRange describes an area of the backing memory for pname:image (see &lt;&lt;resources-image-views&gt;&gt; for the description of sname:VkImageSubresourceRange), as well as the set of image subresources whose image layouts are modified.</member>
      </members>
    </type>
    <type name="VkImageResolve" summary="Structure specifying an image resolve operation.">
      <specification />
      <members>
        <member name="srcSubresource">pname:srcSubresource and pname:dstSubresource are slink:VkImageSubresourceLayers structures specifying the image subresources of the images used for the source and destination image data, respectively. Resolve of depth/stencil images is not supported.</member>
        <member name="srcOffset">pname:srcOffset and pname:dstOffset select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data.</member>
        <member name="extent">pname:extent is the size in texels of the source image to resolve in pname:width, pname:height and pname:depth. 1D images use only pname:x and pname:width. 2D images use pname:x, pname:y, pname:width and pname:height. 3D images use pname:x, pname:y, pname:z, pname:width, pname:height and pname:depth.</member>
      </members>
    </type>
    <type name="VkImageSubresource" summary="Structure specifying a image subresource.">
      <specification />
      <members>
        <member name="aspectMask">pname:aspectMask is a elink:VkImageAspectFlags selecting the image _aspect_.</member>
        <member name="mipLevel">pname:mipLevel selects the mipmap level.</member>
        <member name="arrayLayer">pname:arrayLayer selects the array layer.</member>
      </members>
    </type>
    <type name="VkImageSubresourceLayers" summary="Structure specifying a image subresource layers.">
      <specification />
      <members>
        <member name="aspectMask">pname:aspectMask is a combination of elink:VkImageAspectFlagBits, selecting the color, depth and/or stencil aspects to be copied.</member>
        <member name="mipLevel">pname:mipLevel is the mipmap level to copy from.</member>
        <member name="baseArrayLayer">pname:baseArrayLayer and pname:layerCount are the starting layer and number of layers to copy.</member>
      </members>
    </type>
    <type name="VkImageSubresourceRange" summary="Structure specifying a image subresource range.">
      <specification />
      <members>
        <member name="aspectMask">pname:aspectMask is a bitmask indicating which aspect(s) of the image are included in the view. See elink:VkImageAspectFlagBits.</member>
        <member name="baseMipLevel">pname:baseMipLevel is the first mipmap level accessible to the view.</member>
        <member name="levelCount">pname:levelCount is the number of mipmap levels (starting from pname:baseMipLevel) accessible to the view.</member>
        <member name="baseArrayLayer">pname:baseArrayLayer is the first array layer accessible to the view.</member>
        <member name="layerCount">pname:layerCount is the number of array layers (starting from pname:baseArrayLayer) accessible to the view.</member>
      </members>
    </type>
    <type name="VkImageTiling" summary="Specifies the tiling arrangement of data in an image.">
      <specification />
      <members />
    </type>
    <type name="VkImageType" summary="Specifies the type of an image object.">
      <specification />
      <members />
    </type>
    <type name="VkImageUsageFlagBits" summary="Bitmask specifying intended usage of an image.">
      <specification />
      <members />
    </type>
    <type name="VkImageView" summary="Opaque handle to a image view object.">
      <specification>
        <para>Image objects are not directly accessed by pipeline shaders for reading or writing image data. Instead, _image views_ representing contiguous ranges of the image subresources and containing additional metadata are used for that purpose. Views must: be created on images of compatible types, and must: represent a valid subset of image subresources.</para>
      </specification>
      <members />
    </type>
    <type name="VkImageViewCreateInfo" summary="Structure specifying parameters of a newly created image view.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="image">pname:image is a sname:VkImage on which the view will be created.</member>
        <member name="viewType">pname:viewType is the type of the image view.</member>
        <member name="format">pname:format is a elink:VkFormat describing the format and type used to interpret data elements in the image.</member>
        <member name="components">pname:components specifies a remapping of color components (or of depth or stencil components after they have been converted into color components). See slink:VkComponentMapping.</member>
        <member name="subresourceRange">pname:subresourceRange is a slink:VkImageSubresourceRange selecting the set of mipmap levels and array layers to be accessible to the view.</member>
      </members>
    </type>
    <type name="VkImageViewType" summary="Image view types.">
      <specification />
      <members />
    </type>
    <type name="VkImportMemoryWin32HandleInfoNV" summary="Import Win32 memory created on the same physical device.">
      <specification>
        <para>To import memory created on the same physical device but outside of the current Vulkan instance, add a slink:VkImportMemoryWin32HandleInfoNV structure to the pname:pNext chain of the slink:VkMemoryAllocateInfo structure, specifying a handle to and the type of the memory.</para>
      </specification>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="handleType">pname:handleType is 0 or a flag specifying the type of memory handle in pname:handle. Flags which may: be specified are: + --</member>
      </members>
    </type>
    <type name="VkIndexType" summary="Type of index buffer indices.">
      <specification />
      <members />
    </type>
    <type name="VkInstance" summary="Opaque handle to a instance object.">
      <specification>
        <para>There is no global state in Vulkan and all per-application state is stored in a sname:VkInstance object. Creating a sname:VkInstance object initializes the Vulkan library and allows the application to pass information about itself to the implementation.</para>
      </specification>
      <members />
    </type>
    <type name="VkInstanceCreateInfo" summary="Structure specifying parameters of a newly created instance.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="pApplicationInfo">pname:pApplicationInfo is `NULL` or a pointer to an instance of sname:VkApplicationInfo. If not `NULL`, this information helps implementations recognize behavior inherent to classes of applications. slink:VkApplicationInfo is defined in detail below.</member>
        <member name="enabledLayerCount">pname:enabledLayerCount is the number of global layers to enable.</member>
        <member name="ppEnabledLayerNames">pname:ppEnabledLayerNames is a pointer to an array of pname:enabledLayerCount null-terminated UTF-8 strings containing the names of layers to enable for the created instance. See the &lt;&lt;extended-functionality-layers,Layers&gt;&gt; section for further details.</member>
        <member name="enabledExtensionCount">pname:enabledExtensionCount is the number of global extensions to enable.</member>
        <member name="ppEnabledExtensionNames">pname:ppEnabledExtensionNames is a pointer to an array of pname:enabledExtensionCount null-terminated UTF-8 strings containing the names of extensions to enable.</member>
      </members>
    </type>
    <type name="VkInternalAllocationType" summary="Allocation type.">
      <specification />
      <members>
        <member name="VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE">ename:VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - The allocation is intended for execution by the host.</member>
      </members>
    </type>
    <type name="VkLayerProperties" summary="Structure specifying layer properties.">
      <specification />
      <members>
        <member name="layerName">pname:layerName is a null-terminated UTF-8 string specifying the name of the layer. Use this name in the pname:ppEnabledLayerNames array passed in the slink:VkInstanceCreateInfo structure to enable this layer for an instance.</member>
        <member name="specVersion">pname:specVersion is the Vulkan version the layer was written to, encoded as described in the &lt;&lt;fundamentals-versionnum,API Version Numbers and Semantics&gt;&gt; section.</member>
        <member name="implementationVersion">pname:implementationVersion is the version of this layer. It is an integer, increasing with backward compatible changes.</member>
        <member name="description">pname:description is a null-terminated UTF-8 string providing additional details that can: be used by the application to identify the layer.</member>
      </members>
    </type>
    <type name="VkLogicOp" summary="Framebuffer logical operations.">
      <specification />
      <members />
    </type>
    <type name="VkMappedMemoryRange" summary="Structure specifying a mapped memory range.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="memory">pname:memory is the memory object to which this range belongs.</member>
        <member name="offset">pname:offset is the zero-based byte offset from the beginning of the memory object.</member>
        <member name="size">pname:size is either the size of range, or ename:VK_WHOLE_SIZE to affect the range from pname:offset to the end of the current mapping of the allocation.</member>
      </members>
    </type>
    <type name="VkMemoryAllocateInfo" summary="Structure containing parameters of a memory allocation.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="allocationSize">pname:allocationSize is the size of the allocation in bytes</member>
        <member name="memoryTypeIndex">pname:memoryTypeIndex is the memory type index, which selects the properties of the memory to be allocated, as well as the heap the memory will come from.</member>
      </members>
    </type>
    <type name="VkMemoryBarrier" summary="Structure specifying a memory barrier.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="srcAccessMask">pname:srcAccessMask is a bitmask of the classes of memory accesses performed by the first set of commands that will participate in the dependency.</member>
        <member name="dstAccessMask">pname:dstAccessMask is a bitmask of the classes of memory accesses performed by the second set of commands that will participate in the dependency.</member>
      </members>
    </type>
    <type name="VkMemoryHeap" summary="Structure specifying a memory heap.">
      <specification />
      <members>
        <member name="size">pname:size is the total memory size in bytes in the heap.</member>
        <member name="flags">pname:flags is a bitmask of attribute flags for the heap. The bits specified in pname:flags are: + --</member>
      </members>
    </type>
    <type name="VkMemoryHeapFlagBits" summary="Bitmask specifying attribute flags for a heap.">
      <specification />
      <members />
    </type>
    <type name="VkMemoryPropertyFlagBits" summary="Bitmask specifying properties for a memory type.">
      <specification />
      <members />
    </type>
    <type name="VkMemoryRequirements" summary="Structure specifying memory requirements.">
      <specification />
      <members>
        <member name="size">pname:size is the size, in bytes, of the memory allocation required: for the resource.</member>
        <member name="alignment">pname:alignment is the alignment, in bytes, of the offset within the allocation required: for the resource.</member>
        <member name="memoryTypeBits">pname:memoryTypeBits is a bitmask and contains one bit set for every supported memory type for the resource. Bit `i` is set if and only if the memory type `i` in the sname:VkPhysicalDeviceMemoryProperties structure for the physical device is supported for the resource.</member>
      </members>
    </type>
    <type name="VkMemoryType" summary="Structure specifying memory type.">
      <specification />
      <members>
        <member name="heapIndex">pname:heapIndex describes which memory heap this memory type corresponds to, and must: be less than pname:memoryHeapCount from the sname:VkPhysicalDeviceMemoryProperties structure.</member>
        <member name="propertyFlags">pname:propertyFlags is a bitmask of properties for this memory type. The bits specified in pname:propertyFlags are: + --</member>
      </members>
    </type>
    <type name="VkMirSurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created Mir surface object.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="connection">pname:connection and pname:surface are pointers to the MirConnection and MirSurface for the window to associate the surface with.</member>
      </members>
    </type>
    <type name="VkOffset2D" summary="Structure specifying a two-dimensional offset.">
      <specification />
      <members />
    </type>
    <type name="VkOffset3D" summary="Structure specifying a three-dimensional offset.">
      <specification />
      <members />
    </type>
    <type name="VkPhysicalDevice" summary="Opaque handle to a physical device object.">
      <specification>
        <para>Vulkan separates the concept of _physical_ and _logical_ devices. A physical device usually represents a single device in a system (perhaps made up of several individual hardware devices working together), of which there are a finite number. A logical device represents an application's view of the device.</para>
      </specification>
      <members />
    </type>
    <type name="VkPhysicalDeviceFeatures" summary="Structure describing the fine-grained features that can be supported by an implementation.">
      <specification />
      <members />
    </type>
    <type name="VkPhysicalDeviceLimits" summary="Structure.">
      <specification />
      <members>
        <member name="maxImageDimension1D">[[features-limits-maxImageDimension1D]] pname:maxImageDimension1D is the maximum dimension (pname:width) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_1D.</member>
        <member name="maxImageDimension2D">[[features-limits-maxImageDimension2D]] pname:maxImageDimension2D is the maximum dimension (pname:width or pname:height) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_2D and without ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.</member>
        <member name="maxImageDimension3D">[[features-limits-maxImageDimension3D]] pname:maxImageDimension3D is the maximum dimension (pname:width, pname:height, or pname:depth) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_3D.</member>
        <member name="maxImageDimensionCube">[[features-limits-maxImageDimensionCube]] pname:maxImageDimensionCube is the maximum dimension (pname:width or pname:height) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_2D and with ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.</member>
        <member name="maxImageArrayLayers">[[features-limits-maxImageArrayLayers]] pname:maxImageArrayLayers is the maximum number of layers (pname:arrayLayers) for an image.</member>
        <member name="maxTexelBufferElements">[[features-limits-maxTexelBufferElements]] pname:maxTexelBufferElements is the maximum number of addressable texels for a buffer view created on a buffer which was created with the ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the pname:usage member of the sname:VkBufferCreateInfo structure.</member>
        <member name="maxUniformBufferRange">[[features-limits-maxUniformBufferRange]] pname:maxUniformBufferRange is the maximum value that can: be specified in the pname:range member of any slink:VkDescriptorBufferInfo structures passed to a call to flink:vkUpdateDescriptorSets for descriptors of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.</member>
        <member name="maxStorageBufferRange">[[features-limits-maxStorageBufferRange]] pname:maxStorageBufferRange is the maximum value that can: be specified in the pname:range member of any slink:VkDescriptorBufferInfo structures passed to a call to flink:vkUpdateDescriptorSets for descriptors of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.</member>
        <member name="maxPushConstantsSize">[[features-limits-maxPushConstantsSize]] pname:maxPushConstantsSize is the maximum size, in bytes, of the pool of push constant memory. For each of the push constant ranges indicated by the pname:pPushConstantRanges member of the sname:VkPipelineLayoutCreateInfo structure, pname:offset + pname:size must: be less than or equal to this limit.</member>
        <member name="maxMemoryAllocationCount">[[features-limits-maxMemoryAllocationCount]] pname:maxMemoryAllocationCount is the maximum number of device memory allocations, as created by flink:vkAllocateMemory, which can: simultaneously exist.</member>
        <member name="maxSamplerAllocationCount">[[features-limits-maxSamplerAllocationCount]] pname:maxSamplerAllocationCount is the maximum number of sampler objects, as created by flink:vkCreateSampler, which can: simultaneously exist on a device.</member>
        <member name="bufferImageGranularity">[[features-limits-bufferImageGranularity]] pname:bufferImageGranularity is the granularity, in bytes, at which buffer or linear image resources, and optimal image resources can: be bound to adjacent offsets in the same sname:VkDeviceMemory object without aliasing. See &lt;&lt;resources-bufferimagegranularity,Buffer-Image Granularity&gt;&gt; for more details.</member>
        <member name="sparseAddressSpaceSize">[[features-limits-sparseAddressSpaceSize]] pname:sparseAddressSpaceSize is the total amount of address space available, in bytes, for sparse memory resources. This is an upper bound on the sum of the size of all sparse resources, regardless of whether any memory is bound to them.</member>
        <member name="maxBoundDescriptorSets">[[features-limits-maxBoundDescriptorSets]] pname:maxBoundDescriptorSets is the maximum number of descriptor sets that can: be simultaneously used by a pipeline. All code:DescriptorSet decorations in shader modules must: have a value less than pname:maxBoundDescriptorSets. See &lt;&lt;descriptorsets-sets&gt;&gt;.</member>
        <member name="maxPerStageDescriptorSamplers">[[features-limits-maxPerStageDescriptorSamplers]] pname:maxPerStageDescriptorSamplers is the maximum number of samplers that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this limit. A descriptor is accessible to a shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-sampler&gt;&gt; and &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;.</member>
        <member name="maxPerStageDescriptorUniformBuffers">[[features-limits-maxPerStageDescriptorUniformBuffers]] pname:maxPerStageDescriptorUniformBuffers is the maximum number of uniform buffers that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. A descriptor is accessible to a shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-uniformbuffer&gt;&gt; and &lt;&lt;descriptorsets-uniformbufferdynamic&gt;&gt;.</member>
        <member name="maxPerStageDescriptorStorageBuffers">[[features-limits-maxPerStageDescriptorStorageBuffers]] pname:maxPerStageDescriptorStorageBuffers is the maximum number of storage buffers that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-storagebuffer&gt;&gt; and &lt;&lt;descriptorsets-storagebufferdynamic&gt;&gt;.</member>
        <member name="maxPerStageDescriptorSampledImages">[[features-limits-maxPerStageDescriptorSampledImages]] pname:maxPerStageDescriptorSampledImages is the maximum number of sampled images that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;, &lt;&lt;descriptorsets-sampledimage&gt;&gt;, and &lt;&lt;descriptorsets-uniformtexelbuffer&gt;&gt;.</member>
        <member name="maxPerStageDescriptorStorageImages">[[features-limits-maxPerStageDescriptorStorageImages]] pname:maxPerStageDescriptorStorageImages is the maximum number of storage images that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-storageimage&gt;&gt;, and &lt;&lt;descriptorsets-storagetexelbuffer&gt;&gt;.</member>
        <member name="maxPerStageDescriptorInputAttachments">[[features-limits-maxPerStageDescriptorInputAttachments]] pname:maxPerStageDescriptorInputAttachments is the maximum number of input attachments that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. These are only supported for the fragment stage. See &lt;&lt;descriptorsets-inputattachment&gt;&gt;.</member>
        <member name="maxPerStageResources">[[features-limits-maxPerStageResources]] pname:maxPerStageResources is the maximum number of resources that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, or ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. For the fragment shader stage the framebuffer color attachments also count against this limit.</member>
        <member name="maxDescriptorSetSamplers">[[features-limits-maxDescriptorSetSamplers]] pname:maxDescriptorSetSamplers is the maximum number of samplers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this limit. See &lt;&lt;descriptorsets-sampler&gt;&gt; and &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;.</member>
        <member name="maxDescriptorSetUniformBuffers">[[features-limits-maxDescriptorSetUniformBuffers]] pname:maxDescriptorSetUniformBuffers is the maximum number of uniform buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. See &lt;&lt;descriptorsets-uniformbuffer&gt;&gt; and &lt;&lt;descriptorsets-uniformbufferdynamic&gt;&gt;.</member>
        <member name="maxDescriptorSetUniformBuffersDynamic">[[features-limits-maxDescriptorSetUniformBuffersDynamic]] pname:maxDescriptorSetUniformBuffersDynamic is the maximum number of dynamic uniform buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. See &lt;&lt;descriptorsets-uniformbufferdynamic&gt;&gt;.</member>
        <member name="maxDescriptorSetStorageBuffers">[[features-limits-maxDescriptorSetStorageBuffers]] pname:maxDescriptorSetStorageBuffers is the maximum number of storage buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. See &lt;&lt;descriptorsets-storagebuffer&gt;&gt; and &lt;&lt;descriptorsets-storagebufferdynamic&gt;&gt;.</member>
        <member name="maxDescriptorSetStorageBuffersDynamic">[[features-limits-maxDescriptorSetStorageBuffersDynamic]] pname:maxDescriptorSetStorageBuffersDynamic is the maximum number of dynamic storage buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. See &lt;&lt;descriptorsets-storagebufferdynamic&gt;&gt;.</member>
        <member name="maxDescriptorSetSampledImages">[[features-limits-maxDescriptorSetSampledImages]] pname:maxDescriptorSetSampledImages is the maximum number of sampled images that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit. See &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;, &lt;&lt;descriptorsets-sampledimage&gt;&gt;, and &lt;&lt;descriptorsets-uniformtexelbuffer&gt;&gt;.</member>
        <member name="maxDescriptorSetStorageImages">[[features-limits-maxDescriptorSetStorageImages]] pname:maxDescriptorSetStorageImages is the maximum number of storage images that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit. See &lt;&lt;descriptorsets-storageimage&gt;&gt;, and &lt;&lt;descriptorsets-storagetexelbuffer&gt;&gt;.</member>
        <member name="maxDescriptorSetInputAttachments">[[features-limits-maxDescriptorSetInputAttachments]] pname:maxDescriptorSetInputAttachments is the maximum number of input attachments that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. See &lt;&lt;descriptorsets-inputattachment&gt;&gt;.</member>
        <member name="maxVertexInputAttributes">[[features-limits-maxVertexInputAttributes]] pname:maxVertexInputAttributes is the maximum number of vertex input attributes that can: be specified for a graphics pipeline. These are described in the array of sname:VkVertexInputAttributeDescription structures that are provided at graphics pipeline creation time via the pname:pVertexAttributeDescriptions member of the sname:VkPipelineVertexInputStateCreateInfo structure. See &lt;&lt;fxvertex-attrib&gt;&gt; and &lt;&lt;fxvertex-input&gt;&gt;.</member>
        <member name="maxVertexInputBindings">[[features-limits-maxVertexInputBindings]] pname:maxVertexInputBindings is the maximum number of vertex buffers that can: be specified for providing vertex attributes to a graphics pipeline. These are described in the array of sname:VkVertexInputBindingDescription structures that are provided at graphics pipeline creation time via the pname:pVertexBindingDescriptions member of the sname:VkPipelineVertexInputStateCreateInfo structure. The pname:binding member of sname:VkVertexInputBindingDescription must: be less than this limit. See &lt;&lt;fxvertex-input&gt;&gt;.</member>
        <member name="maxVertexInputAttributeOffset">[[features-limits-maxVertexInputAttributeOffset]] pname:maxVertexInputAttributeOffset is the maximum vertex input attribute offset that can: be added to the vertex input binding stride. The pname:offset member of the sname:VkVertexInputAttributeDescription structure must: be less than or equal to this limit. See &lt;&lt;fxvertex-input&gt;&gt;.</member>
        <member name="maxVertexInputBindingStride">[[features-limits-maxVertexInputBindingStride]] pname:maxVertexInputBindingStride is the maximum vertex input binding stride that can: be specified in a vertex input binding. The pname:stride member of the sname:VkVertexInputBindingDescription structure must: be less than or equal to this limit. See &lt;&lt;fxvertex-input&gt;&gt;.</member>
        <member name="maxVertexOutputComponents">[[features-limits-maxVertexOutputComponents]] pname:maxVertexOutputComponents is the maximum number of components of output variables which can: be output by a vertex shader. See &lt;&lt;shaders-vertex&gt;&gt;.</member>
        <member name="maxTessellationGenerationLevel">[[features-limits-maxTessellationGenerationLevel]] pname:maxTessellationGenerationLevel is the maximum tessellation generation level supported by the fixed-function tessellation primitive generator. See &lt;&lt;tessellation&gt;&gt;.</member>
        <member name="maxTessellationPatchSize">[[features-limits-maxTessellationPatchSize]] pname:maxTessellationPatchSize is the maximum patch size, in vertices, of patches that can: be processed by the tessellation control shader and tessellation primitive generator. The pname:patchControlPoints member of the sname:VkPipelineTessellationStateCreateInfo structure specified at pipeline creation time and the value provided in the code:OutputVertices execution mode of shader modules must: be less than or equal to this limit. See &lt;&lt;tessellation&gt;&gt;.</member>
        <member name="maxTessellationControlPerVertexInputComponents">[[features-limits-maxTessellationControlPerVertexInputComponents]] pname:maxTessellationControlPerVertexInputComponents is the maximum number of components of input variables which can: be provided as per-vertex inputs to the tessellation control shader stage.</member>
        <member name="maxTessellationControlPerVertexOutputComponents">[[features-limits-maxTessellationControlPerVertexOutputComponents]] pname:maxTessellationControlPerVertexOutputComponents is the maximum number of components of per-vertex output variables which can: be output from the tessellation control shader stage.</member>
        <member name="maxTessellationControlPerPatchOutputComponents">[[features-limits-maxTessellationControlPerPatchOutputComponents]] pname:maxTessellationControlPerPatchOutputComponents is the maximum number of components of per-patch output variables which can: be output from the tessellation control shader stage.</member>
        <member name="maxTessellationControlTotalOutputComponents">[[features-limits-maxTessellationControlTotalOutputComponents]] pname:maxTessellationControlTotalOutputComponents is the maximum total number of components of per-vertex and per-patch output variables which can: be output from the tessellation control shader stage.</member>
        <member name="maxTessellationEvaluationInputComponents">[[features-limits-maxTessellationEvaluationInputComponents]] pname:maxTessellationEvaluationInputComponents is the maximum number of components of input variables which can: be provided as per-vertex inputs to the tessellation evaluation shader stage.</member>
        <member name="maxTessellationEvaluationOutputComponents">[[features-limits-maxTessellationEvaluationOutputComponents]] pname:maxTessellationEvaluationOutputComponents is the maximum number of components of per-vertex output variables which can: be output from the tessellation evaluation shader stage.</member>
        <member name="maxGeometryShaderInvocations">[[features-limits-maxGeometryShaderInvocations]] pname:maxGeometryShaderInvocations is the maximum invocation count supported for instanced geometry shaders. The value provided in the code:Invocations execution mode of shader modules must: be less than or equal to this limit. See &lt;&lt;geometry&gt;&gt;.</member>
        <member name="maxGeometryInputComponents">[[features-limits-maxGeometryInputComponents]] pname:maxGeometryInputComponents is the maximum number of components of input variables which can: be provided as inputs to the geometry shader stage.</member>
        <member name="maxGeometryOutputComponents">[[features-limits-maxGeometryOutputComponents]] pname:maxGeometryOutputComponents is the maximum number of components of output variables which can: be output from the geometry shader stage.</member>
        <member name="maxGeometryOutputVertices">[[features-limits-maxGeometryOutputVertices]] pname:maxGeometryOutputVertices is the maximum number of vertices which can: be emitted by any geometry shader.</member>
        <member name="maxGeometryTotalOutputComponents">[[features-limits-maxGeometryTotalOutputComponents]] pname:maxGeometryTotalOutputComponents is the maximum total number of components of output, across all emitted vertices, which can: be output from the geometry shader stage.</member>
        <member name="maxFragmentInputComponents">[[features-limits-maxFragmentInputComponents]] pname:maxFragmentInputComponents is the maximum number of components of input variables which can: be provided as inputs to the fragment shader stage.</member>
        <member name="maxFragmentOutputAttachments">[[features-limits-maxFragmentOutputAttachments]] pname:maxFragmentOutputAttachments is the maximum number of output attachments which can: be written to by the fragment shader stage.</member>
        <member name="maxFragmentDualSrcAttachments">[[features-limits-maxFragmentDualSrcAttachments]] pname:maxFragmentDualSrcAttachments is the maximum number of output attachments which can: be written to by the fragment shader stage when blending is enabled and one of the dual source blend modes is in use. See &lt;&lt;framebuffer-dsb&gt;&gt; and &lt;&lt;features-features-dualSrcBlend,dualSrcBlend&gt;&gt;.</member>
        <member name="maxFragmentCombinedOutputResources">[[features-limits-maxFragmentCombinedOutputResources]] pname:maxFragmentCombinedOutputResources is the total number of storage buffers, storage images, and output buffers which can: be used in the fragment shader stage.</member>
        <member name="maxComputeSharedMemorySize">[[features-limits-maxComputeSharedMemorySize]] pname:maxComputeSharedMemorySize is the maximum total storage size, in bytes, of all variables declared with the code:WorkgroupLocal storage class in shader modules (or with the code:shared storage qualifier in GLSL) in the compute shader stage.</member>
        <member name="maxComputeWorkGroupCount">[[features-limits-maxComputeWorkGroupCount]] pname:maxComputeWorkGroupCount[3] is the maximum number of local workgroups that can: be dispatched by a single dispatch command. These three values represent the maximum number of local workgroups for the X, Y, and Z dimensions, respectively. The pname:x, pname:y, and pname:z parameters to the flink:vkCmdDispatch command, or members of the slink:VkDispatchIndirectCommand structure must: be less than or equal to the corresponding limit. See &lt;&lt;dispatch&gt;&gt;.</member>
        <member name="maxComputeWorkGroupInvocations">[[features-limits-maxComputeWorkGroupInvocations]] pname:maxComputeWorkGroupInvocations is the maximum total number of compute shader invocations in a single local workgroup. The product of the X, Y, and Z sizes as specified by the code:LocalSize execution mode in shader modules and by the object decorated by the code:WorkgroupSize decoration must: be less than or equal to this limit.</member>
        <member name="maxComputeWorkGroupSize">[[features-limits-maxComputeWorkGroupSize]] pname:maxComputeWorkGroupSize[3] is the maximum size of a local compute workgroup, per dimension. These three values represent the maximum local workgroup size in the X, Y, and Z dimensions, respectively. The pname:x, pname:y, and pname:z sizes specified by the code:LocalSize execution mode and by the object decorated by the code:WorkgroupSize decoration in shader modules must: be less than or equal to the corresponding limit.</member>
        <member name="subPixelPrecisionBits">[[features-limits-subPixelPrecisionBits]] pname:subPixelPrecisionBits is the number of bits of subpixel precision in framebuffer coordinates latexmath:[$x_f$] and latexmath:[$y_f$]. See &lt;&lt;primsrast&gt;&gt;.</member>
        <member name="subTexelPrecisionBits">[[features-limits-subTexelPrecisionBits]] pname:subTexelPrecisionBits is the number of bits of precision in the division along an axis of an image used for minification and magnification filters. latexmath:[$2^\mathit{subTexelPrecisionBits}$] is the actual number of divisions along each axis of the image represented. The filtering hardware will snap to these locations when computing the filtered results.</member>
        <member name="mipmapPrecisionBits">[[features-limits-mipmapPrecisionBits]] pname:mipmapPrecisionBits is the number of bits of division that the LOD calculation for mipmap fetching get snapped to when determining the contribution from each mip level to the mip filtered results. latexmath:[$2^\mathit{mipmapPrecisionBits}$] is the actual number of divisions. + -- [NOTE] .Note ==== For example, if this value is 2 bits then when linearly filtering between two levels, each level could: contribute: 0%, 33%, 66%, or 100% (this is just an example and the amount of contribution should: be covered by different equations in the spec). ==== -- +</member>
        <member name="maxDrawIndexedIndexValue">[[features-limits-maxDrawIndexedIndexValue]] pname:maxDrawIndexedIndexValue is the maximum index value that can: be used for indexed draw calls when using 32-bit indices. This excludes the primitive restart index value of 0xFFFFFFFF. See &lt;&lt;features-features-fullDrawIndexUint32,fullDrawIndexUint32&gt;&gt;.</member>
        <member name="maxDrawIndirectCount">[[features-limits-maxDrawIndirectCount]] pname:maxDrawIndirectCount is the maximum draw count that is supported for indirect draw calls. See &lt;&lt;features-features-multiDrawIndirect,multiDrawIndirect&gt;&gt;.</member>
        <member name="maxSamplerLodBias">[[features-limits-maxSamplerLodBias]] pname:maxSamplerLodBias is the maximum absolute sampler level of detail bias. The sum of the pname:mipLodBias member of the sname:VkSamplerCreateInfo structure and the code:Bias operand of image sampling operations in shader modules (or 0 if no code:Bias operand is provided to an image sampling operation) are clamped to the range latexmath:[$[-\mathit{maxSamplerLodBias},+\mathit{maxSamplerLodBias}\]$]. See &lt;&lt;samplers-mipLodBias&gt;&gt;.</member>
        <member name="maxSamplerAnisotropy">[[features-limits-maxSamplerAnisotropy]] pname:maxSamplerAnisotropy is the maximum degree of sampler anisotropy. The maximum degree of anisotropic filtering used for an image sampling operation is the minimum of the pname:maxAnisotropy member of the sname:VkSamplerCreateInfo structure and this limit. See &lt;&lt;samplers-maxAnisotropy&gt;&gt;.</member>
        <member name="maxViewports">[[features-limits-maxViewports]] pname:maxViewports is the maximum number of active viewports. The pname:viewportCount member of the sname:VkPipelineViewportStateCreateInfo structure that is provided at pipeline creation must: be less than or equal to this limit.</member>
        <member name="maxViewportDimensions">[[features-limits-maxViewportDimensions]] pname:maxViewportDimensions[2] are the maximum viewport dimensions in the X (width) and Y (height) dimensions, respectively. The maximum viewport dimensions must: be greater than or equal to the largest image which can: be created and used as a framebuffer attachment. See &lt;&lt;vertexpostproc-viewport,Controlling the Viewport&gt;&gt;.</member>
        <member name="viewportBoundsRange">[[features-limits-viewportboundsrange]] pname:viewportBoundsRange[2] is the latexmath:[$[\mathit{minimum},\mathit{maximum}\]$] range that the corners of a viewport must: be contained in. This range must: be at least latexmath:[$[- 2 \times \mathit{maxViewportDimensions}, 2 \times \mathit{maxViewportDimensions} - 1\]$]. See &lt;&lt;vertexpostproc-viewport,Controlling the Viewport&gt;&gt;. + -- [NOTE] .Note ==== The intent of the pname:viewportBoundsRange limit is to allow a maximum sized viewport to be arbitrarily shifted relative to the output target as long as at least some portion intersects. This would give a bounds limit of latexmath:[$[- \mathit{maxViewportDimensions}+1, 2 \times \mathit{maxViewportDimensions} -1\]$] which would allow all possible non-empty-set intersections of the output target and the viewport. Since these numbers are typically powers of two, picking the signed number range using the smallest possible number of bits ends up with the specified range. ==== --</member>
        <member name="viewportSubPixelBits">[[features-limits-viewportSubPixelBits]] pname:viewportSubPixelBits is the number of bits of subpixel precision for viewport bounds. The subpixel precision that floating-point viewport bounds are interpreted at is given by this limit.</member>
        <member name="minMemoryMapAlignment">[[features-limits-minMemoryMapAlignment]] pname:minMemoryMapAlignment is the minimum required alignment, in bytes, of host visible memory allocations within the host address space. When mapping a memory allocation with flink:vkMapMemory, subtracting pname:offset bytes from the returned pointer will always produce an integer multiple of this limit. See &lt;&lt;memory-device-hostaccess&gt;&gt;.</member>
        <member name="minTexelBufferOffsetAlignment">[[features-limits-minTexelBufferOffsetAlignment]] pname:minTexelBufferOffsetAlignment is the minimum required alignment, in bytes, for the pname:offset member of the sname:VkBufferViewCreateInfo structure for texel buffers. When a buffer view is created for a buffer which was created with ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the pname:usage member of the sname:VkBufferCreateInfo structure, the pname:offset must: be an integer multiple of this limit.</member>
        <member name="minUniformBufferOffsetAlignment">[[features-limits-minUniformBufferOffsetAlignment]] pname:minUniformBufferOffsetAlignment is the minimum required alignment, in bytes, for the pname:offset member of the sname:VkDescriptorBufferInfo structure for uniform buffers. When a descriptor of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC is updated, the pname:offset must: be an integer multiple of this limit. Similarly, dynamic offsets for uniform buffers must: be multiples of this limit.</member>
        <member name="minStorageBufferOffsetAlignment">[[features-limits-minStorageBufferOffsetAlignment]] pname:minStorageBufferOffsetAlignment is the minimum required alignment, in bytes, for the pname:offset member of the sname:VkDescriptorBufferInfo structure for storage buffers. When a descriptor of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC is updated, the pname:offset must: be an integer multiple of this limit. Similarly, dynamic offsets for storage buffers must: be multiples of this limit.</member>
        <member name="minTexelOffset">[[features-limits-minTexelOffset]] pname:minTexelOffset is the minimum offset value for the code:ConstOffset image operand of any of the code:OpImageSample* or code:OpImageFetch* image instructions.</member>
        <member name="maxTexelOffset">[[features-limits-maxTexelOffset]] pname:maxTexelOffset is the maximum offset value for the code:ConstOffset image operand of any of the code:OpImageSample* or code:OpImageFetch* image instructions.</member>
        <member name="minTexelGatherOffset">[[features-limits-minTexelGatherOffset]] pname:minTexelGatherOffset is the minimum offset value for the code:Offset or code:ConstOffsets image operands of any of the code:OpImage*code:Gather image instructions.</member>
        <member name="maxTexelGatherOffset">[[features-limits-maxTexelGatherOffset]] pname:maxTexelGatherOffset is the maximum offset value for the code:Offset or code:ConstOffsets image operands of any of the code:OpImage*code:Gather image instructions.</member>
        <member name="minInterpolationOffset">[[features-limits-minInterpolationOffset]] pname:minInterpolationOffset is the minimum negative offset value for the code:offset operand of the code:InterpolateAtOffset extended instruction.</member>
        <member name="maxInterpolationOffset">[[features-limits-maxInterpolationOffset]] pname:maxInterpolationOffset is the maximum positive offset value for the code:offset operand of the code:InterpolateAtOffset extended instruction.</member>
        <member name="subPixelInterpolationOffsetBits">[[features-limits-subPixelInterpolationOffsetBits]] pname:subPixelInterpolationOffsetBits is the number of subpixel fractional bits that the code:x and code:y offsets to the code:InterpolateAtOffset extended instruction may: be rounded to as fixed-point values.</member>
        <member name="maxFramebufferWidth">[[features-limits-maxFramebufferWidth]] pname:maxFramebufferWidth is the maximum width for a framebuffer. The pname:width member of the sname:VkFramebufferCreateInfo structure must: be less than or equal to this limit.</member>
        <member name="maxFramebufferHeight">[[features-limits-maxFramebufferHeight]] pname:maxFramebufferHeight is the maximum height for a framebuffer. The pname:height member of the sname:VkFramebufferCreateInfo structure must: be less than or equal to this limit.</member>
        <member name="maxFramebufferLayers">[[features-limits-maxFramebufferLayers]] pname:maxFramebufferLayers is the maximum layer count for a layered framebuffer. The pname:layers member of the sname:VkFramebufferCreateInfo structure must: be less than or equal to this limit.</member>
        <member name="framebufferColorSampleCounts">[[features-limits-framebufferColorSampleCounts]] pname:framebufferColorSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the color sample counts that are supported for all framebuffer color attachments.</member>
        <member name="framebufferDepthSampleCounts">[[features-limits-framebufferDepthSampleCounts]] pname:framebufferDepthSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the supported depth sample counts for all framebuffer depth/stencil attachments, when the format includes a depth component.</member>
        <member name="framebufferStencilSampleCounts">pname:framebufferStencilSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the supported stencil sample counts for all framebuffer depth/stencil attachments, when the format includes a stencil component.</member>
        <member name="framebufferNoAttachmentsSampleCounts">pname:framebufferNoAttachmentsSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the supported sample counts for a framebuffer with no attachments.</member>
        <member name="maxColorAttachments">[[features-limits-maxColorAttachments]] pname:maxColorAttachments is the maximum number of color attachments that can: be used by a subpass in a render pass. The pname:colorAttachmentCount member of the sname:VkSubpassDescription structure must: be less than or equal to this limit.</member>
        <member name="sampledImageColorSampleCounts">[[features-limits-sampledImageColorSampleCounts]] pname:sampledImageColorSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a non-integer color format.</member>
        <member name="sampledImageIntegerSampleCounts">[[features-limits-sampledImageIntegerSampleCounts]] pname:sampledImageIntegerSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and an integer color format.</member>
        <member name="sampledImageDepthSampleCounts">[[features-limits-sampledImageDepthSampleCounts]] pname:sampledImageDepthSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a depth format.</member>
        <member name="sampledImageStencilSampleCounts">[[features-limits-sampledImageStencilSampleCounts]] pname:sampledImageStencilSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a stencil format.</member>
        <member name="storageImageSampleCounts">[[features-limits-storageImageSampleCounts]] pname:storageImageSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, and pname:usage containing ename:VK_IMAGE_USAGE_STORAGE_BIT.</member>
        <member name="maxSampleMaskWords">[[features-limits-maxSampleMaskWords]] pname:maxSampleMaskWords is the maximum number of array elements of a variable decorated with the code:SampleMask built-in decoration.</member>
        <member name="timestampComputeAndGraphics">[[features-limits-timestampComputeAndGraphics]] pname:timestampComputeAndGraphics indicates support for timestamps on all graphics and compute queues. If this limit is set to ename:VK_TRUE, all queues that advertise the ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT in the sname:VkQueueFamilyProperties::pname:queueFlags support sname:VkQueueFamilyProperties::pname:timestampValidBits of at least 36. See &lt;&lt;queries-timestamps, Timestamp Queries&gt;&gt;.</member>
        <member name="timestampPeriod">[[features-limits-timestampPeriod]] pname:timestampPeriod is the number of nanoseconds required for a timestamp query to be incremented by 1. See &lt;&lt;queries-timestamps, Timestamp Queries&gt;&gt;.</member>
        <member name="maxClipDistances">[[features-limits-maxClipDistances]] pname:maxClipDistances is the maximum number of clip distances that can: be used in a single shader stage. The size of any array declared with the code:ClipDistance built-in decoration in a shader module must: be less than or equal to this limit.</member>
        <member name="maxCullDistances">[[features-limits-maxCullDistances]] pname:maxCullDistances is the maximum number of cull distances that can: be used in a single shader stage. The size of any array declared with the code:CullDistance built-in decoration in a shader module must: be less than or equal to this limit.</member>
        <member name="maxCombinedClipAndCullDistances">[[features-limits-maxCombinedClipAndCullDistances]] pname:maxCombinedClipAndCullDistances is the maximum combined number of clip and cull distances that can: be used in a single shader stage. The sum of the sizes of any pair of arrays declared with the code:ClipDistance and code:CullDistance built-in decoration used by a single shader stage in a shader module must: be less than or equal to this limit.</member>
        <member name="discreteQueuePriorities">[[features-limits-discreteQueuePriorities]] pname:discreteQueuePriorities is the number of discrete priorities that can: be assigned to a queue based on the value of each member of sname:VkDeviceQueueCreateInfo::pname:pQueuePriorities. This must: be at least 2, and levels must: be spread evenly over the range, with at least one level at 1.0, and another at 0.0. See &lt;&lt;devsandqueues-priority&gt;&gt;.</member>
        <member name="pointSizeRange">[[features-limits-pointSizeRange]] pname:pointSizeRange[2] is the range latexmath:[$[\mathit{minimum},\mathit{maximum}\]$] of supported sizes for points. Values written to variables decorated with the code:PointSize built-in decoration are clamped to this range.</member>
        <member name="lineWidthRange">[[features-limits-lineWidthRange]] pname:lineWidthRange[2] is the range latexmath:[$[\mathit{minimum},\mathit{maximum}\]$] of supported widths for lines. Values specified by the pname:lineWidth member of the sname:VkPipelineRasterizationStateCreateInfo or the pname:lineWidth parameter to fname:vkCmdSetLineWidth are clamped to this range.</member>
        <member name="pointSizeGranularity">[[features-limits-pointSizeGranularity]] pname:pointSizeGranularity is the granularity of supported point sizes. Not all point sizes in the range defined by pname:pointSizeRange are supported. This limit specifies the granularity (or increment) between successive supported point sizes.</member>
        <member name="lineWidthGranularity">[[features-limits-lineWidthGranularity]] pname:lineWidthGranularity is the granularity of supported line widths. Not all line widths in the range defined by pname:lineWidthRange are supported. This limit specifies the granularity (or increment) between successive supported line widths.</member>
        <member name="strictLines">[[features-limits-strictLines]] pname:strictLines indicates whether lines are rasterized according to the preferred method of rasterization. If set to ename:VK_FALSE, lines may: be rasterized under a relaxed set of rules. If set to ename:VK_TRUE, lines are rasterized as per the strict definition. See &lt;&lt;primsrast-lines-basic,Basic Line Segment Rasterization&gt;&gt;.</member>
        <member name="standardSampleLocations">[[features-limits-standardSampleLocations]] pname:standardSampleLocations indicates whether rasterization uses the standard sample locations as documented in &lt;&lt;primsrast-multisampling,Multisampling&gt;&gt;. If set to ename:VK_TRUE, the implementation uses the documented sample locations. If set to ename:VK_FALSE, the implementation may: use different sample locations.</member>
        <member name="optimalBufferCopyOffsetAlignment">[[features-limits-optimalBufferCopyOffsetAlignment]] pname:optimalBufferCopyOffsetAlignment is the optimal buffer offset alignment in bytes for fname:vkCmdCopyBufferToImage and fname:vkCmdCopyImageToBuffer. The per texel alignment requirements are still enforced, this is just an additional alignment recommendation for optimal performance and power.</member>
        <member name="optimalBufferCopyRowPitchAlignment">[[features-limits-optimalBufferCopyRowPitchAlignment]] pname:optimalBufferCopyRowPitchAlignment is the optimal buffer row pitch alignment in bytes for fname:vkCmdCopyBufferToImage and fname:vkCmdCopyImageToBuffer. Row pitch is the number of bytes between texels with the same X coordinate in adjacent rows (Y coordinates differ by one). The per texel alignment requirements are still enforced, this is just an additional alignment recommendation for optimal performance and power.</member>
        <member name="nonCoherentAtomSize">[[features-limits-nonCoherentAtomSize]] pname:nonCoherentAtomSize is the size and alignment in bytes that bounds concurrent access to &lt;&lt;memory-device-hostaccess, host-mapped device memory&gt;&gt;.</member>
      </members>
    </type>
    <type name="VkPhysicalDeviceMemoryProperties" summary="Structure specifying physical device memory properties.">
      <specification />
      <members>
        <member name="memoryTypeCount">pname:memoryTypeCount is the number of valid elements in the pname:pMemoryRanges array.</member>
        <member name="memoryTypes">pname:memoryTypes is an array of slink:VkMemoryType structures describing the _memory types_ that can: be used to access memory allocated from the heaps specified by pname:memoryHeaps.</member>
        <member name="memoryHeapCount">pname:memoryHeapCount is the number of valid elements in the pname:pMemoryRanges array.</member>
        <member name="memoryHeaps">pname:memoryHeaps is an array of slink:VkMemoryHeap structures describing the _memory heaps_ from which memory can: be allocated.</member>
      </members>
    </type>
    <type name="VkPhysicalDeviceProperties" summary="Structure specifying physical device properties.">
      <specification />
      <members>
        <member name="apiVersion">pname:apiVersion is the version of Vulkan supported by the device, encoded as described in the &lt;&lt;fundamentals-versionnum,API Version Numbers and Semantics&gt;&gt; section.</member>
        <member name="driverVersion">pname:driverVersion is the vendor-specified version of the driver.</member>
        <member name="vendorID">pname:vendorID is a unique identifier for the _vendor_ (see below) of the physical device.</member>
        <member name="deviceID">pname:deviceID is a unique identifier for the physical device among devices available from the vendor.</member>
        <member name="deviceType">pname:deviceType is a elink:VkPhysicalDeviceType specifying the type of device.</member>
        <member name="deviceName">pname:deviceName is a null-terminated UTF-8 string containing the name of the device.</member>
        <member name="pipelineCacheUUID">pname:pipelineCacheUUID is an array of size ename:VK_UUID_SIZE, containing 8-bit values that represent a universally unique identifier for the device.</member>
        <member name="limits">pname:limits is the slink:VkPhysicalDeviceLimits structure which specifies device-specific limits of the physical device. See &lt;&lt;features-limits,Limits&gt;&gt; for details.</member>
        <member name="sparseProperties">pname:sparseProperties is the slink:VkPhysicalDeviceSparseProperties structure which specifies various sparse related properties of the physical device. See &lt;&lt;sparsememory-physicalprops,Sparse Properties&gt;&gt; for details.</member>
      </members>
    </type>
    <type name="VkPhysicalDeviceSparseProperties" summary="Structure specifying physical device sparse memory properties.">
      <specification />
      <members>
        <member name="residencyStandard2DBlockShape">pname:residencyStandard2DBlockShape is ename:VK_TRUE if the physical device will access all single-sample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the &lt;&lt;sparsememory-sparseblockshapessingle,Standard Sparse Image Block Shapes (Single Sample)&gt;&gt; table. If this property is not supported the value returned in the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure for single-sample 2D images is not required: to match the standard sparse image block dimensions listed in the table.</member>
        <member name="residencyStandard2DMultisampleBlockShape">pname:residencyStandard2DMultisampleBlockShape is ename:VK_TRUE if the physical device will access all multisample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the &lt;&lt;sparsememory-sparseblockshapesmsaa,Standard Sparse Image Block Shapes (MSAA)&gt;&gt; table. If this property is not supported, the value returned in the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure for multisample 2D images is not required: to match the standard sparse image block dimensions listed in the table.</member>
        <member name="residencyStandard3DBlockShape">pname:residencyStandard3DBlockShape is ename:VK_TRUE if the physical device will access all 3D sparse resources using the standard sparse image block shapes (based on image format), as described in the &lt;&lt;sparsememory-sparseblockshapessingle,Standard Sparse Image Block Shapes (Single Sample)&gt;&gt; table. If this property is not supported, the value returned in the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure for 3D images is not required: to match the standard sparse image block dimensions listed in the table.</member>
        <member name="residencyAlignedMipSize">pname:residencyAlignedMipSize is ename:VK_TRUE if images with mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block may: be placed in the mip tail. If this property is not reported, only mip levels with dimensions smaller than the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure will be placed in the mip tail. If this property is reported the implementation is allowed to return ename:VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT in the pname:flags member of sname:VkSparseImageFormatProperties, indicating that mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block will be placed in the mip tail.</member>
        <member name="residencyNonResidentStrict">pname:residencyNonResidentStrict specifies whether the physical device can: consistently access non-resident regions of a resource. If this property is ename:VK_TRUE, access to non-resident regions of resources will be guaranteed to return values as if the resource were populated with 0; writes to non-resident regions will be discarded.</member>
      </members>
    </type>
    <type name="VkPhysicalDeviceType" summary="Supported physical device types.">
      <specification />
      <members>
        <member name="VK_PHYSICAL_DEVICE_TYPE_OTHER">ename:VK_PHYSICAL_DEVICE_TYPE_OTHER The device does not match any other available types.</member>
        <member name="VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU">ename:VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU The device is typically one embedded in or tightly coupled with the host.</member>
        <member name="VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU">ename:VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU The device is typically a separate processor connected to the host via an interlink.</member>
        <member name="VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU">ename:VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU The device is typically a virtual node in a virtualization environment.</member>
        <member name="VK_PHYSICAL_DEVICE_TYPE_CPU">ename:VK_PHYSICAL_DEVICE_TYPE_CPU The device is typically running on the same processors as the host.</member>
      </members>
    </type>
    <type name="VkPipeline" summary="Opaque handle to a pipeline object.">
      <specification />
      <members />
    </type>
    <type name="VkPipelineBindPoint" summary="Specify the bind point of a pipeline object to a command buffer.">
      <specification />
      <members />
    </type>
    <type name="VkPipelineCache" summary="Opaque handle to a pipeline cache object.">
      <specification>
        <para>Pipeline cache objects allow the result of pipeline construction to be reused between pipelines and between runs of an application. Reuse between pipelines is achieved by passing the same pipeline cache object when creating multiple related pipelines. Reuse across runs of an application is achieved by retrieving pipeline cache contents in one run of an application, saving the contents, and using them to preinitialize a pipeline cache on a subsequent run. The contents of the pipeline cache objects are managed by the implementation. Applications can: manage the host memory consumed by a pipeline cache object and control the amount of data retrieved from a pipeline cache object.</para>
      </specification>
      <members />
    </type>
    <type name="VkPipelineCacheCreateInfo" summary="Structure specifying parameters of a newly created pipeline cache.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="initialDataSize">pname:initialDataSize is the number of bytes in pname:pInitialData. If pname:initialDataSize is zero, the pipeline cache will initially be empty.</member>
        <member name="pInitialData">pname:pInitialData is a pointer to previously retrieved pipeline cache data. If the pipeline cache data is incompatible (as defined below) with the device, the pipeline cache will be initially empty. If pname:initialDataSize is zero, pname:pInitialData is ignored.</member>
      </members>
    </type>
    <type name="VkPipelineCacheHeaderVersion" summary="Encode pipeline cache version.">
      <specification />
      <members />
    </type>
    <type name="VkPipelineColorBlendAttachmentState" summary="Structure specifying a pipeline color blend attachment state.">
      <specification />
      <members>
        <member name="blendEnable">pname:blendEnable controls whether blending is enabled for the corresponding color attachment. If blending is not enabled, the source fragment's color for that attachment is passed through unmodified.</member>
        <member name="srcColorBlendFactor">pname:srcColorBlendFactor selects which blend factor is used to determine the source factors latexmath:[$S_r,S_g,S_b$].</member>
        <member name="dstColorBlendFactor">pname:dstColorBlendFactor selects which blend factor is used to determine the destination factors latexmath:[$D_r,D_g,D_b$].</member>
        <member name="colorBlendOp">pname:colorBlendOp selects which blend operation is used to calculate the RGB values to write to the color attachment.</member>
        <member name="srcAlphaBlendFactor">pname:srcAlphaBlendFactor selects which blend factor is used to determine the source factor latexmath:[$S_a$].</member>
        <member name="dstAlphaBlendFactor">pname:dstAlphaBlendFactor selects which blend factor is used to determine the destination factor latexmath:[$D_a$].</member>
        <member name="alphaBlendOp">pname:alphaBlendOp selects which blend operation is use to calculate the alpha values to write to the color attachment.</member>
        <member name="colorWriteMask">pname:colorWriteMask is a bitmask selecting which of the R, G, B, and/or A components are enabled for writing, as described later in this chapter.</member>
      </members>
    </type>
    <type name="VkPipelineColorBlendStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline color blend state.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="logicOpEnable">pname:logicOpEnable controls whether to apply &lt;&lt;framebuffer-logicop, Logical Operations&gt;&gt;.</member>
        <member name="logicOp">pname:logicOp selects which logical operation to apply.</member>
        <member name="attachmentCount">pname:attachmentCount is the number of sname:VkPipelineColorBlendAttachmentState elements in pname:pAttachments. This value must: equal the pname:colorAttachmentCount for the subpass in which this pipeline is used.</member>
        <member name="pAttachments">pname:pAttachments: is a pointer to array of per target attachment states.</member>
        <member name="blendConstants">pname:blendConstants is an array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the &lt;&lt;framebuffer-blendfactors,blend factor&gt;&gt;.</member>
      </members>
    </type>
    <type name="VkPipelineCreateFlagBits" summary="Bitmask controlling how a pipeline is generated.">
      <specification />
      <members>
        <member name="VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT">ename:VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT specifies that the created pipeline will not be optimized. Using this flag may: reduce the time taken to create the pipeline.</member>
        <member name="VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT">ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT specifies that the pipeline to be created is allowed to be the parent of a pipeline that will be created in a subsequent call to flink:vkCreateGraphicsPipelines.</member>
        <member name="VK_PIPELINE_CREATE_DERIVATIVE_BIT">ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT specifies that the pipeline to be created will be a child of a previously created parent pipeline.</member>
      </members>
    </type>
    <type name="VkPipelineDepthStencilStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline depth stencil state.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="depthTestEnable">pname:depthTestEnable controls whether &lt;&lt;fragops-depth,depth testing&gt;&gt; is enabled.</member>
        <member name="depthWriteEnable">pname:depthWriteEnable controls whether &lt;&lt;fragops-depth-write,depth writes&gt;&gt; are enabled.</member>
        <member name="depthCompareOp">pname:depthCompareOp is the comparison operator used in the &lt;&lt;fragops-depth,depth test&gt;&gt;.</member>
        <member name="depthBoundsTestEnable">pname:depthBoundsTestEnable controls whether &lt;&lt;fragops-dbt,depth bounds testing&gt;&gt; is enabled.</member>
        <member name="stencilTestEnable">pname:stencilTestEnable controls whether &lt;&lt;fragops-stencil,stencil testing&gt;&gt; is enabled.</member>
        <member name="front">pname:front and pname:back control the parameters of the &lt;&lt;fragops-stencil,stencil test&gt;&gt;.</member>
        <member name="minDepthBounds">pname:minDepthBounds and pname:maxDepthBounds define the range of values used in the &lt;&lt;fragops-dbt,depth bounds test&gt;&gt;.</member>
      </members>
    </type>
    <type name="VkPipelineDynamicStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline dynamic state.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="dynamicStateCount">pname:dynamicStateCount is the number of elements in the pname:pDynamicStates array.</member>
        <member name="pDynamicStates">pname:pDynamicStates is an array of elink:VkDynamicState enums which indicate which pieces of pipeline state will use the values from dynamic state commands rather than from the pipeline state creation info.</member>
      </members>
    </type>
    <type name="VkPipelineInputAssemblyStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline input assembly state.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="topology">pname:topology is a elink:VkPrimitiveTopology defining the primitive topology, as described below.</member>
        <member name="primitiveRestartEnable">pname:primitiveRestartEnable controls whether a special vertex index value is treated as restarting the assembly of primitives. This enable only applies to indexed draws (flink:vkCmdDrawIndexed and flink:vkCmdDrawIndexedIndirect), and the special index value is either 0xFFFFFFFF when the pname:indexType parameter of fname:vkCmdBindIndexBuffer is equal to ename:VK_INDEX_TYPE_UINT32, or 0xFFFF when pname:indexType is equal to ename:VK_INDEX_TYPE_UINT16. Primitive restart is not allowed for ``list'' topologies.</member>
      </members>
    </type>
    <type name="VkPipelineLayout" summary="Opaque handle to a pipeline layout object.">
      <specification>
        <para>Access to descriptor sets from a pipeline is accomplished through a _pipeline layout_. Zero or more descriptor set layouts and zero or more push constant ranges are combined to form a pipeline layout object which describes the complete set of resources that can: be accessed by a pipeline. The pipeline layout represents a sequence of descriptor sets with each having a specific layout. This sequence of layouts is used to determine the interface between shader stages and shader resources. Each pipeline is created using a pipeline layout.</para>
      </specification>
      <members />
    </type>
    <type name="VkPipelineLayoutCreateInfo" summary="Structure specifying the parameters of a newly created pipeline layout object.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="setLayoutCount">pname:setLayoutCount is the number of descriptor sets included in the pipeline layout.</member>
        <member name="pSetLayouts">pname:pSetLayouts is a pointer to an array of sname:VkDescriptorSetLayout objects.</member>
        <member name="pushConstantRangeCount">pname:pushConstantRangeCount is the number of push constant ranges included in the pipeline layout.</member>
        <member name="pPushConstantRanges">pname:pPushConstantRanges is a pointer to an array of sname:VkPushConstantRange structures defining a set of push constant ranges for use in a single pipeline layout. In addition to descriptor set layouts, a pipeline layout also describes how many push constants can: be accessed by each stage of the pipeline. + [NOTE] .Note ==== Push constants represent a high speed path to modify constant data in pipelines that is expected to outperform memory-backed resource updates. ====</member>
      </members>
    </type>
    <type name="VkPipelineMultisampleStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline multisample state.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="rasterizationSamples">pname:rasterizationSamples is a elink:VkSampleCountFlagBits specifying the number of samples per pixel used in rasterization.</member>
        <member name="sampleShadingEnable">pname:sampleShadingEnable specifies that fragment shading executes per-sample if ename:VK_TRUE, or per-fragment if ename:VK_FALSE, as described in &lt;&lt;primsrast-sampleshading,Sample Shading&gt;&gt;.</member>
        <member name="minSampleShading">pname:minSampleShading is the minimum fraction of sample shading, as described in &lt;&lt;primsrast-sampleshading,Sample Shading&gt;&gt;.</member>
        <member name="pSampleMask">pname:pSampleMask is a bitmask of static coverage information that is ANDed with the coverage information generated during rasterization, as described in &lt;&lt;fragops-samplemask,Sample Mask&gt;&gt;.</member>
        <member name="alphaToCoverageEnable">pname:alphaToCoverageEnable controls whether a temporary coverage value is generated based on the alpha component of the fragment's first color output as specified in the &lt;&lt;fragops-covg,Multisample Coverage&gt;&gt; section.</member>
        <member name="alphaToOneEnable">pname:alphaToOneEnable controls whether the alpha component of the fragment's first color output is replaced with one as described in &lt;&lt;fragops-covg,Multisample Coverage&gt;&gt;.</member>
      </members>
    </type>
    <type name="VkPipelineRasterizationStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline rasterization state.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="depthClampEnable">pname:depthClampEnable controls whether to clamp the fragment's depth values instead of clipping primitives to the z planes of the frustum, as described in &lt;&lt;vertexpostproc-clipping,Primitive Clipping&gt;&gt;.</member>
        <member name="rasterizerDiscardEnable">pname:rasterizerDiscardEnable controls whether primitives are discarded immediately before the rasterization stage.</member>
        <member name="polygonMode">pname:polygonMode is the triangle rendering mode. See elink:VkPolygonMode.</member>
        <member name="cullMode">pname:cullMode is the triangle facing direction used for primitive culling. See elink:VkCullModeFlagBits.</member>
        <member name="frontFace">pname:frontFace is the front-facing triangle orientation to be used for culling. See elink:VkFrontFace.</member>
        <member name="depthBiasEnable">pname:depthBiasEnable controls whether to bias fragment depth values.</member>
        <member name="depthBiasConstantFactor">pname:depthBiasConstantFactor is a scalar factor controlling the constant depth value added to each fragment.</member>
        <member name="depthBiasClamp">pname:depthBiasClamp is the maximum (or minimum) depth bias of a fragment.</member>
        <member name="depthBiasSlopeFactor">pname:depthBiasSlopeFactor is a scalar factor applied to a fragment's slope in depth bias calculations.</member>
        <member name="lineWidth">pname:lineWidth is the width of rasterized line segments.</member>
      </members>
    </type>
    <type name="VkPipelineShaderStageCreateInfo" summary="Structure specifying parameters of a newly created pipeline shader stage.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="stage">pname:stage names a single pipeline stage. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkPipelineStageFlagBits" summary="Bitmask specifying pipeline stages.">
      <specification />
      <members />
    </type>
    <type name="VkPipelineTessellationStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline tessellation state.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="patchControlPoints">pname:patchControlPoints number of control points per patch.</member>
      </members>
    </type>
    <type name="VkPipelineVertexInputStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline vertex input state.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="vertexBindingDescriptionCount">pname:vertexBindingDescriptionCount is the number of vertex binding descriptions provided in pname:pVertexBindingDescriptions.</member>
        <member name="pVertexBindingDescriptions">pname:pVertexBindingDescriptions is a pointer to an array of sname:VkVertexInputBindingDescription structures.</member>
        <member name="vertexAttributeDescriptionCount">pname:vertexAttributeDescriptionCount is the number of vertex attribute descriptions provided in pname:pVertexAttributeDescriptions.</member>
        <member name="pVertexAttributeDescriptions">pname:pVertexAttributeDescriptions is a pointer to an array of sname:VkVertexInputAttributeDescription structures.</member>
      </members>
    </type>
    <type name="VkPipelineViewportStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline viewport state.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="viewportCount">pname:viewportCount is the number of viewports used by the pipeline.</member>
        <member name="pViewports">pname:pViewports is a pointer to an array of slink:VkViewport structures, defining the viewport transforms. If the viewport state is dynamic, this member is ignored.</member>
        <member name="scissorCount">pname:scissorCount is the number of &lt;&lt;fragops-scissor,scissors&gt;&gt; and must: match the number of viewports.</member>
        <member name="pScissors">pname:pScissors is a pointer to an array of sname:VkRect2D structures which define the rectangular bounds of the scissor for the corresponding viewport. If the scissor state is dynamic, this member is ignored.</member>
      </members>
    </type>
    <type name="VkPolygonMode" summary="Control polygon rasterization mode.">
      <specification />
      <members />
    </type>
    <type name="VkPresentInfoKHR" summary="Structure describing parameters of a queue presentation.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_PRESENT_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="waitSemaphoreCount">pname:waitSemaphoreCount is the number of semaphores to wait for before issuing the present request.  The number may: be zero.</member>
        <member name="pWaitSemaphores">pname:pWaitSemaphores, if not code:VK_NULL_HANDLE, is an array of sname:VkSemaphore objects with pname:waitSemaphoreCount entries, and specifies the semaphores to wait for before issuing the present request.</member>
        <member name="swapchainCount">pname:swapchainCount is the number of swapchains being presented to by this command.</member>
        <member name="pSwapchains">pname:pSwapchains is an array of sname:VkSwapchainKHR objects with pname:swapchainCount entries.  A given swapchain must: not appear in this list more than once.</member>
        <member name="pImageIndices">pname:pImageIndices is an array of indices into the array of each swapchain's presentable images, with pname:swapchainCount entries.  Each entry in this array identifies the image to present on the corresponding entry in the pname:pSwapchains array.</member>
        <member name="pResults">pname:pResults is an array of ename:VkResult typed elements with pname:swapchainCount entries. Applications that don't need per-swapchain results can: use `NULL` for pname:pResults. If non-`NULL`, each entry in pname:pResults will be set to the ename:VkResult for presenting the swapchain corresponding to the same index in pname:pSwapchains.</member>
      </members>
    </type>
    <type name="VkPresentModeKHR" summary="Presentation mode supported for a surface.">
      <specification />
      <members>
        <member name="VK_PRESENT_MODE_IMMEDIATE_KHR">ename:VK_PRESENT_MODE_IMMEDIATE_KHR: The presentation engine does not wait for a vertical blanking period to update the current image, meaning this mode may: result in visible tearing. No internal queuing of presentation requests is needed, as the requests are applied immediately.</member>
        <member name="VK_PRESENT_MODE_MAILBOX_KHR">ename:VK_PRESENT_MODE_MAILBOX_KHR: The presentation engine waits for the next vertical blanking period to update the current image. Tearing cannot: be observed. An internal single-entry queue is used to hold pending presentation requests. If the queue is full when a new presentation request is received, the new request replaces the existing entry, and any images associated with the prior entry become available for re-use by the application. One request is removed from the queue and processed during each vertical blanking period in which the queue is non-empty.</member>
        <member name="VK_PRESENT_MODE_FIFO_KHR">ename:VK_PRESENT_MODE_FIFO_KHR: The presentation engine waits for the next vertical blanking period to update the current image. Tearing cannot: be observed. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during each vertical blanking period in which the queue is non-empty. This is the only value of pname:presentMode that is required: to be supported.</member>
        <member name="VK_PRESENT_MODE_FIFO_RELAXED_KHR">ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR: The presentation engine generally waits for the next vertical blanking period to update the current image. If a vertical blanking period has already passed since the last update of the current image then the presentation engine does not wait for another vertical blanking period for the update, meaning this mode may: result in visible tearing in this case. This mode is useful for reducing visual stutter with an application that will mostly present a new image before the next vertical blanking period, but may occasionally be late, and present a new image just after the next vertical blanking period. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during or after each vertical blanking period in which the queue is non-empty.</member>
      </members>
    </type>
    <type name="VkPrimitiveTopology" summary="Supported primitive topologies.">
      <specification />
      <members />
    </type>
    <type name="VkPushConstantRange" summary="Structure specifying a push constant range.">
      <specification />
      <members>
        <member name="stageFlags">pname:stageFlags is a set of stage flags describing the shader stages that will access a range of push constants. If a particular stage is not included in the range, then accessing members of that range of push constants from the corresponding shader stage will result in undefined data being read.</member>
        <member name="offset">pname:offset and pname:size are the start offset and size, respectively, consumed by the range. Both pname:offset and pname:size are in units of bytes and must: be a multiple of 4. The layout of the push constant variables is specified in the shader.</member>
      </members>
    </type>
    <type name="VkQueryControlFlagBits" summary="Bitmask specifying constraints on a query.">
      <specification />
      <members />
    </type>
    <type name="VkQueryPipelineStatisticFlagBits" summary="Bitmask specifying queried pipeline statistics.">
      <specification />
      <members />
    </type>
    <type name="VkQueryPool" summary="Opaque handle to a query pool object.">
      <specification>
        <para>Queries are managed using _query pool_ objects. Each query pool is a collection of a specific number of queries of a particular type.</para>
      </specification>
      <members />
    </type>
    <type name="VkQueryPoolCreateInfo" summary="Structure specifying parameters of a newly created query pool.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="queryType">pname:queryType is the type of queries managed by the pool, and must: be one of the values + --</member>
      </members>
    </type>
    <type name="VkQueryResultFlagBits" summary="Bitmask specifying how and when query results are returned.">
      <specification />
      <members />
    </type>
    <type name="VkQueryType" summary="Specify the type of queries managed by a query pool.">
      <specification />
      <members />
    </type>
    <type name="VkQueue" summary="Opaque handle to a queue object.">
      <specification>
        <para>Creating a logical device also creates the queues associated with that device. The queues to create are described by a set of slink:VkDeviceQueueCreateInfo structures that are passed to flink:vkCreateDevice in pname:pQueueCreateInfos.</para>
      </specification>
      <members />
    </type>
    <type name="VkQueueFamilyProperties" summary="Structure providing information about a queue family.">
      <specification />
      <members>
        <member name="queueFlags">pname:queueFlags contains flags indicating the capabilities of the queues in this queue family.</member>
        <member name="queueCount">pname:queueCount is the unsigned integer count of queues in this queue family.</member>
        <member name="timestampValidBits">pname:timestampValidBits is the unsigned integer count of meaningful bits in the timestamps written via fname:vkCmdWriteTimestamp. The valid range for the count is 36..64 bits, or a value of 0, indicating no support for timestamps. Bits outside the valid range are guaranteed to be zeros.</member>
        <member name="minImageTransferGranularity">pname:minImageTransferGranularity is the minimum granularity supported for image transfer operations on the queues in this queue family.</member>
      </members>
    </type>
    <type name="VkQueueFlagBits" summary="Bitmask specifying capabilities of queues in a queue family.">
      <specification />
      <members>
        <member name="VK_QUEUE_GRAPHICS_BIT">if ename:VK_QUEUE_GRAPHICS_BIT is set, then the queues in this queue family support graphics operations.</member>
        <member name="VK_QUEUE_COMPUTE_BIT">if ename:VK_QUEUE_COMPUTE_BIT is set, then the queues in this queue family support compute operations.</member>
        <member name="VK_QUEUE_TRANSFER_BIT">if ename:VK_QUEUE_TRANSFER_BIT is set, then the queues in this queue family support transfer operations.</member>
        <member name="VK_QUEUE_SPARSE_BINDING_BIT">if ename:VK_QUEUE_SPARSE_BINDING_BIT is set, then the queues in this queue family support sparse memory management operations (see &lt;&lt;sparsememory,Sparse Resources&gt;&gt;). If any of the sparse resource features are enabled, then at least one queue family must: support this bit.</member>
      </members>
    </type>
    <type name="VkRect2D" summary="Structure specifying a two-dimensional subregion.">
      <specification />
      <members />
    </type>
    <type name="VkRenderPass" summary="Opaque handle to a render pass object.">
      <specification>
        <para>A _render pass_ represents a collection of attachments, subpasses, and dependencies between the subpasses, and describes how the attachments are used over the course of the subpasses. The use of a render pass in a command buffer is a  _render pass instance_.</para>
      </specification>
      <members />
    </type>
    <type name="VkRenderPassBeginInfo" summary="Structure specifying render pass begin info.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="renderPass">pname:renderPass is the render pass to begin an instance of.</member>
        <member name="framebuffer">pname:framebuffer is the framebuffer containing the attachments that are used with the render pass.</member>
        <member name="renderArea">pname:renderArea is the render area that is affected by the render pass instance, and is described in more detail below.</member>
        <member name="clearValueCount">pname:clearValueCount is the number of elements in pname:pClearValues.</member>
        <member name="pClearValues">pname:pClearValues is an array of slink:VkClearValue structures that contains clear values for each attachment, if the attachment uses a pname:loadOp value of ename:VK_ATTACHMENT_LOAD_OP_CLEAR or if the attachment has a depth/stencil format and uses a pname:stencilLoadOp value of ename:VK_ATTACHMENT_LOAD_OP_CLEAR. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of pname:pClearValues are ignored.</member>
      </members>
    </type>
    <type name="VkRenderPassCreateInfo" summary="Structure specifying parameters of a newly created render pass.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="attachmentCount">pname:attachmentCount is the number of attachments used by this render pass, or zero indicating no attachments. Attachments are referred to by zero-based indices in the range [0,pname:attachmentCount).</member>
        <member name="pAttachments">pname:pAttachments points to an array of pname:attachmentCount number of slink:VkAttachmentDescription structures describing properties of the attachments, or `NULL` if pname:attachmentCount is zero.</member>
        <member name="subpassCount">pname:subpassCount is the number of subpasses to create for this render pass. Subpasses are referred to by zero-based indices in the range [0,pname:subpassCount). A render pass must: have at least one subpass.</member>
        <member name="pSubpasses">pname:pSubpasses points to an array of pname:subpassCount number of slink:VkSubpassDescription structures describing properties of the subpasses.</member>
        <member name="dependencyCount">pname:dependencyCount is the number of dependencies between pairs of subpasses, or zero indicating no dependencies.</member>
        <member name="pDependencies">pname:pDependencies points to an array of pname:dependencyCount number of slink:VkSubpassDependency structures describing dependencies between pairs of subpasses, or `NULL` if pname:dependencyCount is zero.</member>
      </members>
    </type>
    <type name="VkResult" summary="Vulkan command return codes.">
      <specification>
        <para>While the core Vulkan API is not designed to capture incorrect usage, some circumstances still require return codes. Commands in Vulkan return their status via return codes that are in one of two categories:</para>
        <para>  * Successful completion codes are returned when a command needs to     communicate success or status information. All successful completion     codes are non-negative values.   * Run time error codes are returned when a command needs to communicate a     failure that could only be detected at run time. All run time error     codes are negative values.</para>
      </specification>
      <members />
    </type>
    <type name="VkSampleCountFlagBits" summary="Bitmask specifying sample counts supported for an image used for storage operations.">
      <specification />
      <members />
    </type>
    <type name="VkSampleMask" summary="Mask of sample coverage information.">
      <specification />
      <members />
    </type>
    <type name="VkSampler" summary="Opaque handle to a sampler object.">
      <specification>
        <para>sname:VkSampler objects represent the state of an image sampler which is used by the implementation to read image data and apply filtering and other transformations for the shader.</para>
      </specification>
      <members />
    </type>
    <type name="VkSamplerAddressMode" summary="Specify behavior of sampling with texture coordinates outside an image.">
      <specification />
      <members />
    </type>
    <type name="VkSamplerCreateInfo" summary="Structure specifying parameters of a newly created sampler.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="magFilter">pname:magFilter is the magnification filter to apply to lookups, and is of type: + --</member>
      </members>
    </type>
    <type name="VkSamplerMipmapMode" summary="Specify mipmap mode used for texture lookups.">
      <specification />
      <members />
    </type>
    <type name="VkSemaphore" summary="Opaque handle to a semaphore object.">
      <specification>
        <para>Semaphores are used to coordinate queue operations both within a queue and between different queues. A semaphore's status is always either _signaled_ or _unsignaled_.</para>
      </specification>
      <members />
    </type>
    <type name="VkSemaphoreCreateInfo" summary="Structure specifying parameters of a newly created semaphore.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
      </members>
    </type>
    <type name="VkShaderModule" summary="Opaque handle to a shader module object.">
      <specification>
        <para>_Shader modules_ contain _shader code_ and one or more entry points. Shaders are selected from a shader module by specifying an entry point as part of &lt;&lt;pipelines,pipeline&gt;&gt; creation. The stages of a pipeline can: use shaders that come from different modules. The shader code defining a shader module must: be in the SPIR-V format, as described by the &lt;&lt;spirvenv,Vulkan Environment for SPIR-V&gt;&gt; appendix.</para>
      </specification>
      <members />
    </type>
    <type name="VkShaderModuleCreateInfo" summary="Structure specifying parameters of a newly created shader module.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="codeSize">pname:codeSize is the size, in bytes, of the code pointed to by pname:pCode.</member>
        <member name="pCode">pname:pCode points to code that is used to create the shader module. The type and format of the code is determined from the content of the memory addressed by pname:pCode.</member>
      </members>
    </type>
    <type name="VkShaderStageFlagBits" summary="Bitmask specifying a pipeline stage.">
      <specification />
      <members />
    </type>
    <type name="VkSharingMode" summary="Buffer and image sharing modes.">
      <specification />
      <members>
        <member name="VK_SHARING_MODE_EXCLUSIVE">ename:VK_SHARING_MODE_EXCLUSIVE specifies that access to any range or image subresource of the object will be exclusive to a single queue family at a time.</member>
        <member name="VK_SHARING_MODE_CONCURRENT">ename:VK_SHARING_MODE_CONCURRENT specifies that concurrent access to any range or image subresource of the object from multiple queue families is supported.</member>
      </members>
    </type>
    <type name="VkSparseBufferMemoryBindInfo" summary="Structure specifying a sparse buffer memory bind operation.">
      <specification />
      <members>
        <member name="buffer">pname:buffer is the sname:VkBuffer object to be bound.</member>
        <member name="bindCount">pname:bindCount is the number of sname:VkSparseMemoryBind structures in the pname:pBinds array.</member>
        <member name="pBinds">pname:pBinds is a pointer to array of sname:VkSparseMemoryBind structures.</member>
      </members>
    </type>
    <type name="VkSparseImageFormatFlagBits" summary="Bitmask specifying additional information about a sparse image resource.">
      <specification />
      <members />
    </type>
    <type name="VkSparseImageFormatProperties" summary="Structure specifying sparse image format properties.">
      <specification />
      <members>
        <member name="aspectMask">pname:aspectMask is a bitmask of elink:VkImageAspectFlagBits specifying which aspects of the image the properties apply to.</member>
        <member name="imageGranularity">pname:imageGranularity is the width, height, and depth of the sparse image block in texels or compressed texel blocks.</member>
        <member name="flags">pname:flags is a bitmask specifying additional information about the sparse resource. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkSparseImageMemoryBind" summary="Structure specifying sparse image memory bind.">
      <specification />
      <members>
        <member name="subresource">pname:subresource is the aspectMask and region of interest in the image.</member>
        <member name="offset">pname:offset are the coordinates of the first texel within the image subresource to bind.</member>
        <member name="extent">pname:extent is the size in texels of the region within the image subresource to bind. The extent must: be a multiple of the sparse image block dimensions, except when binding sparse image blocks along the edge of an image subresource it can: instead be such that any coordinate of latexmath:[$\mathit{offset} + \mathit{extent}$] equals the corresponding dimensions of the image subresource.</member>
        <member name="memory">pname:memory is the sname:VkDeviceMemory object that the sparse image blocks of the image are bound to. If pname:memory is dlink:VK_NULL_HANDLE, the sparse image blocks are unbound.</member>
        <member name="memoryOffset">pname:memoryOffset is an offset into sname:VkDeviceMemory object. If pname:memory is dlink:VK_NULL_HANDLE, this value is ignored.</member>
        <member name="flags">pname:flags are sparse memory binding flags.</member>
      </members>
    </type>
    <type name="VkSparseImageMemoryBindInfo" summary="Structure specifying sparse image memory bind info.">
      <specification />
      <members>
        <member name="image">pname:image is the sname:VkImage object to be bound</member>
        <member name="bindCount">pname:bindCount is the number of sname:VkSparseImageMemoryBind structures in pBinds array</member>
        <member name="pBinds">pname:pBinds is a pointer to array of sname:VkSparseImageMemoryBind structures</member>
      </members>
    </type>
    <type name="VkSparseImageMemoryRequirements" summary="Structure specifying sparse image memory requirements.">
      <specification />
      <members>
        <member name="formatProperties.aspectMask">pname:formatProperties.aspectMask is the set of aspects of the image that this sparse memory requirement applies to. This will usually have a single aspect specified. However, depth/stencil images may: have depth and stencil data interleaved in the same sparse block, in which case both ename:VK_IMAGE_ASPECT_DEPTH_BIT and ename:VK_IMAGE_ASPECT_STENCIL_BIT would be present.</member>
        <member name="formatProperties.imageGranularity">pname:formatProperties.imageGranularity describes the dimensions of a single bindable sparse image block in pixel units. For aspect ename:VK_IMAGE_ASPECT_METADATA_BIT, all dimensions will be zero pixels. All metadata is located in the mip tail region.</member>
        <member name="formatProperties.flags">pname:formatProperties.flags is a bitmask of elink:VkSparseImageFormatFlagBits:</member>
        <member name="VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT">* If ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT is set the image uses a single mip tail region for all array layers.</member>
        <member name="VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT">* If ename:VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT is set the dimensions of mip levels must: be integer multiples of the corresponding dimensions of the sparse image block for levels not located in the mip tail.</member>
        <member name="VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT">* If ename:VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT is set the image uses non-standard sparse image block dimensions. The pname:formatProperties.imageGranularity values do not match the standard sparse image block dimension corresponding to the image's pixel format.</member>
        <member name="imageMipTailFirstLod">pname:imageMipTailFirstLod is the first mip level at which image subresources are included in the mip tail region.</member>
        <member name="imageMipTailSize">pname:imageMipTailSize is the memory size (in bytes) of the mip tail region. If pname:formatProperties.flags contains ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT, this is the size of the whole mip tail, otherwise this is the size of the mip tail of a single array layer. This value is guaranteed to be a multiple of the sparse block size in bytes.</member>
        <member name="imageMipTailOffset">pname:imageMipTailOffset is the opaque memory offset used with slink:VkSparseImageOpaqueMemoryBindInfo to bind the mip tail region(s).</member>
        <member name="imageMipTailStride">pname:imageMipTailStride is the offset stride between each array-layer's mip tail, if pname:formatProperties.flags does not contain ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT (otherwise the value is undefined).</member>
      </members>
    </type>
    <type name="VkSparseImageOpaqueMemoryBindInfo" summary="Structure specifying sparse image opaque memory bind info.">
      <specification />
      <members>
        <member name="image">pname:image is the sname:VkImage object to be bound.</member>
        <member name="bindCount">pname:bindCount is the number of sname:VkSparseMemoryBind structures in the pname:pBinds array.</member>
        <member name="pBinds">pname:pBinds is a pointer to array of sname:VkSparseMemoryBind structures.</member>
      </members>
    </type>
    <type name="VkSparseMemoryBind" summary="Structure specifying a sparse memory bind operation.">
      <specification />
      <members>
        <member name="resourceOffset">pname:resourceOffset is the offset into the resource.</member>
        <member name="size">pname:size is the size of the memory region to be bound.</member>
        <member name="memory">pname:memory is the sname:VkDeviceMemory object that the range of the resource is bound to. If pname:memory is dlink:VK_NULL_HANDLE, the range is unbound.</member>
        <member name="memoryOffset">pname:memoryOffset is the offset into the sname:VkDeviceMemory object to bind the resource range to. If pname:memory is dlink:VK_NULL_HANDLE, this value is ignored.</member>
        <member name="flags">pname:flags is a bitmask specifying usage of the binding operation. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkSparseMemoryBindFlagBits" summary="Bitmask specifying usage of a sparse memory binding operation.">
      <specification />
      <members />
    </type>
    <type name="VkSpecializationInfo" summary="Structure specifying specialization info.">
      <specification />
      <members>
        <member name="mapEntryCount">pname:mapEntryCount is the number of entries in the pname:pMapEntries array.</member>
        <member name="pMapEntries">pname:pMapEntries is a pointer to an array of sname:VkSpecializationMapEntry which maps constant IDs to offsets in pname:pData.</member>
        <member name="dataSize">pname:dataSize is the byte size of the pname:pData buffer.</member>
        <member name="pData">pname:pData contains the actual constant values to specialize with.</member>
      </members>
    </type>
    <type name="VkSpecializationMapEntry" summary="Structure specifying a specialization map entry.">
      <specification />
      <members>
        <member name="constantID">pname:constantID is the ID of the specialization constant in SPIR-V.</member>
        <member name="offset">pname:offset is the byte offset of the specialization constant value within the supplied data buffer.</member>
        <member name="size">pname:size is the byte size of the specialization constant value within the supplied data buffer.</member>
      </members>
    </type>
    <type name="VkStencilFaceFlagBits" summary="Bitmask specifying sets of stencil state for which to update the compare mask.">
      <specification />
      <members />
    </type>
    <type name="VkStencilOp" summary="Stencil comparison function.">
      <specification />
      <members />
    </type>
    <type name="VkStencilOpState" summary="Structure specifying stencil operation state.">
      <specification />
      <members>
        <member name="failOp">pname:failOp is the action performed on samples that fail the stencil test.</member>
        <member name="passOp">pname:passOp is the action performed on samples that pass both the depth and stencil tests.</member>
        <member name="depthFailOp">pname:depthFailOp is the action performed on samples that pass the stencil test and fail the depth test.</member>
        <member name="compareOp">pname:compareOp is the comparison operator used in the stencil test.</member>
        <member name="compareMask">pname:compareMask selects the bits of the unsigned integer stencil values participating in the stencil test.</member>
        <member name="writeMask">pname:writeMask selects the bits of the unsigned integer stencil values updated by the stencil test in the stencil framebuffer attachment.</member>
        <member name="reference">pname:reference is an integer reference value that is used in the unsigned stencil comparison.</member>
      </members>
    </type>
    <type name="VkSubmitInfo" summary="Structure specifying a queue submit operation.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="waitSemaphoreCount">pname:waitSemaphoreCount is the number of semaphores upon which to wait before executing the command buffers for the batch.</member>
        <member name="pWaitSemaphores">pname:pWaitSemaphores is a pointer to an array of semaphores upon which to wait before the command buffers for this batch begin execution. If semaphores to wait on are provided, they define a &lt;&lt;synchronization-semaphores-waiting, semaphore wait operation&gt;&gt;.</member>
        <member name="pWaitDstStageMask">pname:pWaitDstStageMask is a pointer to an array of pipeline stages at which each corresponding semaphore wait will occur.</member>
        <member name="commandBufferCount">pname:commandBufferCount is the number of command buffers to execute in the batch.</member>
        <member name="pCommandBuffers">pname:pCommandBuffers is a pointer to an array of command buffers to execute in the batch. The command buffers submitted in a batch begin execution in the order they appear in pname:pCommandBuffers, but may: complete out of order.</member>
        <member name="signalSemaphoreCount">pname:signalSemaphoreCount is the number of semaphores to be signaled once the commands specified in pname:pCommandBuffers have completed execution.</member>
        <member name="pSignalSemaphores">pname:pSignalSemaphores is a pointer to an array of semaphores which will be signaled when the command buffers for this batch have completed execution. If semaphores to be signaled are provided, they define a &lt;&lt;synchronization-semaphores-signaling, semaphore signal operation&gt;&gt;.</member>
      </members>
    </type>
    <type name="VkSubpassContents" summary="Specify how commands in the first subpass of a render pass are provided.">
      <specification />
      <members />
    </type>
    <type name="VkSubpassDependency" summary="Structure specifying a subpass dependency.">
      <specification />
      <members>
        <member name="srcSubpass">pname:srcSubpass and pname:dstSubpass are the subpass indices of the producer and consumer subpasses, respectively. pname:srcSubpass and pname:dstSubpass can: also have the special value ename:VK_SUBPASS_EXTERNAL. The source subpass must: always be a lower numbered subpass than the destination subpass (excluding external subpasses and &lt;&lt;synchronization-pipeline-barriers-subpass-self-dependencies, self-dependencies&gt;&gt;), so that the order of subpass descriptions is a valid execution ordering, avoiding cycles in the dependency graph.</member>
        <member name="srcStageMask">pname:srcStageMask, pname:dstStageMask, pname:srcAccessMask, pname:dstAccessMask, and pname:dependencyFlags describe an &lt;&lt;synchronization-execution-and-memory-dependencies,execution and memory dependency&gt;&gt; between subpasses. The bits that can: be included in pname:dependencyFlags are: + --</member>
      </members>
    </type>
    <type name="VkSubpassDescription" summary="Structure specifying a subpass description.">
      <specification />
      <members>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="pipelineBindPoint">pname:pipelineBindPoint is a elink:VkPipelineBindPoint value specifying whether this is a compute or graphics subpass. Currently, only graphics subpasses are supported.</member>
        <member name="inputAttachmentCount">pname:inputAttachmentCount is the number of input attachments.</member>
        <member name="pInputAttachments">pname:pInputAttachments is an array of slink:VkAttachmentReference structures (defined below) that lists which of the render pass's attachments can: be read in the shader during the subpass, and what layout each attachment will be in during the subpass. Each element of the array corresponds to an input attachment unit number in the shader, i.e. if the shader declares an input variable `layout(input_attachment_index=X, set=Y, binding=Z)` then it uses the attachment provided in pname:pInputAttachments[X]. Input attachments must: also be bound to the pipeline with a descriptor set, with the input attachment descriptor written in the location (set=Y, binding=Z).</member>
        <member name="colorAttachmentCount">pname:colorAttachmentCount is the number of color attachments.</member>
        <member name="pColorAttachments">pname:pColorAttachments is an array of pname:colorAttachmentCount slink:VkAttachmentReference structures that lists which of the render pass's attachments will be used as color attachments in the subpass, and what layout each attachment will be in during the subpass. Each element of the array corresponds to a fragment shader output location, i.e. if the shader declared an output variable `layout(location=X)` then it uses the attachment provided in pname:pColorAttachments[X].</member>
        <member name="pResolveAttachments">pname:pResolveAttachments is `NULL` or an array of pname:colorAttachmentCount slink:VkAttachmentReference structures that lists which of the render pass's attachments are resolved to at the end of the subpass, and what layout each attachment will be in during the resolve. If pname:pResolveAttachments is not `NULL`, each of its elements corresponds to a color attachment (the element in pname:pColorAttachments at the same index). At the end of each subpass, the subpass's color attachments are resolved to corresponding resolve attachments, unless the resolve attachment index is ename:VK_ATTACHMENT_UNUSED or pname:pResolveAttachments is `NULL`. If the first use of an attachment in a render pass is as a resolve attachment, then the pname:loadOp is effectively ignored as the resolve is guaranteed to overwrite all pixels in the render area.</member>
        <member name="pDepthStencilAttachment">pname:pDepthStencilAttachment is a pointer to a slink:VkAttachmentReference specifying which attachment will be used for depth/stencil data and the layout it will be in during the subpass. Setting the attachment index to ename:VK_ATTACHMENT_UNUSED or leaving this pointer as `NULL` indicates that no depth/stencil attachment will be used in the subpass.</member>
        <member name="preserveAttachmentCount">pname:preserveAttachmentCount is the number of preserved attachments.</member>
        <member name="pPreserveAttachments">pname:pPreserveAttachments is an array of pname:preserveAttachmentCount render pass attachment indices describing the attachments that are not used by a subpass, but whose contents must: be preserved throughout the subpass.</member>
      </members>
    </type>
    <type name="VkSubresourceLayout" summary="Structure specifying subresource layout.">
      <specification />
      <members>
        <member name="offset">pname:offset is the byte offset from the start of the image where the image subresource begins.</member>
        <member name="size">pname:size is the size in bytes of the image subresource. pname:size includes any extra memory that is required based on pname:rowPitch.</member>
        <member name="rowPitch">pname:rowPitch describes the number of bytes between each row of texels in an image.</member>
        <member name="arrayPitch">pname:arrayPitch describes the number of bytes between each array layer of an image.</member>
        <member name="depthPitch">pname:depthPitch describes the number of bytes between each slice of 3D image.</member>
      </members>
    </type>
    <type name="VkSurfaceCapabilitiesKHR" summary="Structure describing capabilities of a surface.">
      <specification />
      <members>
        <member name="minImageCount">pname:minImageCount is the minimum number of images the specified device supports for a swapchain created for the surface.</member>
        <member name="maxImageCount">pname:maxImageCount is the maximum number of images the specified device supports for a swapchain created for the surface.  A value of `0` means that there is no limit on the number of images, though there may: be limits related to the total amount of memory used by swapchain images.</member>
        <member name="currentExtent">pname:currentExtent is the current width and height of the surface, or the special value latexmath:[$(0xFFFFFFFF, 0xFFFFFFFF)$] indicating that the surface size will be determined by the extent of a swapchain targeting the surface.</member>
        <member name="minImageExtent">pname:minImageExtent contains the smallest valid swapchain extent for the surface on the specified device.</member>
        <member name="maxImageExtent">pname:maxImageExtent contains the largest valid swapchain extent for the surface on the specified device.</member>
        <member name="maxImageArrayLayers">pname:maxImageArrayLayers is the maximum number of layers swapchain images can: have for a swapchain created for this device and surface.</member>
        <member name="supportedTransforms">pname:supportedTransforms is a bitmask of elink:VkSurfaceTransformFlagBitsKHR, describing the presentation transforms supported for the surface on the specified device.</member>
        <member name="currentTransform">pname:currentTransform is a bitmask of elink:VkSurfaceTransformFlagBitsKHR, describing the surface's current transform relative to the presentation engine's natural orientation.</member>
        <member name="supportedCompositeAlpha">pname:supportedCompositeAlpha is a bitmask of elink:VkCompositeAlphaFlagBitsKHR, representing the alpha compositing modes supported by the presentation engine for the surface on the specified device.  Opaque composition can: be achieved in any alpha compositing mode by either using a swapchain image format that has no alpha component, or by ensuring that all pixels in the swapchain images have an alpha value of 1.0.</member>
        <member name="supportedUsageFlags">pname:supportedUsageFlags is a bitmask of elink:VkImageUsageFlagBits representing the ways the application can: use the presentable images of a swapchain created for the surface on the specified device. ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT must: be included in the set but implementations may: support additional usages.</member>
      </members>
    </type>
    <type name="VkSurfaceFormatKHR" summary="Structure describing a supported swapchain format-color space pair.">
      <specification />
      <members>
        <member name="format">pname:format is a ename:VkFormat that is compatible with the specified surface.</member>
        <member name="colorSpace">pname:colorSpace is a presentation ename:VkColorSpaceKHR that is compatible with the surface.</member>
      </members>
    </type>
    <type name="VkSurfaceTransformFlagBitsKHR" summary="Presentation transforms supported on a device.">
      <specification />
      <members />
    </type>
    <type name="VkSwapchainCreateInfoKHR" summary="Structure specifying parameters of a newly created swapchain object.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use, and must: be zero.</member>
        <member name="surface">pname:surface is the surface that the swapchain will present images to.</member>
        <member name="minImageCount">pname:minImageCount is the minimum number of presentable images that the application needs. The platform will either create the swapchain with at least that many images, or will fail to create the swapchain.</member>
        <member name="imageFormat">pname:imageFormat is a slink:VkFormat that is valid for swapchains on the specified surface.</member>
        <member name="imageColorSpace">pname:imageColorSpace is a slink:VkColorSpaceKHR that is valid for swapchains on the specified surface.</member>
        <member name="imageExtent">pname:imageExtent is the size (in pixels) of the swapchain. Behavior is platform-dependent when the image extent does not match the surface's pname:currentExtent as returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR.</member>
        <member name="imageArrayLayers">pname:imageArrayLayers is the number of views in a multiview/stereo surface. For non-stereoscopic-3D applications, this value is 1.</member>
        <member name="imageUsage">pname:imageUsage is a bitmask of elink:VkImageUsageFlagBits, indicating how the application will use the swapchain's presentable images.</member>
        <member name="imageSharingMode">pname:imageSharingMode is the sharing mode used for the images of the swapchain.</member>
        <member name="queueFamilyIndexCount">pname:queueFamilyIndexCount is the number of queue families having access to the images of the swapchain in case pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT.</member>
        <member name="pQueueFamilyIndices">pname:pQueueFamilyIndices is an array of queue family indices having access to the images of the swapchain in case pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT.</member>
        <member name="preTransform">pname:preTransform is a bitmask of elink:VkSurfaceTransformFlagBitsKHR, describing the transform, relative to the presentation engine's natural orientation, applied to the image content prior to presentation. If it does not match the pname:currentTransform value returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR, the presentation engine will transform the image content as part of the presentation operation.</member>
        <member name="compositeAlpha">pname:compositeAlpha is a bitmask of elink:VkCompositeAlphaFlagBitsKHR, indicating the alpha compositing mode to use when this surface is composited together with other surfaces on certain window systems.</member>
        <member name="presentMode">pname:presentMode is the presentation mode the swapchain will use. A swapchain's present mode determines how incoming present requests will be processed and queued internally.</member>
        <member name="clipped">pname:clipped indicates whether the Vulkan implementation is allowed to discard rendering operations that affect regions of the surface which aren't visible.</member>
        <member name="VK_TRUE">* If set to ename:VK_TRUE, the presentable images associated with the swapchain may: not own all of their pixels. Pixels in the presentable images that correspond to regions of the target surface obscured by another window on the desktop or subject to some other clipping mechanism will have undefined content when read back. Pixel shaders may: not execute for these pixels, and thus any side affects they would have had will not occur.</member>
        <member name="VK_FALSE">* If set to ename:VK_FALSE, presentable images associated with the swapchain will own all the pixels they contain. Setting this value to ename:VK_TRUE does not guarantee any clipping will occur, but allows more optimal presentation methods to be used on some platforms.</member>
      </members>
    </type>
    <type name="VkSystemAllocationScope" summary="Allocation scope.">
      <specification />
      <members>
        <member name="VK_SYSTEM_ALLOCATION_SCOPE_COMMAND">ename:VK_SYSTEM_ALLOCATION_SCOPE_COMMAND - The allocation is scoped to the duration of the Vulkan command.</member>
        <member name="VK_SYSTEM_ALLOCATION_SCOPE_OBJECT">ename:VK_SYSTEM_ALLOCATION_SCOPE_OBJECT - The allocation is scoped to the lifetime of the Vulkan object that is being created or used.</member>
        <member name="VK_SYSTEM_ALLOCATION_SCOPE_CACHE">ename:VK_SYSTEM_ALLOCATION_SCOPE_CACHE - The allocation is scoped to the lifetime of a sname:VkPipelineCache object.</member>
        <member name="VK_SYSTEM_ALLOCATION_SCOPE_DEVICE">ename:VK_SYSTEM_ALLOCATION_SCOPE_DEVICE - The allocation is scoped to the lifetime of the Vulkan device.</member>
        <member name="VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE">ename:VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - The allocation is scoped to the lifetime of the Vulkan instance.</member>
      </members>
    </type>
    <type name="VkVertexInputAttributeDescription" summary="Structure specifying vertex input attribute description.">
      <specification />
      <members>
        <member name="location">pname:location is the shader binding location number for this attribute.</member>
        <member name="binding">pname:binding is the binding number which this attribute takes its data from.</member>
        <member name="format">pname:format is the size and type of the vertex attribute data.</member>
        <member name="offset">pname:offset is a byte offset of this attribute relative to the start of an element in the vertex input binding.</member>
      </members>
    </type>
    <type name="VkVertexInputBindingDescription" summary="Structure specifying vertex input binding description.">
      <specification />
      <members>
        <member name="binding">pname:binding is the binding number that this structure describes.</member>
        <member name="stride">pname:stride is the distance in bytes between two consecutive elements within the buffer.</member>
        <member name="inputRate">pname:inputRate specifies whether vertex attribute addressing is a function of the vertex index or of the instance index. Possible values include: + --</member>
      </members>
    </type>
    <type name="VkVertexInputRate" summary="Specify rate at which vertex attributes are pulled from buffers.">
      <specification />
      <members />
    </type>
    <type name="VkViewport" summary="Structure specifying a viewport.">
      <specification />
      <members>
        <member name="x">pname:x and pname:y are the viewport's upper left corner latexmath:[$(x,y)$].</member>
        <member name="width">pname:width and pname:height are the viewport's width and height, respectively.</member>
        <member name="minDepth">pname:minDepth and pname:maxDepth are the depth range for the viewport. It is valid for pname:minDepth to be greater than or equal to pname:maxDepth.</member>
      </members>
    </type>
    <type name="VkWaylandSurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created Wayland surface object.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="display">pname:display and pname:surface are pointers to the Wayland code:wl_display and code:wl_surface to associate the surface with.</member>
      </members>
    </type>
    <type name="VkWin32KeyedMutexAcquireReleaseInfoNV" summary="Use Windows keyex mutex mechanism to synchronize work.">
      <specification>
        <para>When submitting work that operates on memory imported from a Direct3D 11 resource to a queue, the keyed mutex mechanism may: be used in addition to Vulkan semaphores to synchronize the work.  Keyed mutexes are a property of a properly created shareable Direct3D 11 resource. They can: only be used if the imported resource was created with the etext:D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX flag.</para>
        <para>To acquire keyed mutexes before submitted work and/or release them after, add a slink:VkWin32KeyedMutexAcquireReleaseInfoNV structure to the pname:pNext chain of the slink:VkSubmitInfo structure.</para>
      </specification>
      <members />
    </type>
    <type name="VkWin32SurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created Win32 surface object.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="hinstance">pname:hinstance and pname:hwnd are the Win32 code:HINSTANCE and code:HWND for the window to associate the surface with.</member>
      </members>
    </type>
    <type name="VkWriteDescriptorSet" summary="Structure specifying the parameters of a descriptor set write operation.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="dstSet">pname:dstSet is the destination descriptor set to update.</member>
        <member name="dstBinding">pname:dstBinding is the descriptor binding within that set.</member>
        <member name="dstArrayElement">pname:dstArrayElement is the starting element in that array.</member>
        <member name="descriptorCount">pname:descriptorCount is the number of descriptors to update (the number of elements in pname:pImageInfo, pname:pBufferInfo, or pname:pTexelBufferView).</member>
        <member name="descriptorType">pname:descriptorType is a elink:VkDescriptorType specifying the type of each descriptor in pname:pImageInfo, pname:pBufferInfo, or pname:pTexelBufferView, as described below. It must: be the same type as that specified in sname:VkDescriptorSetLayoutBinding for pname:dstSet at pname:dstBinding. The type of the descriptor also controls which array the descriptors are taken from.</member>
        <member name="pImageInfo">pname:pImageInfo points to an array of slink:VkDescriptorImageInfo structures or is ignored, as described below.</member>
        <member name="pBufferInfo">pname:pBufferInfo points to an array of slink:VkDescriptorBufferInfo structures or is ignored, as described below.</member>
        <member name="pTexelBufferView">pname:pTexelBufferView points to an array of slink:VkBufferView handles as described in the &lt;&lt;resources-buffer-views,Buffer Views&gt;&gt; section or is ignored, as described below.</member>
      </members>
    </type>
    <type name="VkXcbSurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created Xcb surface object.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="connection">pname:connection is a pointer to an sname:xcb_connection_t to the X server.</member>
        <member name="window">pname:window is the sname:xcb_window_t for the X11 window to associate the surface with.</member>
      </members>
    </type>
    <type name="VkXlibSurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created Xlib surface object.">
      <specification />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="dpy">pname:dpy is a pointer to an Xlib Display connection to the X server.</member>
        <member name="window">pname:window is an Xlib Window to associate the surface with.</member>
      </members>
    </type>
  </types>
  <commands>
    <command name="vkAcquireNextImageKHR" summary="Retrieve the index of the next available presentable image." />
    <command name="vkAllocateCommandBuffers" summary="Allocate command buffers from an existing command pool." />
    <command name="vkAllocateDescriptorSets" summary="Allocate one or more descriptor sets." />
    <command name="vkAllocateMemory" summary="Allocate GPU memory." />
    <command name="vkBeginCommandBuffer" summary="Start recording a command buffer." />
    <command name="vkBindBufferMemory" summary="Bind device memory to a buffer object." />
    <command name="vkBindImageMemory" summary="Bind device memory to an image object." />
    <command name="vkCmdBeginQuery" summary="Begin a query." />
    <command name="vkCmdBeginRenderPass" summary="Begin a new render pass." />
    <command name="vkCmdBindDescriptorSets" summary="Binds descriptor sets to a command buffer." />
    <command name="vkCmdBindIndexBuffer" summary="Bind an index buffer to a command buffer." />
    <command name="vkCmdBindPipeline" summary="Bind a pipeline object to a command buffer." />
    <command name="vkCmdBindVertexBuffers" summary="Bind vertex buffers to a command buffer." />
    <command name="vkCmdBlitImage" summary="Copy regions of an image, potentially performing format conversion,." />
    <command name="vkCmdClearAttachments" summary="Clear regions within currently bound framebuffer attachments." />
    <command name="vkCmdClearColorImage" summary="Clear regions of a color image." />
    <command name="vkCmdClearDepthStencilImage" summary="Fill regions of a combined depth-stencil image." />
    <command name="vkCmdCopyBuffer" summary="Copy data between buffer regions." />
    <command name="vkCmdCopyBufferToImage" summary="Copy data from a buffer into an image." />
    <command name="vkCmdCopyImage" summary="Copy data between images." />
    <command name="vkCmdCopyImageToBuffer" summary="Copy image data into a buffer." />
    <command name="vkCmdCopyQueryPoolResults" summary="Copy the results of queries in a query pool to a buffer object." />
    <command name="vkCmdDispatch" summary="Dispatch compute work items." />
    <command name="vkCmdDispatchIndirect" summary="Dispatch compute work items using indirect parameters." />
    <command name="vkCmdDraw" summary="Draw primitives." />
    <command name="vkCmdDrawIndexed" summary="Issue an indexed draw into a command buffer." />
    <command name="vkCmdDrawIndexedIndirect" summary="Perform an indexed indirect draw." />
    <command name="vkCmdDrawIndexedIndirectCountAMD" summary="Perform an indexed indirect draw with the draw count sourced from a buffer." />
    <command name="vkCmdDrawIndirect" summary="Issue an indirect draw into a command buffer." />
    <command name="vkCmdDrawIndirectCountAMD" summary="Perform an indirect draw with the draw count sourced from a buffer." />
    <command name="vkCmdEndQuery" summary="Ends a query." />
    <command name="vkCmdEndRenderPass" summary="End the current render pass." />
    <command name="vkCmdExecuteCommands" summary="Execute a secondary command buffer from a primary command buffer." />
    <command name="vkCmdFillBuffer" summary="Fill a region of a buffer with a fixed value." />
    <command name="vkCmdNextSubpass" summary="Transition to the next subpass of a render pass." />
    <command name="vkCmdPipelineBarrier" summary="Insert a set of execution and memory barriers." />
    <command name="vkCmdPushConstants" summary="Update the values of push constants." />
    <command name="vkCmdResetEvent" summary="Reset an event object to non-signaled state." />
    <command name="vkCmdResetQueryPool" summary="Reset queries in a query pool." />
    <command name="vkCmdResolveImage" summary="Resolve regions of an image." />
    <command name="vkCmdSetBlendConstants" summary="Set the values of blend constants." />
    <command name="vkCmdSetDepthBias" summary="Set the depth bias dynamic state." />
    <command name="vkCmdSetDepthBounds" summary="Set the depth bounds test values for a command buffer." />
    <command name="vkCmdSetEvent" summary="Set an event object to signaled state." />
    <command name="vkCmdSetLineWidth" summary="Set the dynamic line width state." />
    <command name="vkCmdSetScissor" summary="Set the dynamic scissor rectangles on a command buffer." />
    <command name="vkCmdSetStencilCompareMask" summary="Set the stencil compare mask dynamic state." />
    <command name="vkCmdSetStencilReference" summary="Set the stencil reference dynamic state." />
    <command name="vkCmdSetStencilWriteMask" summary="Set the stencil write mask dynamic state." />
    <command name="vkCmdSetViewport" summary="Set the viewport on a command buffer." />
    <command name="vkCmdUpdateBuffer" summary="Update a buffer's contents from host memory." />
    <command name="vkCmdWaitEvents" summary="Wait for one or more events and insert a set of memory." />
    <command name="vkCmdWriteTimestamp" summary="Write a device timestamp into a query object." />
    <command name="vkCreateAndroidSurfaceKHR" summary="Create a slink:VkSurfaceKHR object for an Android native window." />
    <command name="vkCreateBuffer" summary="Create a new buffer object." />
    <command name="vkCreateBufferView" summary="Create a new buffer view object." />
    <command name="vkCreateCommandPool" summary="Create a new command pool object." />
    <command name="vkCreateComputePipelines" summary="Creates a new compute pipeline object." />
    <command name="vkCreateDescriptorPool" summary="Creates a descriptor pool object." />
    <command name="vkCreateDescriptorSetLayout" summary="Create a new descriptor set layout." />
    <command name="vkCreateDevice" summary="Create a new device instance." />
    <command name="vkCreateDisplayModeKHR" summary="Create a display mode." />
    <command name="vkCreateDisplayPlaneSurfaceKHR" summary="Create a slink:VkSurfaceKHR structure representing a display plane and mode." />
    <command name="vkCreateEvent" summary="Create a new event object." />
    <command name="vkCreateFence" summary="Create a new fence object." />
    <command name="vkCreateFramebuffer" summary="Create a new framebuffer object." />
    <command name="vkCreateGraphicsPipelines" summary="Create graphics pipelines." />
    <command name="vkCreateImage" summary="Create a new image object." />
    <command name="vkCreateImageView" summary="Create an image view from an existing image." />
    <command name="vkCreateInstance" summary="Create a new Vulkan instance." />
    <command name="vkCreateMirSurfaceKHR" summary="Create a slink:VkSurfaceKHR object for a Mir window." />
    <command name="vkCreatePipelineCache" summary="Creates a new pipeline cache." />
    <command name="vkCreatePipelineLayout" summary="Creates a new pipeline layout object." />
    <command name="vkCreateQueryPool" summary="Create a new query pool object." />
    <command name="vkCreateRenderPass" summary="Create a new render pass object." />
    <command name="vkCreateSampler" summary="Create a new sampler object." />
    <command name="vkCreateSemaphore" summary="Create a new queue semaphore object." />
    <command name="vkCreateShaderModule" summary="Creates a new shader module object." />
    <command name="vkCreateSharedSwapchainsKHR" summary="Create multiple swapchains that share presentable images." />
    <command name="vkCreateSwapchainKHR" summary="Create a swapchain." />
    <command name="vkCreateWaylandSurfaceKHR" summary="Create a slink:VkSurfaceKHR object for a Wayland window." />
    <command name="vkCreateWin32SurfaceKHR" summary="Create a slink:VkSurfaceKHR object for an Win32 native window." />
    <command name="vkCreateXcbSurfaceKHR" summary="Create a slink:VkSurfaceKHR object for a X11 window, using the XCB client-side library." />
    <command name="vkCreateXlibSurfaceKHR" summary="Create a slink:VkSurfaceKHR object for an X11 window, using the Xlib client-side library." />
    <command name="vkDestroyBuffer" summary="Destroy a buffer object." />
    <command name="vkDestroyBufferView" summary="Destroy a buffer view object." />
    <command name="vkDestroyCommandPool" summary="Destroy a command pool object." />
    <command name="vkDestroyDescriptorPool" summary="Destroy a descriptor pool object." />
    <command name="vkDestroyDescriptorSetLayout" summary="Destroy a descriptor set layout object." />
    <command name="vkDestroyDevice" summary="Destroy a logical device." />
    <command name="vkDestroyEvent" summary="Destroy an event object." />
    <command name="vkDestroyFence" summary="Destroy a fence object." />
    <command name="vkDestroyFramebuffer" summary="Destroy a framebuffer object." />
    <command name="vkDestroyImage" summary="Destroy an image object." />
    <command name="vkDestroyImageView" summary="Destroy an image view object." />
    <command name="vkDestroyInstance" summary="Destroy an instance of Vulkan." />
    <command name="vkDestroyPipeline" summary="Destroy a pipeline object." />
    <command name="vkDestroyPipelineCache" summary="Destroy a pipeline cache object." />
    <command name="vkDestroyPipelineLayout" summary="Destroy a pipeline layout object." />
    <command name="vkDestroyQueryPool" summary="Destroy a query pool object." />
    <command name="vkDestroyRenderPass" summary="Destroy a render pass object." />
    <command name="vkDestroySampler" summary="Destroy a sampler object." />
    <command name="vkDestroySemaphore" summary="Destroy a semaphore object." />
    <command name="vkDestroyShaderModule" summary="Destroy a shader module module." />
    <command name="vkDestroySurfaceKHR" summary="Destroy a VkSurfaceKHR object." />
    <command name="vkDestroySwapchainKHR" summary="Destroy a swapchain object." />
    <command name="vkDeviceWaitIdle" summary="Wait for a device to become idle." />
    <command name="vkEndCommandBuffer" summary="Finish recording a command buffer." />
    <command name="vkEnumerateDeviceExtensionProperties" summary="Returns properties of available physical device extensions." />
    <command name="vkEnumerateDeviceLayerProperties" summary="Returns properties of available physical device layers." />
    <command name="vkEnumerateInstanceExtensionProperties" summary="Returns up to requested number of global extension properties." />
    <command name="vkEnumerateInstanceLayerProperties" summary="Returns up to requested number of global layer properties." />
    <command name="vkEnumeratePhysicalDevices" summary="Enumerates the physical devices accessible to a Vulkan instance." />
    <command name="vkFlushMappedMemoryRanges" summary="Flush mapped memory ranges." />
    <command name="vkFreeCommandBuffers" summary="Free command buffers." />
    <command name="vkFreeDescriptorSets" summary="Free one or more descriptor sets." />
    <command name="vkFreeMemory" summary="Free GPU memory." />
    <command name="vkGetBufferMemoryRequirements" summary="Returns the memory requirements for specified Vulkan object." />
    <command name="vkGetDeviceMemoryCommitment" summary="Query the current commitment for a VkDeviceMemory." />
    <command name="vkGetDeviceProcAddr" summary="Return a function pointer for a command." />
    <command name="vkGetDeviceQueue" summary="Get a queue handle from a device." />
    <command name="vkGetDisplayModePropertiesKHR" summary="Query the set of mode properties supported by the display." />
    <command name="vkGetDisplayPlaneCapabilitiesKHR" summary="Query capabilities of a mode and plane combination." />
    <command name="vkGetDisplayPlaneSupportedDisplaysKHR" summary="Query the list of displays a plane supports." />
    <command name="vkGetEventStatus" summary="Retrieve the status of an event object." />
    <command name="vkGetFenceStatus" summary="Return the status of a fence." />
    <command name="vkGetImageMemoryRequirements" summary="Returns the memory requirements for specified Vulkan object." />
    <command name="vkGetImageSparseMemoryRequirements" summary="Query the memory requirements for a sparse image." />
    <command name="vkGetImageSubresourceLayout" summary="Retrieve information about an image subresource." />
    <command name="vkGetInstanceProcAddr" summary="Return a function pointer for a command." />
    <command name="vkGetMemoryWin32HandleNV" summary="Retrieve Win32 handle to a device memory object." />
    <command name="vkGetPhysicalDeviceDisplayPlanePropertiesKHR" summary="Query the plane properties." />
    <command name="vkGetPhysicalDeviceDisplayPropertiesKHR" summary="Query information about the available displays." />
    <command name="vkGetPhysicalDeviceExternalImageFormatPropertiesNV" summary="Determine image capabilities compatible with external memory handle types." />
    <command name="vkGetPhysicalDeviceFeatures" summary="Reports capabilities of a physical device." />
    <command name="vkGetPhysicalDeviceFormatProperties" summary="Lists physical device's format capabilities." />
    <command name="vkGetPhysicalDeviceImageFormatProperties" summary="Lists physical device's image format capabilities." />
    <command name="vkGetPhysicalDeviceMemoryProperties" summary="Reports memory information for the specified physical device." />
    <command name="vkGetPhysicalDeviceMirPresentationSupportKHR" summary="Query physical device for presentation to Mir." />
    <command name="vkGetPhysicalDeviceProperties" summary="Returns properties of a physical device." />
    <command name="vkGetPhysicalDeviceQueueFamilyProperties" summary="Reports properties of the queues of the specified physical device." />
    <command name="vkGetPhysicalDeviceSparseImageFormatProperties" summary="Retrieve properties of an image format applied to sparse images." />
    <command name="vkGetPhysicalDeviceSurfaceCapabilitiesKHR" summary="Query surface capabilities." />
    <command name="vkGetPhysicalDeviceSurfaceFormatsKHR" summary="Query color formats supported by surface." />
    <command name="vkGetPhysicalDeviceSurfacePresentModesKHR" summary="Query supported presentation modes." />
    <command name="vkGetPhysicalDeviceSurfaceSupportKHR" summary="Query if presentation is supported." />
    <command name="vkGetPhysicalDeviceWaylandPresentationSupportKHR" summary="Query physical device for presentation to Wayland." />
    <command name="vkGetPhysicalDeviceWin32PresentationSupportKHR" summary="Query queue family support for presentation on a Win32 display." />
    <command name="vkGetPhysicalDeviceXcbPresentationSupportKHR" summary="Query physical device for presentation to X11 server using XCB." />
    <command name="vkGetPhysicalDeviceXlibPresentationSupportKHR" summary="Query physical device for presentation to X11 server using Xlib." />
    <command name="vkGetPipelineCacheData" summary="Get the data store from a pipeline cache." />
    <command name="vkGetQueryPoolResults" summary="Copy results of queries in a query pool to a host memory region." />
    <command name="vkGetRenderAreaGranularity" summary="Returns the granularity for optimal render area." />
    <command name="vkGetSwapchainImagesKHR" summary="Obtain the array of presentable images associated with a swapchain." />
    <command name="vkInvalidateMappedMemoryRanges" summary="Invalidate ranges of mapped memory objects." />
    <command name="vkMapMemory" summary="Map a memory object into application address space." />
    <command name="vkMergePipelineCaches" summary="Combine the data stores of pipeline caches." />
    <command name="vkQueueBindSparse" summary="Bind device memory to a sparse resource object." />
    <command name="vkQueuePresentKHR" summary="Queue an image for presentation." />
    <command name="vkQueueSubmit" summary="Submits a sequence of semaphores or command buffers to a queue." />
    <command name="vkQueueWaitIdle" summary="Wait for a queue to become idle." />
    <command name="vkResetCommandBuffer" summary="Reset a command buffer." />
    <command name="vkResetCommandPool" summary="Reset a command pool." />
    <command name="vkResetDescriptorPool" summary="Resets a descriptor pool object." />
    <command name="vkResetEvent" summary="Reset an event to non-signaled state." />
    <command name="vkResetFences" summary="Resets one or more fence objects." />
    <command name="vkSetEvent" summary="Set an event to signaled state." />
    <command name="vkUnmapMemory" summary="Unmap a previously mapped memory object." />
    <command name="vkUpdateDescriptorSets" summary="Update the contents of a descriptor set object." />
    <command name="vkWaitForFences" summary="Wait for one or more fences to become signaled." />
  </commands>
</docs>