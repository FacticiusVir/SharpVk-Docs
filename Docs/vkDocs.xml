<?xml version="1.0" encoding="utf-8"?>
<docs>
  <types>
    <type name="PFN_vkAllocationFunction" summary="Application-defined memory allocation function.">
      <specification />
      <description>
        <para>[[vkAllocationFunction_return_rules]] If pname:pfnAllocation is unable to allocate the requested memory, it must: return `NULL`. If the allocation was successful, it must: return a valid pointer to memory allocation containing at least pname:size bytes, and with the pointer value being a multiple of pname:alignment.</para>
        <para>[NOTE] .Note ==== Correct Vulkan operation cannot: be assumed if the application does not follow these rules.</para>
        <para>For example, pname:pfnAllocation (or pname:pfnReallocation) could cause termination of running Vulkan instance(s) on a failed allocation for debugging purposes, either directly or indirectly. In these circumstances, it cannot: be assumed that any part of any affected VkInstance objects are going to operate correctly (even flink:vkDestroyInstance), and the application must: ensure it cleans up properly via other means (e.g. process termination). ====</para>
        <para>If pname:pfnAllocation returns `NULL`, and if the implementation is unable to continue correct processing of the current command without the requested allocation, it must: treat this as a run-time error, and generate ename:VK_ERROR_OUT_OF_HOST_MEMORY at the appropriate time for the command in which the condition was detected, as described in &lt;&lt;fundamentals-errorcodes, Return Codes&gt;&gt;.</para>
        <para>If the implementation is able to continue correct processing of the current command without the requested allocation, then it may: do so, and must: not generate ename:VK_ERROR_OUT_OF_HOST_MEMORY as a result of this failed allocation.</para>
      </description>
      <members>
        <member name="pUserData">pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.</member>
        <member name="size">pname:size is the size in bytes of the requested allocation.</member>
        <member name="alignment">pname:alignment is the requested alignment of the allocation in bytes and must: be a power of two.</member>
        <member name="allocationScope">pname:allocationScope is a elink:VkSystemAllocationScope value specifying the allocation scope of the lifetime of the allocation, as described &lt;&lt;memory-host-allocation-scope,here&gt;&gt;.</member>
      </members>
    </type>
    <type name="PFN_vkDebugReportCallbackEXT" summary="Application-defined debug report callback function.">
      <specification />
      <description>
        <para>The callback returns a basetype:VkBool32 that indicates to the calling layer if the Vulkan call should: be aborted or not. Applications should: always return ename:VK_FALSE so that they see the same behavior with and without validation layers enabled.</para>
        <para>If the application returns ename:VK_TRUE from its callback and the Vulkan call being aborted returns a elink:VkResult, the layer will return ename:VK_ERROR_VALIDATION_FAILED_EXT.</para>
        <para>[NOTE] .Note ==== The primary expected use of ename:VK_ERROR_VALIDATION_FAILED_EXT is for validation layer testing. It is not expected that an application would see this error code during normal use of the validation layers. ====</para>
      </description>
      <members>
        <member name="flags">pname:flags indicates the ename:VkDebugReportFlagBitsEXT that triggered this callback.</member>
        <member name="objType">pname:objType is a elink:VkDebugReportObjectTypeEXT specifying the type of object being used or created at the time the event was triggered.</member>
        <member name="object">pname:object gives the object where the issue was detected. pname:object may be ename:VK_NULL_OBJECT if there is no object associated with the event.</member>
        <member name="location">pname:location is a component (layer, driver, loader) defined value that indicates the _location_ of the trigger. This is an optional value.</member>
        <member name="messageCode">pname:messageCode is a layer-defined value indicating what test triggered this callback.</member>
        <member name="pLayerPrefix">pname:pLayerPrefix is the abbreviation of the component making the callback.</member>
        <member name="pMessage">pname:pMessage is a null-terminated string detailing the trigger conditions.</member>
        <member name="pUserData">pname:pUserData is the user data given when the DebugReportCallback was created.</member>
      </members>
    </type>
    <type name="PFN_vkFreeFunction" summary="Application-defined memory free function.">
      <specification />
      <description>
        <para>pname:pMemory may: be `NULL`, which the callback must: handle safely. If pname:pMemory is non-`NULL`, it must: be a pointer previously allocated by pname:pfnAllocation or pname:pfnReallocation. The application should: free this memory.</para>
      </description>
      <members>
        <member name="pUserData">pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.</member>
        <member name="pMemory">pname:pMemory is the allocation to be freed.</member>
      </members>
    </type>
    <type name="PFN_vkInternalAllocationNotification" summary="Application-defined memory allocation notification function.">
      <specification />
      <description>
        <para>This is a purely informational callback.</para>
      </description>
      <members>
        <member name="pUserData">pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.</member>
        <member name="size">pname:size is the requested size of an allocation.</member>
        <member name="allocationType">pname:allocationType is the requested type of an allocation.</member>
        <member name="allocationScope">pname:allocationScope is a elink:VkSystemAllocationScope value specifying the allocation scope of the lifetime of the allocation, as described &lt;&lt;memory-host-allocation-scope,here&gt;&gt;.</member>
      </members>
    </type>
    <type name="PFN_vkInternalFreeNotification" summary="Application-defined memory free notification function.">
      <specification />
      <description />
      <members>
        <member name="pUserData">pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.</member>
        <member name="size">pname:size is the requested size of an allocation.</member>
        <member name="allocationType">pname:allocationType is the requested type of an allocation.</member>
        <member name="allocationScope">pname:allocationScope is a elink:VkSystemAllocationScope value specifying the allocation scope of the lifetime of the allocation, as described &lt;&lt;memory-host-allocation-scope,here&gt;&gt;.</member>
      </members>
    </type>
    <type name="PFN_vkReallocationFunction" summary="Application-defined memory reallocation function.">
      <specification />
      <description>
        <para>pname:pfnReallocation must: return an allocation with enough space for pname:size bytes, and the contents of the original allocation from bytes zero to [eq]#min(original size, new size) - 1# must: be preserved in the returned allocation. If pname:size is larger than the old size, the contents of the additional space are undefined. If satisfying these requirements involves creating a new allocation, then the old allocation should: be freed.</para>
        <para>If pname:pOriginal is `NULL`, then pname:pfnReallocation must: behave equivalently to a call to tlink:PFN_vkAllocationFunction with the same parameter values (without pname:pOriginal).</para>
        <para>If pname:size is zero, then pname:pfnReallocation must: behave equivalently to a call to tlink:PFN_vkFreeFunction with the same pname:pUserData parameter value, and pname:pMemory equal to pname:pOriginal.</para>
        <para>If pname:pOriginal is non-`NULL`, the implementation must: ensure that pname:alignment is equal to the pname:alignment used to originally allocate pname:pOriginal.</para>
        <para>If this function fails and pname:pOriginal is non-`NULL` the application must: not free the old allocation.</para>
        <para>pname:pfnReallocation must: follow the same &lt;&lt;vkAllocationFunction_return_rules, rules for return values as tname:PFN_vkAllocationFunction&gt;&gt;.</para>
      </description>
      <members>
        <member name="pUserData">pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.</member>
        <member name="pOriginal">pname:pOriginal must: be either `NULL` or a pointer previously returned by pname:pfnReallocation or pname:pfnAllocation of the same allocator.</member>
        <member name="size">pname:size is the size in bytes of the requested allocation.</member>
        <member name="alignment">pname:alignment is the requested alignment of the allocation in bytes and must: be a power of two.</member>
        <member name="allocationScope">pname:allocationScope is a elink:VkSystemAllocationScope value specifying the allocation scope of the lifetime of the allocation, as described &lt;&lt;memory-host-allocation-scope,here&gt;&gt;.</member>
      </members>
    </type>
    <type name="PFN_vkVoidFunction" summary="Dummy function pointer type returned by queries.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkAccessFlagBits" summary="Bitmask specifying classes of memory access the will participate in a memory barrier dependency.">
      <specification />
      <description>
        <para>Color attachment reads and writes are automatically (without memory or execution dependencies) coherent and ordered against themselves and each other for a given sample within a subpass of a render pass instance, executing in &lt;&lt;primrast-order,rasterization order&gt;&gt;. Similarly, depth/stencil attachment reads and writes are automatically coherent and ordered against themselves and each other in the same circumstances.</para>
        <para>Shader reads and/or writes through two variables (in the same or different shader invocations) decorated with code:Coherent and which use the same image view or buffer view are automatically coherent with each other, but require execution dependencies if a specific order is desired. Similarly, shader atomic operations are coherent with each other and with code:Coherent variables. Non-code:Coherent shader memory accesses require memory dependencies for writes to be available and reads to be visible.</para>
        <para>Certain memory access types are only supported on queues that support a particular set of operations. The following table lists, for each access flag, which queue capability flag must: be supported by the queue. When multiple flags are enumerated in the second column of the table it means that the access type is supported on the queue if it supports any of the listed capability flags. For further details on queue capabilities see &lt;&lt;devsandqueues-physical-device-enumeration,Physical Device Enumeration&gt;&gt; and &lt;&lt;devsandqueues-queues,Queues&gt;&gt;.</para>
        <para>.Supported access flags [width="100%",cols="67%,33%",options="header",align="center"] |==== |Access flag                                                  | Required queue capability flag |ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT                    | ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT |ename:VK_ACCESS_INDEX_READ_BIT                               | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT                    | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_UNIFORM_READ_BIT                             | ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT |ename:VK_ACCESS_INPUT_ATTACHMENT_READ_BIT                    | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_SHADER_READ_BIT                              | ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT |ename:VK_ACCESS_SHADER_WRITE_BIT                             | ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT |ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT                    | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT                   | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT            | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT           | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_TRANSFER_READ_BIT                            | ename:VK_QUEUE_GRAPHICS_BIT, ename:VK_QUEUE_COMPUTE_BIT or ename:VK_QUEUE_TRANSFER_BIT |ename:VK_ACCESS_TRANSFER_WRITE_BIT                           | ename:VK_QUEUE_GRAPHICS_BIT, ename:VK_QUEUE_COMPUTE_BIT or ename:VK_QUEUE_TRANSFER_BIT |ename:VK_ACCESS_HOST_READ_BIT                                | None |ename:VK_ACCESS_HOST_WRITE_BIT                               | None |ename:VK_ACCESS_MEMORY_READ_BIT                              | None |ename:VK_ACCESS_MEMORY_WRITE_BIT                             | None |====</para>
      </description>
      <members>
        <member name="VK_ACCESS_INDIRECT_COMMAND_READ_BIT">ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT indicates that the access is an indirect command structure read as part of an indirect drawing command.</member>
        <member name="VK_ACCESS_INDEX_READ_BIT">ename:VK_ACCESS_INDEX_READ_BIT indicates that the access is an index buffer read.</member>
        <member name="VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT">ename:VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT indicates that the access is a read via the vertex input bindings.</member>
        <member name="VK_ACCESS_UNIFORM_READ_BIT">ename:VK_ACCESS_UNIFORM_READ_BIT indicates that the access is a read via a uniform buffer or dynamic uniform buffer descriptor.</member>
        <member name="VK_ACCESS_INPUT_ATTACHMENT_READ_BIT">ename:VK_ACCESS_INPUT_ATTACHMENT_READ_BIT indicates that the access is a read via an input attachment descriptor.</member>
        <member name="VK_ACCESS_SHADER_READ_BIT">ename:VK_ACCESS_SHADER_READ_BIT indicates that the access is a read from a shader via any other descriptor type.</member>
        <member name="VK_ACCESS_SHADER_WRITE_BIT">ename:VK_ACCESS_SHADER_WRITE_BIT indicates that the access is a write or atomic from a shader via the same descriptor types as in ename:VK_ACCESS_SHADER_READ_BIT.</member>
        <member name="VK_ACCESS_COLOR_ATTACHMENT_READ_BIT">ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT indicates that the access is a read via a color attachment.</member>
        <member name="VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT">ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT indicates that the access is a write via a color or resolve attachment.</member>
        <member name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT">ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT indicates that the access is a read via a depth/stencil attachment.</member>
        <member name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT">ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT indicates that the access is a write via a depth/stencil attachment.</member>
        <member name="VK_ACCESS_TRANSFER_READ_BIT">ename:VK_ACCESS_TRANSFER_READ_BIT indicates that the access is a read from a transfer (copy, blit, resolve, etc.) operation. For the complete set of transfer operations, see &lt;&lt;synchronization-transfer,ename:VK_PIPELINE_STAGE_TRANSFER_BIT&gt;&gt;.</member>
        <member name="VK_ACCESS_TRANSFER_WRITE_BIT">ename:VK_ACCESS_TRANSFER_WRITE_BIT indicates that the access is a write from a transfer (copy, blit, resolve, etc.) operation. For the complete set of transfer operations, see &lt;&lt;synchronization-transfer,ename:VK_PIPELINE_STAGE_TRANSFER_BIT&gt;&gt;.</member>
        <member name="VK_ACCESS_HOST_READ_BIT">ename:VK_ACCESS_HOST_READ_BIT indicates that the access is a read via the host.</member>
        <member name="VK_ACCESS_HOST_WRITE_BIT">ename:VK_ACCESS_HOST_WRITE_BIT indicates that the access is a write via the host.</member>
        <member name="VK_ACCESS_MEMORY_READ_BIT">ename:VK_ACCESS_MEMORY_READ_BIT indicates that the access is a read via a non-specific unit attached to the memory. This unit may: be external to the Vulkan device or otherwise not part of the core Vulkan pipeline. When included in pname:dstAccessMask, all writes using access types in pname:srcAccessMask performed by pipeline stages in pname:srcStageMask must: be visible in memory.</member>
        <member name="VK_ACCESS_MEMORY_WRITE_BIT">ename:VK_ACCESS_MEMORY_WRITE_BIT indicates that the access is a write via a non-specific unit attached to the memory. This unit may: be external to the Vulkan device or otherwise not part of the core Vulkan pipeline. When included in pname:srcAccessMask, all access types in pname:dstAccessMask from pipeline stages in pname:dstStageMask will observe the side effects of commands that executed before the barrier. When included in pname:dstAccessMask all writes using access types in pname:srcAccessMask performed by pipeline stages in pname:srcStageMask must: be visible in memory.</member>
      </members>
    </type>
    <type name="VkAllocationCallbacks" summary="Structure containing callback function pointers for memory allocation.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:pfnAllocation must: be a pointer to a valid user-defined tlink:PFN_vkAllocationFunction * pname:pfnReallocation must: be a pointer to a valid user-defined tlink:PFN_vkReallocationFunction * pname:pfnFree must: be a pointer to a valid user-defined tlink:PFN_vkFreeFunction * If either of pname:pfnInternalAllocation or pname:pfnInternalFree is not `NULL`, both must: be valid callbacks ****</para>
      </description>
      <members>
        <member name="pUserData">pname:pUserData is a value to be interpreted by the implementation of the callbacks. When any of the callbacks in sname:VkAllocationCallbacks are called, the Vulkan implementation will pass this value as the first parameter to the callback. This value can: vary each time an allocator is passed into a command, even when the same object takes an allocator in multiple commands.</member>
        <member name="pfnAllocation">pname:pfnAllocation is a pointer to an application-defined memory allocation function of type tlink:PFN_vkAllocationFunction.</member>
        <member name="pfnReallocation">pname:pfnReallocation is a pointer to an application-defined memory reallocation function of type tlink:PFN_vkReallocationFunction.</member>
        <member name="pfnFree">pname:pfnFree is a pointer to an application-defined memory free function of type tlink:PFN_vkFreeFunction.</member>
        <member name="pfnInternalAllocation">pname:pfnInternalAllocation is a pointer to an application-defined function that is called by the implementation when the implementation makes internal allocations, and it is of type tlink:PFN_vkInternalAllocationNotification.</member>
        <member name="pfnInternalFree">pname:pfnInternalFree is a pointer to an application-defined function that is called by the implementation when the implementation frees internal allocations, and it is of type tlink:PFN_vkInternalFreeNotification.</member>
      </members>
    </type>
    <type name="VkAndroidSurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created Android surface object.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="window">pname:window is a pointer to the code:ANativeWindow to associate the surface with.</member>
      </members>
    </type>
    <type name="VkApplicationInfo" summary="Structure specifying application info.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:apiVersion must: be zero, or otherwise it must: be a version that the implementation supports, or supports an effective substitute for ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="pApplicationName">pname:pApplicationName is a pointer to a null-terminated UTF-8 string containing the name of the application.</member>
        <member name="applicationVersion">pname:applicationVersion is an unsigned integer variable containing the developer-supplied version number of the application.</member>
        <member name="pEngineName">pname:pEngineName is a pointer to a null-terminated UTF-8 string containing the name of the engine (if any) used to create the application.</member>
        <member name="engineVersion">pname:engineVersion is an unsigned integer variable containing the developer-supplied version number of the engine used to create the application.</member>
        <member name="apiVersion">pname:apiVersion is the version of the Vulkan API against which the application expects to run, encoded as described in the &lt;&lt;fundamentals-versionnum,API Version Numbers and Semantics&gt;&gt; section. If pname:apiVersion is 0 the implementation must: ignore it, otherwise if the implementation does not support the requested pname:apiVersion it must: return ename:VK_ERROR_INCOMPATIBLE_DRIVER. The patch version number specified in pname:apiVersion is ignored when creating an instance object. Only the major and minor versions of the instance must: match those requested in pname:apiVersion.</member>
      </members>
    </type>
    <type name="VkAttachmentDescription" summary="Structure specifying an attachment description.">
      <specification />
      <description />
      <members>
        <member name="flags">pname:flags is a bitmask describing additional properties of the attachment. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkAttachmentDescriptionFlagBits" summary="Bitmask specifying additional properties of an attachment.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkAttachmentLoadOp" summary="Specify how contents of an attachment are treated at the beginning of a subpass.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkAttachmentReference" summary="Structure specifying an attachment reference.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:layout must: not be ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED ****</para>
      </description>
      <members>
        <member name="attachment">pname:attachment is the index of the attachment of the render pass, and corresponds to the index of the corresponding element in the pname:pAttachments array of the sname:VkRenderPassCreateInfo structure. If any color or depth/stencil attachments are ename:VK_ATTACHMENT_UNUSED, then no writes occur for those attachments.</member>
        <member name="layout">pname:layout is a elink:VkImageLayout value specifying the layout the attachment uses during the subpass. The implementation will automatically perform layout transitions as needed between subpasses to make each subpass use the requested layouts.</member>
      </members>
    </type>
    <type name="VkAttachmentStoreOp" summary="Specify how contents of an attachment are treated at the end of a subpass.">
      <specification />
      <description>
        <para>If the attachment uses a color format, then pname:loadOp and pname:storeOp are used, and pname:stencilLoadOp and pname:stencilStoreOp are ignored. If the format has depth and/or stencil components, pname:loadOp and pname:storeOp apply only to the depth data, while pname:stencilLoadOp and pname:stencilStoreOp define how the stencil data is handled.</para>
        <para>During a render pass instance, input/color attachments with color formats that have a component size of 8, 16, or 32 bits must: be represented in the attachment's format throughout the instance. Attachments with other floating- or fixed-point color formats, or with depth components may: be represented in a format with a precision higher than the attachment format, but must: be represented with the same range. When such a component is loaded via the pname:loadOp, it will be converted into an implementation-dependent format used by the render pass. Such components must: be converted from the render pass format, to the format of the attachment, before they are stored or resolved at the end of a render pass instance via pname:storeOp. Conversions occur as described in &lt;&lt;fundamentals-numerics,Numeric Representation and Computation&gt;&gt; and &lt;&lt;fundamentals-fixedconv, Fixed-Point Data Conversions&gt;&gt;.</para>
        <para>If pname:flags includes ename:VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT, then the attachment is treated as if it shares physical memory with another attachment in the same render pass. This information limits the ability of the implementation to reorder certain operations (like layout transitions and the pname:loadOp) such that it is not improperly reordered against other uses of the same physical memory via a different attachment. This is described in more detail below.</para>
        <para>.Valid Usage **** * pname:finalLayout must: not be ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED ****</para>
      </description>
      <members />
    </type>
    <type name="VkBindSparseInfo" summary="Structure specifying a sparse binding operation.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="waitSemaphoreCount">pname:waitSemaphoreCount is the number of semaphores upon which to wait before executing the sparse binding operations for the batch.</member>
        <member name="pWaitSemaphores">pname:pWaitSemaphores is a pointer to an array of semaphores upon which to wait on before the sparse binding operations for this batch begin execution. If semaphores to wait on are provided, they define a &lt;&lt;synchronization-semaphores-waiting, semaphore wait operation&gt;&gt;.</member>
        <member name="bufferBindCount">pname:bufferBindCount is the number of sparse buffer bindings to perform in the batch.</member>
        <member name="pBufferBinds">pname:pBufferBinds is a pointer to an array of slink:VkSparseBufferMemoryBindInfo structures.</member>
        <member name="imageOpaqueBindCount">pname:imageOpaqueBindCount is the number of opaque sparse image bindings to perform.</member>
        <member name="pImageOpaqueBinds">pname:pImageOpaqueBinds is a pointer to an array of slink:VkSparseImageOpaqueMemoryBindInfo structures, indicating opaque sparse image bindings to perform.</member>
        <member name="imageBindCount">pname:imageBindCount is the number of sparse image bindings to perform.</member>
        <member name="pImageBinds">pname:pImageBinds is a pointer to an array of slink:VkSparseImageMemoryBindInfo structures, indicating sparse image bindings to perform.</member>
        <member name="signalSemaphoreCount">pname:signalSemaphoreCount is the number of semaphores to be signaled once the sparse binding operations specified by the structure have completed execution.</member>
        <member name="pSignalSemaphores">pname:pSignalSemaphores is a pointer to an array of semaphores which will be signaled when the sparse binding operations for this batch have completed execution. If semaphores to be signaled are provided, they define a &lt;&lt;synchronization-semaphores-signaling, semaphore signal operation&gt;&gt;.</member>
      </members>
    </type>
    <type name="VkBlendFactor" summary="Framebuffer blending factors.">
      <specification />
      <description>
        <para>The semantics of each enum value is described in the table below:</para>
        <para>.Blend Factors [width="100%",options="header",align="center",cols="59%,28%,13%"] |==== |VkBlendFactor                                  | RGB Blend Factors [eq]#(S~r~,S~g~,S~b~)# or [eq]#(D~r~,D~g~,D~b~)# | Alpha Blend Factor ([eq]#S~a~# or [eq]#D~a~#) |ename:VK_BLEND_FACTOR_ZERO                     | [eq]#(0,0,0)#                              | [eq]#0# |ename:VK_BLEND_FACTOR_ONE                      | [eq]#(1,1,1)#                              | [eq]#1# |ename:VK_BLEND_FACTOR_SRC_COLOR                | [eq]#(R~s0~,G~s0~,B~s0~)#                  | [eq]#A~s0~# |ename:VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR      | [eq]#(1-R~s0~,1-G~s0~,1-B~s0~)#            | [eq]#1-A~s0~# |ename:VK_BLEND_FACTOR_DST_COLOR                | [eq]#(R~d~,G~d~,B~d~)#                     | [eq]#A~d~# |ename:VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR      | [eq]#(1-R~d~,1-G~d~,1-B~d~)#               | [eq]#1-A~d~# |ename:VK_BLEND_FACTOR_SRC_ALPHA                | [eq]#(A~s0~,A~s0~,A~s0~)#                  | [eq]#A~s0~# |ename:VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA      | [eq]#(1-A~s0~,1-A~s0~,1-A~s0~)#            | [eq]#1-A~s0~# |ename:VK_BLEND_FACTOR_DST_ALPHA                | [eq]#(A~d~,A~d~,A~d~)#                     | [eq]#A~d~# |ename:VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA      | [eq]#(1-A~d~,1-A~d~,1-A~d~)#               | [eq]#1-A~d~# |ename:VK_BLEND_FACTOR_CONSTANT_COLOR           | [eq]#(R~c~,G~c~,B~c~)#                     | [eq]#A~c~# |ename:VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR | [eq]#(1-R~c~,1-G~c~,1-B~c~)#               | [eq]#1-A~c~# |ename:VK_BLEND_FACTOR_CONSTANT_ALPHA           | [eq]#(A~c~,A~c~,A~c~)#                     | [eq]#A~c~# |ename:VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA | [eq]#(1-A~c~,1-A~c~,1-A~c~)#               | [eq]#1-A~c~# |ename:VK_BLEND_FACTOR_SRC_ALPHA_SATURATE       | [eq]#(f,f,f)#; [eq]#f = min(A~s0~,1-A~d~)# | [eq]#1# |ename:VK_BLEND_FACTOR_SRC1_COLOR               | [eq]#(R~s1~,G~s1~,B~s1~)#                  | [eq]#A~s1~# |ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR     | [eq]#(1-R~s1~,1-G~s1~,1-B~s1~)#            | [eq]#1-A~s1~# |ename:VK_BLEND_FACTOR_SRC1_ALPHA               | [eq]#(A~s1~,A~s1~,A~s1~)#                  | [eq]#A~s1~# |ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA     | [eq]#(1-A~s1~,1-A~s1~,1-A~s1~)#            | [eq]#1-A~s1~# |====</para>
        <para>In this table, the following conventions are used:</para>
        <para>* [eq]#R~s0~,G~s0~,B~s0~# and [eq]#A~s0~# represent the first source color R, G, B, and A components, respectively, for the fragment output location corresponding to the color attachment being blended. * [eq]#R~s1~,G~s1~,B~s1~# and [eq]#A~s1~# represent the second source color R, G, B, and A components, respectively, used in dual source blending modes, for the fragment output location corresponding to the color attachment being blended. * [eq]#R~d~,G~d~,B~d~# and [eq]#A~d~# represent the R, G, B, and A components of the destination color. That is, the color currently in the corresponding color attachment for this fragment/sample. * [eq]#R~c~,G~c~,B~c~# and [eq]#A~c~# represent the blend constant R, G, B, and A components, respectively.</para>
      </description>
      <members />
    </type>
    <type name="VkBlendOp" summary="Framebuffer blending operations.">
      <specification />
      <description>
        <para>&lt;&lt;&lt;</para>
        <para>The semantics of each enum value is described in the table below:</para>
        <para>.Blend Operations [width="100%",cols="45%,30%,25%",options="header",align="center"] |==== |VkBlendOp                                   | RGB Components                    | Alpha Component</para>
        <para>|ename:VK_BLEND_OP_ADD | [eq]#R = R~s0~ {times} S~r~ + R~d~ {times} D~r~# + [eq]#G = G~s0~ {times} S~g~ + G~d~ {times} D~g~# + [eq]#B = B~s0~ {times} S~b~ + B~d~ {times} D~b~# | [eq]#A = A~s0~ {times} S~a~ + A~d~ {times} D~a~#</para>
        <para>|ename:VK_BLEND_OP_SUBTRACT | [eq]#R = R~s0~ {times} S~r~ - R~d~ {times} D~r~# + [eq]#G = G~s0~ {times} S~g~ - G~d~ {times} D~g~# + [eq]#B = B~s0~ {times} S~b~ - B~d~ {times} D~b~# | [eq]#A = A~s0~ {times} S~a~ - A~d~ {times} D~a~#</para>
        <para>|ename:VK_BLEND_OP_REVERSE_SUBTRACT | [eq]#R = R~d~ {times} D~r~ - R~s0~ {times} S~r~# + [eq]#G = G~d~ {times} D~g~ - G~s0~ {times} S~g~# + [eq]#B = B~d~ {times} D~b~ - B~s0~ {times} S~b~# | [eq]#A = A~d~ {times} D~a~ - A~s0~ {times} S~a~#</para>
        <para>|ename:VK_BLEND_OP_MIN | [eq]#R = min(R~s0~,R~d~)# + [eq]#G = min(G~s0~,G~d~)# + [eq]#B = min(B~s0~,B~d~)# | [eq]#A = min(A~s0~,A~d~)#</para>
        <para>|ename:VK_BLEND_OP_MAX | [eq]#R = max(R~s0~,R~d~)# + [eq]#G = max(G~s0~,G~d~)# + [eq]#B = max(B~s0~,B~d~)# | [eq]#A = max(A~s0~,A~d~)# |====</para>
        <para>In this table, the following conventions are used:</para>
        <para>* [eq]#R~s0~, G~s0~, B~s0~# and [eq]#A~s0~# represent the first source color R, G, B, and A components, respectively. * [eq]#R~d~, G~d~, B~d~# and [eq]#A~d~# represent the R, G, B, and A components of the destination color. That is, the color currently in the corresponding color attachment for this fragment/sample. * [eq]#S~r~, S~g~, S~b~# and [eq]#S~a~# represent the source blend factor R, G, B, and A components, respectively. * [eq]#D~r~, D~g~, D~b~# and [eq]#D~a~# represent the destination blend factor R, G, B, and A components, respectively.</para>
        <para>The blending operation produces a new set of values [eq]#R, G, B# and [eq]#A#, which are written to the framebuffer attachment. If blending is not enabled for this attachment, then [eq]#R, G, B# and [eq]#A# are assigned [eq]#R~s0~, G~s0~, B~s0~# and [eq]#A~s0~#, respectively.</para>
        <para>If the color attachment is fixed-point, the components of the source and destination values and blend factors are each clamped to [eq]#[0,1]# or [eq]#[-1,1]# respectively for an unsigned normalized or signed normalized color attachment prior to evaluating the blend operations. If the color attachment is floating-point, no clamping occurs.</para>
      </description>
      <members />
    </type>
    <type name="VkBool32" summary="Vulkan boolean type.">
      <specification />
      <description>
        <para>ename:VK_TRUE represents a boolean *True* (integer 1) value, and ename:VK_FALSE a boolean *False* (integer 0) value.</para>
        <para>All values returned from a Vulkan implementation in a basetype:VkBool32 will be either ename:VK_TRUE or ename:VK_FALSE.</para>
        <para>Applications must: not pass any other values than ename:VK_TRUE or ename:VK_FALSE into a Vulkan implementation where a basetype:VkBool32 is expected.</para>
      </description>
      <members />
    </type>
    <type name="VkBorderColor" summary="Specify border color used for texture lookups.">
      <specification />
      <description>
        <para>[NOTE] .Mapping of OpenGL to Vulkan filter modes ================== pname:magFilter values of ename:VK_FILTER_NEAREST and ename:VK_FILTER_LINEAR directly correspond to code:GL_NEAREST and code:GL_LINEAR magnification filters. pname:minFilter and pname:mipmapMode combine to correspond to the similarly named OpenGL minification filter of code:GL_minFilter_MIPMAP_mipmapMode (e.g. pname:minFilter of ename:VK_FILTER_LINEAR and pname:mipmapMode of ename:VK_SAMPLER_MIPMAP_MODE_NEAREST correspond to code:GL_LINEAR_MIPMAP_NEAREST).</para>
        <para>There are no Vulkan filter modes that directly correspond to OpenGL minification filters of code:GL_LINEAR or code:GL_NEAREST, but they can: be emulated using ename:VK_SAMPLER_MIPMAP_MODE_NEAREST, pname:minLod = 0, and pname:maxLod = 0.25, and using pname:minFilter = ename:VK_FILTER_LINEAR or pname:minFilter = ename:VK_FILTER_NEAREST, respectively.</para>
        <para>Note that using a pname:maxLod of zero would cause &lt;&lt;textures-texel-filtering,magnification&gt;&gt; to always be performed, and the pname:magFilter to always be used. This is valid, just not an exact match for OpenGL behavior. Clamping the maximum LOD to 0.25 allows the [eq]#{lambda}# value to be non-zero and minification to be performed, while still always rounding down to the base level. If the pname:minFilter and pname:magFilter are equal, then using a pname:maxLod of zero also works. ==================</para>
        <para>pname:addressModeU, pname:addressModeV, and pname:addressModeW must: each have one of the following values:</para>
      </description>
      <members />
    </type>
    <type name="VkBuffer" summary="Opaque handle to a buffer object.">
      <specification>
        <para>Buffers represent linear arrays of data which are used for various purposes by binding them to a graphics or compute pipeline via descriptor sets or via certain commands, or by directly specifying them as parameters to certain commands.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkBufferCopy" summary="Structure specifying a buffer copy operation.">
      <specification />
      <description />
      <members>
        <member name="srcOffset">pname:srcOffset is the starting offset in bytes from the start of pname:srcBuffer.</member>
        <member name="dstOffset">pname:dstOffset is the starting offset in bytes from the start of pname:dstBuffer.</member>
        <member name="size">pname:size is the number of bytes to copy.</member>
      </members>
    </type>
    <type name="VkBufferCreateFlagBits" summary="Bitmask specifying additional parameters of a buffer.">
      <specification />
      <description>
        <para>See &lt;&lt;sparsememory-sparseresourcefeatures,Sparse Resource Features&gt;&gt; and &lt;&lt;features-features,Physical Device Features&gt;&gt; for details of the sparse memory features supported on a device.</para>
        <para>.Valid Usage **** * pname:size must: be greater than `0` * If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:pQueueFamilyIndices must: be a pointer to an array of pname:queueFamilyIndexCount basetype:uint32_t values * If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:queueFamilyIndexCount must: be greater than `1` * If the &lt;&lt;features-features-sparseBinding,sparse bindings&gt;&gt; feature is not enabled, pname:flags must: not contain ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT * If the &lt;&lt;features-features-sparseResidencyBuffer,sparse buffer residency&gt;&gt; feature is not enabled, pname:flags must: not contain ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT * If the &lt;&lt;features-features-sparseResidencyAliased,sparse aliased residency&gt;&gt; feature is not enabled, pname:flags must: not contain ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT * If pname:flags contains ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT or ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT, it must: also contain ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT ****</para>
      </description>
      <members>
        <member name="VK_BUFFER_CREATE_SPARSE_BINDING_BIT">ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT indicates that the buffer will be backed using sparse memory binding.</member>
        <member name="VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT">ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT indicates that the buffer can: be partially backed using sparse memory binding. Buffers created with this flag must: also be created with the ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag.</member>
        <member name="VK_BUFFER_CREATE_SPARSE_ALIASED_BIT">ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT indicates that the buffer will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another buffer (or another portion of the same buffer). Buffers created with this flag must: also be created with the ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag.</member>
      </members>
    </type>
    <type name="VkBufferCreateInfo" summary="Structure specifying the parameters of a newly created buffer object.">
      <specification />
      <description>
        <para>Bits which can: be set in pname:usage are:</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is a bitmask describing additional parameters of the buffer. See elink:VkBufferCreateFlagBits below for a description of the supported bits.</member>
        <member name="size">pname:size is the size in bytes of the buffer to be created.</member>
        <member name="usage">pname:usage is a bitmask describing the allowed usages of the buffer. See elink:VkBufferUsageFlagBits below for a description of the supported bits.</member>
        <member name="sharingMode">pname:sharingMode is the sharing mode of the buffer when it will be accessed by multiple queue families, see elink:VkSharingMode in the &lt;&lt;resources-sharing,Resource Sharing&gt;&gt; section below for supported values.</member>
        <member name="queueFamilyIndexCount">pname:queueFamilyIndexCount is the number of entries in the pname:pQueueFamilyIndices array.</member>
        <member name="pQueueFamilyIndices">pname:pQueueFamilyIndices is a list of queue families that will access this buffer (ignored if pname:sharingMode is not ename:VK_SHARING_MODE_CONCURRENT).</member>
      </members>
    </type>
    <type name="VkBufferImageCopy" summary="Structure specifying a buffer image copy operation.">
      <specification />
      <description>
        <para>When copying to or from a depth or stencil aspect, the data in buffer memory uses a layout that is a (mostly) tightly packed representation of the depth or stencil data. Specifically:</para>
        <para>* data copied to or from the stencil aspect of any depth/stencil format is tightly packed with one ename:VK_FORMAT_S8_UINT value per texel. * data copied to or from the depth aspect of a ename:VK_FORMAT_D16_UNORM or ename:VK_FORMAT_D16_UNORM_S8_UINT format is tightly packed with one ename:VK_FORMAT_D16_UNORM value per texel. * data copied to or from the depth aspect of a ename:VK_FORMAT_D32_SFLOAT or ename:VK_FORMAT_D32_SFLOAT_S8_UINT format is tightly packed with one ename:VK_FORMAT_D32_SFLOAT value per texel. * data copied to or from the depth aspect of a ename:VK_FORMAT_X8_D24_UNORM_PACK32 or ename:VK_FORMAT_D24_UNORM_S8_UINT format is packed with one 32-bit word per texel with the D24 value in the LSBs of the word, and undefined values in the eight MSBs.</para>
        <para>[NOTE] .Note ==== To copy both the depth and stencil aspects of a depth/stencil format, two entries in pname:pRegions can: be used, where one specifies the depth aspect in pname:imageSubresource, and the other specifies the stencil aspect. ====</para>
        <para>Because depth or stencil aspect buffer to image copies may: require format conversions on some implementations, they are not supported on queues that do not support graphics. When copying to a depth aspect, the data in buffer memory must: be in the the range [eq]#[0,1]# or undefined results occur.</para>
        <para>Copies are done layer by layer starting with image layer pname:baseArrayLayer member of pname:imageSubresource. pname:layerCount layers are copied from the source image or to the destination image.</para>
        <para>.Valid Usage **** * pname:bufferOffset must: be a multiple of the calling command's sname:VkImage parameter's format's element size * pname:bufferOffset must: be a multiple of `4` * pname:bufferRowLength must: be `0`, or greater than or equal to the pname:width member of pname:imageExtent * pname:bufferImageHeight must: be `0`, or greater than or equal to the pname:height member of pname:imageExtent * pname:imageOffset.x and (pname:imageExtent.width + pname:imageOffset.x) must: both be greater than or equal to `0` and less than or equal to the image subresource width * pname:imageOffset.y and (imageExtent.height + pname:imageOffset.y) must: both be greater than or equal to `0` and less than or equal to the image subresource height ** If the calling command's pname:srcImage (flink:vkCmdCopyImageToBuffer) or pname:dstImage (flink:vkCmdCopyBufferToImage) is of type ename:VK_IMAGE_TYPE_1D, then pname:imageOffset.y must: be `0` and pname:imageExtent.height must: be `1`. * pname:imageOffset.z and (imageExtent.depth + pname:imageOffset.z) must: both be greater than or equal to `0` and less than or equal to the image subresource depth ** If the calling command's pname:srcImage (flink:vkCmdCopyImageToBuffer) or pname:dstImage (flink:vkCmdCopyBufferToImage) is of type ename:VK_IMAGE_TYPE_1D or ename:VK_IMAGE_TYPE_2D, then pname:imageOffset.z must: be `0` and pname:imageExtent.depth must: be `1`. * If the calling command's sname:VkImage parameter is a compressed format image: ** pname:bufferRowLength must: be a multiple of the compressed texel block width ** pname:bufferImageHeight must: be a multiple of the compressed texel block height ** all members of pname:imageOffset must: be a multiple of the corresponding dimensions of the compressed texel block ** pname:bufferOffset must: be a multiple of the compressed texel block size in bytes ** pname:imageExtent.width must: be a multiple of the compressed texel block width or (pname:imageExtent.width + pname:imageOffset.x) must: equal the image subresource width ** pname:imageExtent.height must: be a multiple of the compressed texel block height or (pname:imageExtent.height + pname:imageOffset.y) must: equal the image subresource height ** pname:imageExtent.depth must: be a multiple of the compressed texel block depth or (pname:imageExtent.depth + pname:imageOffset.z) must: equal the image subresource depth * pname:bufferOffset, pname:bufferRowLength, pname:bufferImageHeight and all members of pname:imageOffset and pname:imageExtent must: respect the image transfer granularity requirements of the queue family that it will be submitted against, as described in &lt;&lt;devsandqueues-physical-device-enumeration,Physical Device Enumeration&gt;&gt; * The pname:aspectMask member of pname:imageSubresource must: specify aspects present in the calling command's sname:VkImage parameter * The pname:aspectMask member of pname:imageSubresource must: only have a single bit set * If the calling command's sname:VkImage parameter is of elink:VkImageType ename:VK_IMAGE_TYPE_3D, the pname:baseArrayLayer and pname:layerCount members of pname:imageSubresource must: be `0` and `1`, respectively * When copying to the depth aspect of an image subresource, the data in the source buffer must: be in the range [eq]#[0,1]# ****</para>
      </description>
      <members>
        <member name="bufferOffset">pname:bufferOffset is the offset in bytes from the start of the buffer object where the image data is copied from or to.</member>
        <member name="bufferRowLength">pname:bufferRowLength and pname:bufferImageHeight specify the data in buffer memory as a subregion of a larger two- or three-dimensional image, and control the addressing calculations of data in buffer memory. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the pname:imageExtent.</member>
        <member name="imageSubresource">pname:imageSubresource is a slink:VkImageSubresourceLayers used to specify the specific image subresources of the image used for the source or destination image data.</member>
        <member name="imageOffset">pname:imageOffset selects the initial x, y, z offsets in texels of the sub-region of the source or destination image data.</member>
        <member name="imageExtent">pname:imageExtent is the size in texels of the image to copy in pname:width, pname:height and pname:depth.</member>
      </members>
    </type>
    <type name="VkBufferMemoryBarrier" summary="Structure specifying the parameters of a buffer memory barrier.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:offset must: be less than the size of pname:buffer * If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be greater than `0` * If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be less than or equal to than the size of pname:buffer minus pname:offset * If pname:buffer was created with a sharing mode of ename:VK_SHARING_MODE_CONCURRENT, pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex must: both be ename:VK_QUEUE_FAMILY_IGNORED * If pname:buffer was created with a sharing mode of ename:VK_SHARING_MODE_EXCLUSIVE, pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex must: either both be ename:VK_QUEUE_FAMILY_IGNORED, or both be a valid queue family (see &lt;&lt;devsandqueues-queueprops&gt;&gt;) * If pname:buffer was created with a sharing mode of ename:VK_SHARING_MODE_EXCLUSIVE, and pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex are valid queue families, at least one of them must: be the same as the family of the queue that will execute this barrier ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="srcAccessMask">pname:srcAccessMask is a bitmask of the classes of memory accesses performed by the first set of commands that will participate in the dependency.</member>
        <member name="dstAccessMask">pname:dstAccessMask is a bitmask of the classes of memory accesses performed by the second set of commands that will participate in the dependency.</member>
        <member name="srcQueueFamilyIndex">pname:srcQueueFamilyIndex is the queue family that is relinquishing ownership of the range of pname:buffer to another queue, or ename:VK_QUEUE_FAMILY_IGNORED if there is no transfer of ownership.</member>
        <member name="dstQueueFamilyIndex">pname:dstQueueFamilyIndex is the queue family that is acquiring ownership of the range of pname:buffer from another queue, or ename:VK_QUEUE_FAMILY_IGNORED if there is no transfer of ownership.</member>
        <member name="buffer">pname:buffer is a handle to the buffer whose backing memory is affected by the barrier.</member>
        <member name="offset">pname:offset is an offset in bytes into the backing memory for pname:buffer; this is relative to the base offset as bound to the buffer (see flink:vkBindBufferMemory).</member>
        <member name="size">pname:size is a size in bytes of the affected area of backing memory for pname:buffer, or ename:VK_WHOLE_SIZE to use the range from pname:offset to the end of the buffer.</member>
      </members>
    </type>
    <type name="VkBufferUsageFlagBits" summary="Bitmask specifying allowed usage of a buffer.">
      <specification />
      <description>
        <para>Any combination of bits can: be specified for pname:usage, but at least one of the bits must: be set in order to create a valid buffer.</para>
        <para>Bits which can: be set in pname:flags are:</para>
      </description>
      <members>
        <member name="VK_BUFFER_USAGE_TRANSFER_SRC_BIT">ename:VK_BUFFER_USAGE_TRANSFER_SRC_BIT indicates that the buffer can: be used as the source of a _transfer command_ (see the definition of &lt;&lt;synchronization-transfer,ename:VK_PIPELINE_STAGE_TRANSFER_BIT&gt;&gt;).</member>
        <member name="VK_BUFFER_USAGE_TRANSFER_DST_BIT">ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT indicates that the buffer can: be used as the destination of a transfer command.</member>
        <member name="VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT">ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT indicates that the buffer can: be used to create a sname:VkBufferView suitable for occupying a sname:VkDescriptorSet slot of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.</member>
        <member name="VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT">ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT indicates that the buffer can: be used to create a sname:VkBufferView suitable for occupying a sname:VkDescriptorSet slot of type ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.</member>
        <member name="VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT">ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT indicates that the buffer can: be used in a sname:VkDescriptorBufferInfo suitable for occupying a sname:VkDescriptorSet slot either of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.</member>
        <member name="VK_BUFFER_USAGE_STORAGE_BUFFER_BIT">ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT indicates that the buffer can: be used in a sname:VkDescriptorBufferInfo suitable for occupying a sname:VkDescriptorSet slot either of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.</member>
        <member name="VK_BUFFER_USAGE_INDEX_BUFFER_BIT">ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT indicates that the buffer is suitable for passing as the pname:buffer parameter to fname:vkCmdBindIndexBuffer.</member>
        <member name="VK_BUFFER_USAGE_VERTEX_BUFFER_BIT">ename:VK_BUFFER_USAGE_VERTEX_BUFFER_BIT indicates that the buffer is suitable for passing as an element of the pname:pBuffers array to fname:vkCmdBindVertexBuffers.</member>
        <member name="VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT">ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT indicates that the buffer is suitable for passing as the pname:buffer parameter to fname:vkCmdDrawIndirect, fname:vkCmdDrawIndexedIndirect, or fname:vkCmdDispatchIndirect.</member>
      </members>
    </type>
    <type name="VkBufferView" summary="Opaque handle to a buffer view object.">
      <specification>
        <para>A _buffer view_ represents a contiguous range of a buffer and a specific format to be used to interpret the data. Buffer views are used to enable shaders to access buffer contents interpreted as formatted data. In order to create a valid buffer view, the buffer must: have been created with at least one of the following usage flags:</para>
        <para>* ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT * ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkBufferViewCreateInfo" summary="Structure specifying parameters of a newly created buffer view.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:offset must: be less than the size of pname:buffer * pname:offset must: be a multiple of sname:VkPhysicalDeviceLimits::pname:minTexelBufferOffsetAlignment * If pname:range is not equal to ename:VK_WHOLE_SIZE: ** pname:range must: be greater than `0` ** pname:range must: be a multiple of the element size of pname:format ** pname:range divided by the element size of pname:format, must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxTexelBufferElements ** the sum of pname:offset and pname:range must: be less than or equal to the size of pname:buffer * pname:buffer must: have been created with a pname:usage value containing at least one of ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT * If pname:buffer was created with pname:usage containing ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT, pname:format must: be supported for uniform texel buffers, as specified by the ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT flag in sname:VkFormatProperties::pname:bufferFeatures returned by fname:vkGetPhysicalDeviceFormatProperties * If pname:buffer was created with pname:usage containing ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, pname:format must: be supported for storage texel buffers, as specified by the ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT flag in sname:VkFormatProperties::pname:bufferFeatures returned by fname:vkGetPhysicalDeviceFormatProperties ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="buffer">pname:buffer is a sname:VkBuffer on which the view will be created.</member>
        <member name="format">pname:format is a elink:VkFormat describing the format of the data elements in the buffer.</member>
        <member name="offset">pname:offset is an offset in bytes from the base address of the buffer. Accesses to the buffer view from shaders use addressing that is relative to this starting offset.</member>
        <member name="range">pname:range is a size in bytes of the buffer view. If pname:range is equal to ename:VK_WHOLE_SIZE, the range from pname:offset to the end of the buffer is used. If ename:VK_WHOLE_SIZE is used and the remaining size of the buffer is not a multiple of the element size of pname:format, then the nearest smaller multiple is used.</member>
      </members>
    </type>
    <type name="VkClearAttachment" summary="Structure specifying a clear attachment.">
      <specification />
      <description>
        <para>No memory barriers are needed between fname:vkCmdClearAttachments and preceding or subsequent draw or attachment clear commands in the same subpass.</para>
        <para>The fname:vkCmdClearAttachments command is not affected by the bound pipeline state.</para>
        <para>Attachments can: also be cleared at the beginning of a render pass instance by setting pname:loadOp (or pname:stencilLoadOp) of slink:VkAttachmentDescription to ename:VK_ATTACHMENT_LOAD_OP_CLEAR, as described for flink:vkCreateRenderPass.</para>
        <para>.Valid Usage **** * If pname:aspectMask includes ename:VK_IMAGE_ASPECT_COLOR_BIT, it must: not include ename:VK_IMAGE_ASPECT_DEPTH_BIT or ename:VK_IMAGE_ASPECT_STENCIL_BIT * pname:aspectMask must: not include ename:VK_IMAGE_ASPECT_METADATA_BIT ****</para>
      </description>
      <members>
        <member name="aspectMask">pname:aspectMask is a mask selecting the color, depth and/or stencil aspects of the attachment to be cleared. pname:aspectMask can: include ename:VK_IMAGE_ASPECT_COLOR_BIT for color attachments, ename:VK_IMAGE_ASPECT_DEPTH_BIT for depth/stencil attachments with a depth component, and ename:VK_IMAGE_ASPECT_STENCIL_BIT for depth/stencil attachments with a stencil component. If the subpass's depth/stencil attachment is ename:VK_ATTACHMENT_UNUSED, then the clear has no effect.</member>
        <member name="colorAttachment">pname:colorAttachment is only meaningful if ename:VK_IMAGE_ASPECT_COLOR_BIT is set in pname:aspectMask, in which case it is an index to the pname:pColorAttachments array in the slink:VkSubpassDescription structure of the current subpass which selects the color attachment to clear. If pname:colorAttachment is ename:VK_ATTACHMENT_UNUSED then the clear has no effect.</member>
        <member name="clearValue">pname:clearValue is the color or depth/stencil value to clear the attachment to, as described in &lt;&lt;clears-values,Clear Values&gt;&gt; below.</member>
      </members>
    </type>
    <type name="VkClearColorValue" summary="Structure specifying a clear color value.">
      <specification />
      <description>
        <para>The four array elements of the clear color map to R, G, B, and A components of image formats, in order.</para>
        <para>If the image has more than one sample, the same value is written to all samples for any pixels being cleared.</para>
      </description>
      <members>
        <member name="float32">pname:float32 are the color clear values when the format of the image or attachment is one of the formats in the &lt;&lt;features-formats-numericformat, Interpretation of Numeric Format&gt;&gt; table other than signed integer (etext:SINT) or unsigned integer (etext:UINT). Floating point values are automatically converted to the format of the image, with the clear value being treated as linear if the image is sRGB.</member>
        <member name="int32">pname:int32 are the color clear values when the format of the image or attachment is signed integer (etext:SINT). Signed integer values are converted to the format of the image by casting to the smaller type (with negative 32-bit values mapping to negative values in the smaller type). If the integer clear value is not representable in the target type (e.g. would overflow in conversion to that type), the clear value is undefined.</member>
        <member name="uint32">pname:uint32 are the color clear values when the format of the image or attachment is unsigned integer (etext:UINT). Unsigned integer values are converted to the format of the image by casting to the integer type with fewer bits.</member>
      </members>
    </type>
    <type name="VkClearDepthStencilValue" summary="Structure specifying a clear depth stencil value.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:depth must: be between `0.0` and `1.0`, inclusive ****</para>
      </description>
      <members>
        <member name="depth">pname:depth is the clear value for the depth aspect of the depth/stencil attachment. It is a floating-point value which is automatically converted to the attachment's format.</member>
        <member name="stencil">pname:stencil is the clear value for the stencil aspect of the depth/stencil attachment. It is a 32-bit integer value which is converted to the attachment's format by taking the appropriate number of LSBs.</member>
      </members>
    </type>
    <type name="VkClearRect" summary="Structure specifying a clear rectangle.">
      <specification />
      <description>
        <para>The layers [eq]#[pname:baseArrayLayer, pname:baseArrayLayer {plus} pname:layerCount)# counting from the base layer of the attachment image view are cleared.</para>
      </description>
      <members>
        <member name="rect">pname:rect is the two-dimensional region to be cleared.</member>
        <member name="baseArrayLayer">pname:baseArrayLayer is the first layer to be cleared.</member>
        <member name="layerCount">pname:layerCount is the number of layers to clear.</member>
      </members>
    </type>
    <type name="VkClearValue" summary="Structure specifying a clear value.">
      <specification />
      <description>
        <para>This union is used where part of the API requires either color or depth/stencil clear values, depending on the attachment, and defines the initial clear values in the slink:VkRenderPassBeginInfo structure.</para>
      </description>
      <members>
        <member name="color">pname:color specifies the color image clear values to use when clearing a color image or attachment.</member>
        <member name="depthStencil">pname:depthStencil specifies the depth and stencil clear values to use when clearing a depth/stencil image or attachment.</member>
      </members>
    </type>
    <type name="VkColorComponentFlagBits" summary="Bitmask controlling which components are written to the framebuffer.">
      <specification />
      <description>
        <para>If ename:VK_COLOR_COMPONENT_R_BIT is set, then the [eq]#R# value is written to color attachment for the appropriate sample, otherwise the value in memory is unmodified. The ename:VK_COLOR_COMPONENT_G_BIT, ename:VK_COLOR_COMPONENT_B_BIT, and ename:VK_COLOR_COMPONENT_A_BIT bits similarly control writing of the [eq]#G, B,# and [eq]#A# values. The pname:colorWriteMask is applied regardless of whether blending is enabled.</para>
      </description>
      <members />
    </type>
    <type name="VkColorSpaceKHR" summary="Supported color space of the presentation engine.">
      <specification />
      <description>
        <para>[NOTE] .Note ==== If pname:pSurfaceFormats includes just one entry, whose value for pname:format is ename:VK_FORMAT_UNDEFINED, pname:surface has no preferred format. In this case, the application can: use any valid ename:VkFormat value. ====</para>
        <para>[NOTE] .Note ==== In the initial release of the +VK_KHR_surface+ and +VK_KHR_swapchain+ extensions, the token ename:VK_COLORSPACE_SRGB_NONLINEAR_KHR was used. Starting in the May 13, 2016 updates to the extension branches, matching release 1.0.13 of the core API specification, ename:VK_COLOR_SPACE_SRGB_NONLINEAR_KHR is used instead for consistency with Vulkan naming rules. The older enum is still available for backwards compatibility. ====</para>
      </description>
      <members>
        <member name="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR">ename:VK_COLOR_SPACE_SRGB_NONLINEAR_KHR: The presentation engine supports the sRGB color space.</member>
      </members>
    </type>
    <type name="VkCommandBuffer" summary="Opaque handle to a command buffer object.">
      <specification>
        <para>Command buffers are objects used to record commands which can: be subsequently submitted to a device queue for execution. There are two levels of command buffers - _primary command buffers_, which can: execute secondary command buffers, and which are submitted to queues, and _secondary command buffers_, which can: be executed by primary command buffers, and which are not directly submitted to queues.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkCommandBufferAllocateInfo" summary="Structure specifying the allocation parameters for command buffer object.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="commandPool">pname:commandPool is the name of the command pool that the command buffers allocate their memory from.</member>
        <member name="level">pname:level determines whether the command buffers are primary or secondary command buffers. Possible values include: + --</member>
      </members>
    </type>
    <type name="VkCommandBufferBeginInfo" summary="Structure specifying a command buffer begin operation.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is a bitmask indicating usage behavior for the command buffer. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkCommandBufferInheritanceInfo" summary="Structure specifying command buffer inheritance info.">
      <specification />
      <description>
        <para>.Valid Usage **** * If the &lt;&lt;features-features-inheritedQueries,inherited queries&gt;&gt; feature is not enabled, pname:occlusionQueryEnable must: be ename:VK_FALSE * If the &lt;&lt;features-features-inheritedQueries,inherited queries&gt;&gt; feature is enabled, pname:queryFlags must: be a valid combination of elink:VkQueryControlFlagBits values * If the &lt;&lt;features-features-pipelineStatisticsQuery,pipeline statistics queries&gt;&gt; feature is not enabled, pname:pipelineStatistics must: be code:0 ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="renderPass">pname:renderPass is a sname:VkRenderPass object defining which render passes the sname:VkCommandBuffer will be &lt;&lt;renderpass-compatibility, compatible&gt;&gt; with and can: be executed within. If the sname:VkCommandBuffer will not be executed within a render pass instance, pname:renderPass is ignored.</member>
        <member name="subpass">pname:subpass is the index of the subpass within the render pass instance that the sname:VkCommandBuffer will be executed within. If the sname:VkCommandBuffer will not be executed within a render pass instance, pname:subpass is ignored.</member>
        <member name="framebuffer">pname:framebuffer optionally refers to the sname:VkFramebuffer object that the sname:VkCommandBuffer will be rendering to if it is executed within a render pass instance. It can: be dlink:VK_NULL_HANDLE if the framebuffer is not known, or if the sname:VkCommandBuffer will not be executed within a render pass instance. + [NOTE] .Note ==== Specifying the exact framebuffer that the secondary command buffer will be executed with may: result in better performance at command buffer execution time. ====</member>
        <member name="occlusionQueryEnable">pname:occlusionQueryEnable indicates whether the command buffer can: be executed while an occlusion query is active in the primary command buffer. If this is ename:VK_TRUE, then this command buffer can: be executed whether the primary command buffer has an occlusion query active or not. If this is ename:VK_FALSE, then the primary command buffer must: not have an occlusion query active.</member>
        <member name="queryFlags">pname:queryFlags indicates the query flags that can: be used by an active occlusion query in the primary command buffer when this secondary command buffer is executed. If this value includes the ename:VK_QUERY_CONTROL_PRECISE_BIT bit, then the active query can: return boolean results or actual sample counts. If this bit is not set, then the active query must: not use the ename:VK_QUERY_CONTROL_PRECISE_BIT bit.</member>
        <member name="pipelineStatistics">pname:pipelineStatistics indicates the set of pipeline statistics that can: be counted by an active query in the primary command buffer when this secondary command buffer is executed. If this value includes a given bit, then this command buffer can: be executed whether the primary command buffer has a pipeline statistics query active that includes this bit or not. If this value excludes a given bit, then the active pipeline statistics query must: not be from a query pool that counts that statistic.</member>
      </members>
    </type>
    <type name="VkCommandBufferLevel" summary="Structure specifying a command buffer level.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:commandBufferCount must: be greater than `0` ****</para>
      </description>
      <members />
    </type>
    <type name="VkCommandBufferResetFlagBits" summary="Bitmask controlling behavior of a command buffer reset.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:commandBuffer must: not currently be pending execution * pname:commandBuffer must: have been allocated from a pool that was created with the ename:VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT ****</para>
      </description>
      <members />
    </type>
    <type name="VkCommandBufferUsageFlagBits" summary="Bitmask specifying usage behavior for command buffer.">
      <specification />
      <description>
        <para>.Valid Usage **** * If pname:flags contains ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the pname:renderPass member of pname:pInheritanceInfo must: be a valid sname:VkRenderPass * If pname:flags contains ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the pname:subpass member of pname:pInheritanceInfo must: be a valid subpass index within the pname:renderPass member of pname:pInheritanceInfo * If pname:flags contains ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the pname:framebuffer member of pname:pInheritanceInfo must: be either dlink:VK_NULL_HANDLE, or a valid sname:VkFramebuffer that is compatible with the pname:renderPass member of pname:pInheritanceInfo ****</para>
      </description>
      <members />
    </type>
    <type name="VkCommandPool" summary="Opaque handle to a command pool object.">
      <specification>
        <para>Command pools are opaque objects that command buffer memory is allocated from, and which allow the implementation to amortize the cost of resource creation across multiple command buffers. Command pools are application-synchronized, meaning that a command pool must: not be used concurrently in multiple threads. That includes use via recording commands on any command buffers allocated from the pool, as well as operations that allocate, free, and reset command buffers or the pool itself.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkCommandPoolCreateFlagBits" summary="Bitmask specifying usage behavior for a command pool.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:queueFamilyIndex must: be the index of a queue family available in the calling command's pname:device parameter ****</para>
      </description>
      <members />
    </type>
    <type name="VkCommandPoolCreateInfo" summary="Structure specifying parameters of a newly created command pool.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is a bitmask indicating usage behavior for the pool and command buffers allocated from it. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkCommandPoolResetFlagBits" summary="Bitmask controlling behavior of a command pool reset.">
      <specification />
      <description>
        <para>Resetting a command pool recycles all of the resources from all of the command buffers allocated from the command pool back to the command pool. All command buffers that have been allocated from the command pool are put in the initial state.</para>
        <para>.Valid Usage **** * All sname:VkCommandBuffer objects allocated from pname:commandPool must: not currently be pending execution ****</para>
      </description>
      <members />
    </type>
    <type name="VkCompareOp" summary="Stencil comparison function.">
      <specification />
      <description />
      <members>
        <member name="VK_COMPARE_OP_NEVER">ename:VK_COMPARE_OP_NEVER: the test never passes.</member>
        <member name="VK_COMPARE_OP_LESS">ename:VK_COMPARE_OP_LESS: the test passes when [eq]#R &lt; S#.</member>
        <member name="VK_COMPARE_OP_EQUAL">ename:VK_COMPARE_OP_EQUAL: the test passes when [eq]#R = S#.</member>
        <member name="VK_COMPARE_OP_LESS_OR_EQUAL">ename:VK_COMPARE_OP_LESS_OR_EQUAL: the test passes when [eq]#R {leq} S#.</member>
        <member name="VK_COMPARE_OP_GREATER">ename:VK_COMPARE_OP_GREATER: the test passes when [eq]#R &gt; S#.</member>
        <member name="VK_COMPARE_OP_NOT_EQUAL">ename:VK_COMPARE_OP_NOT_EQUAL: the test passes when [eq]#R {neq} S#.</member>
        <member name="VK_COMPARE_OP_GREATER_OR_EQUAL">ename:VK_COMPARE_OP_GREATER_OR_EQUAL: the test passes when [eq]#R {geq} S#.</member>
        <member name="VK_COMPARE_OP_ALWAYS">ename:VK_COMPARE_OP_ALWAYS: the test always passes.</member>
      </members>
    </type>
    <type name="VkComponentMapping" summary="Structure specifying a color component mapping.">
      <specification />
      <description>
        <para>Each of pname:r, pname:g, pname:b, and pname:a is one of the values:</para>
      </description>
      <members>
        <member name="r">pname:r determines the component value placed in the R component of the output vector.</member>
        <member name="g">pname:g determines the component value placed in the G component of the output vector.</member>
        <member name="b">pname:b determines the component value placed in the B component of the output vector.</member>
        <member name="a">pname:a determines the component value placed in the A component of the output vector.</member>
      </members>
    </type>
    <type name="VkComponentSwizzle" summary="Specify how a component is swizzled.">
      <specification />
      <description>
        <para>Setting the identity swizzle on a component is equivalent to setting the identity mapping on that component. That is:</para>
        <para>.Component Mappings Equivalent To ename:VK_COMPONENT_SWIZZLE_IDENTITY [options="header"] |==== | Component          | Identity Mapping | pname:components.r | ename:VK_COMPONENT_SWIZZLE_R | pname:components.g | ename:VK_COMPONENT_SWIZZLE_G | pname:components.b | ename:VK_COMPONENT_SWIZZLE_B | pname:components.a | ename:VK_COMPONENT_SWIZZLE_A |====</para>
      </description>
      <members>
        <member name="VK_COMPONENT_SWIZZLE_IDENTITY">ename:VK_COMPONENT_SWIZZLE_IDENTITY: the component is set to the identity swizzle.</member>
        <member name="VK_COMPONENT_SWIZZLE_ZERO">ename:VK_COMPONENT_SWIZZLE_ZERO: the component is set to zero.</member>
        <member name="VK_COMPONENT_SWIZZLE_ONE">ename:VK_COMPONENT_SWIZZLE_ONE: the component is set to either 1 or 1.0 depending on whether the type of the image view format is integer or floating-point respectively, as determined by the &lt;&lt;features-formats-definition,Format Definition&gt;&gt; section for each elink:VkFormat.</member>
        <member name="VK_COMPONENT_SWIZZLE_R">ename:VK_COMPONENT_SWIZZLE_R: the component is set to the value of the R component of the image.</member>
        <member name="VK_COMPONENT_SWIZZLE_G">ename:VK_COMPONENT_SWIZZLE_G: the component is set to the value of the G component of the image.</member>
        <member name="VK_COMPONENT_SWIZZLE_B">ename:VK_COMPONENT_SWIZZLE_B: the component is set to the value of the B component of the image.</member>
        <member name="VK_COMPONENT_SWIZZLE_A">ename:VK_COMPONENT_SWIZZLE_A: the component is set to the value of the A component of the image.</member>
      </members>
    </type>
    <type name="VkCompositeAlphaFlagBitsKHR" summary="Alpha compositing modes supported on a device.">
      <specification />
      <description />
      <members>
        <member name="VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR">ename:VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR: The alpha channel, if it exists, of the images is ignored in the compositing process. Instead, the image is treated as if it has a constant alpha of 1.0.</member>
        <member name="VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR">ename:VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR: The alpha channel, if it exists, of the images is respected in the compositing process. The non-alpha channels of the image are expected to already be multiplied by the alpha channel by the application.</member>
        <member name="VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR">ename:VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: The alpha channel, if it exists, of the images is respected in the compositing process. The non-alpha channels of the image are not expected to already be multiplied by the alpha channel by the application; instead, the compositor will multiply the non-alpha channels of the image by the alpha channel during compositing.</member>
        <member name="VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR">ename:VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR: The way in which the presentation engine treats the alpha channel in the images is unknown to the Vulkan API. Instead, the application is responsible for setting the composite alpha blending mode using native window system commands. If the application does not set the blending mode using native window system commands, then a platform-specific default will be used.</member>
      </members>
    </type>
    <type name="VkComputePipelineCreateInfo" summary="Structure specifying parameters of a newly created compute pipeline.">
      <specification />
      <description>
        <para>The parameters pname:basePipelineHandle and pname:basePipelineIndex are described in more detail in &lt;&lt;pipelines-pipeline-derivatives,Pipeline Derivatives&gt;&gt;.</para>
        <para>pname:stage points to a structure of type sname:VkPipelineShaderStageCreateInfo.</para>
        <para>.Valid Usage **** * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineIndex is not `-1`, pname:basePipelineHandle must: be dlink:VK_NULL_HANDLE * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineIndex is not `-1`, it must: be a valid index into the calling command's pname:pCreateInfos parameter * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineHandle is not dlink:VK_NULL_HANDLE, pname:basePipelineIndex must: be `-1` * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineHandle is not dlink:VK_NULL_HANDLE, pname:basePipelineHandle must: be a valid sname:VkPipeline handle * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineHandle is not dlink:VK_NULL_HANDLE, it must: be a valid handle to a compute sname:VkPipeline * The pname:stage member of pname:stage must: be ename:VK_SHADER_STAGE_COMPUTE_BIT * The shader code for the entry point identified by pname:stage and the rest of the state identified by this structure must: adhere to the pipeline linking rules described in the &lt;&lt;interfaces,Shader Interfaces&gt;&gt; chapter * pname:layout must: be &lt;&lt;descriptorsets-pipelinelayout-consistency,consistent&gt;&gt; with the layout of the compute shader specified in pname:stage ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags provides options for pipeline creation, and is of type elink:VkPipelineCreateFlagBits.</member>
        <member name="stage">pname:stage is a slink:VkPipelineShaderStageCreateInfo describing the compute shader.</member>
        <member name="layout">pname:layout is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.</member>
        <member name="basePipelineHandle">pname:basePipelineHandle is a pipeline to derive from</member>
        <member name="basePipelineIndex">pname:basePipelineIndex is an index into the pname:pCreateInfos parameter to use as a pipeline to derive from</member>
      </members>
    </type>
    <type name="VkCopyDescriptorSet" summary="Structure specifying a copy descriptor set operation.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:srcBinding must: be a valid binding within pname:srcSet * The sum of pname:srcArrayElement and pname:descriptorCount must: be less than or equal to the number of array elements in the descriptor set binding specified by pname:srcBinding, and all applicable consecutive bindings, as described by &lt;&lt;descriptorsets-updates-consecutive&gt;&gt; * pname:dstBinding must: be a valid binding within pname:dstSet * The sum of pname:dstArrayElement and pname:descriptorCount must: be less than or equal to the number of array elements in the descriptor set binding specified by pname:dstBinding, and all applicable consecutive bindings, as described by &lt;&lt;descriptorsets-updates-consecutive&gt;&gt; * If pname:srcSet is equal to pname:dstSet, then the source and destination ranges of descriptors must: not overlap, where the ranges may: include array elements from consecutive bindings as described by &lt;&lt;descriptorsets-updates-consecutive&gt;&gt; ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="srcSet">pname:srcSet, pname:srcBinding, and pname:srcArrayElement are the source set, binding, and array element, respectively.</member>
        <member name="dstSet">pname:dstSet, pname:dstBinding, and pname:dstArrayElement are the destination set, binding, and array element, respectively.</member>
        <member name="descriptorCount">pname:descriptorCount is the number of descriptors to copy from the source to destination. If pname:descriptorCount is greater than the number of remaining array elements in the source or destination binding, those affect consecutive bindings in a manner similar to slink:VkWriteDescriptorSet above.</member>
      </members>
    </type>
    <type name="VkCullModeFlagBits" summary="Bitmask controlling triangle culling.">
      <specification />
      <description>
        <para>If the pname:cullMode is set to ename:VK_CULL_MODE_NONE no triangles are discarded, if it is set to ename:VK_CULL_MODE_FRONT_BIT front-facing triangles are discarded, if it is set to ename:VK_CULL_MODE_BACK_BIT then back-facing triangles are discarded and if it is set to ename:VK_CULL_MODE_FRONT_AND_BACK then all triangles are discarded. Following culling, fragments are produced for any triangles which have not been discarded.</para>
      </description>
      <members />
    </type>
    <type name="VkDebugMarkerMarkerInfoEXT" summary="Specify parameters of a command buffer marker region.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="pMarkerName">pname:pMarkerName is a pointer to a null-terminated UTF-8 string that contains the name of the marker.</member>
        <member name="color">pname:color is an optional RGBA color value that can be associated with the marker. A particular implementation may: choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in pname:color are set to 0.0 then it is ignored.</member>
      </members>
    </type>
    <type name="VkDebugMarkerObjectNameInfoEXT" summary="Specify parameters of a name to give to an object.">
      <specification />
      <description>
        <para>Applications may: change the name associated with an object simply by calling fname:vkDebugMarkerSetObjectNameEXT again with a new string. To remove a previously set name, pname:pName should: be set to an empty string.</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="objectType">pname:objectType is a elink:VkDebugReportObjectTypeEXT specifying the type of the object to be named.</member>
        <member name="object">pname:object is the object to be named.</member>
        <member name="pObjectName">pname:pObjectName is a null-terminated UTF-8 string specifying the name to apply to pname:object.</member>
      </members>
    </type>
    <type name="VkDebugMarkerObjectTagInfoEXT" summary="Specify parameters of a tag to attach to an object.">
      <specification />
      <description>
        <para>The pname:tagName parameter gives a name or identifier to the type of data being tagged. This can be used by debugging layers to easily filter for only data that can be used by that implementation.</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="objectType">pname:objectType is a elink:VkDebugReportObjectTypeEXT specifying the type of the object to be named.</member>
        <member name="object">pname:object is the object to be tagged.</member>
        <member name="tagName">pname:tagName is a numerical identifier of the tag.</member>
        <member name="tagSize">pname:tagSize is the number of bytes of data to attach to the object.</member>
        <member name="pTag">pname:pTag is an array of pname:tagSize bytes containing the data to be associated with the object.</member>
      </members>
    </type>
    <type name="VkDebugReportCallbackCreateInfoEXT" summary="Structure specifying parameters of a newly created debug report callback.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags indicate which event(s) will cause this callback to be called. Flags are interpreted as bitmasks and multiple may be set. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkDebugReportErrorEXT" summary="Unknown VK_EXT_debug_report enumeration type.">
      <specification />
      <description>
        <para>[NOTE] .Note ==== The +VK_EXT_debug_report+ extension defines the elink:VkDebugReportErrorEXT enumerant type, but does not currently explain what the enumeration is used for. It is included here for completeness. ====</para>
      </description>
      <members />
    </type>
    <type name="VkDebugReportFlagBitsEXT" summary="Bitmask specifying events which cause a debug report callback.">
      <specification />
      <description>
        <para>* pname:pfnCallback is the application callback function to call. * pname:pUserData is user data to be passed to the callback. --</para>
        <para>For each sname:VkDebugReportCallbackEXT that is created the flags determine when that function is called. A callback will be made for issues that match any bit set in its flags. The callback will come directly from the component that detected the event, unless some other layer intercepts the calls for its own purposes (filter them in different way, log to system error log, etc.) An application may receive multiple callbacks if multiple sname:VkDebugReportCallbackEXT objects were created. A callback will always be executed in the same thread as the originating Vulkan call. A callback may be called from multiple threads simultaneously (if the application is making Vulkan calls from multiple threads).</para>
      </description>
      <members>
        <member name="VK_DEBUG_REPORT_ERROR_BIT_EXT">ename:VK_DEBUG_REPORT_ERROR_BIT_EXT indicates an error that may cause undefined results, including an application crash.</member>
        <member name="VK_DEBUG_REPORT_WARNING_BIT_EXT">ename:VK_DEBUG_REPORT_WARNING_BIT_EXT indicates an unexpected use. E.g. Not destroying objects prior to destroying the containing object or potential inconsistencies between descriptor set layout and the layout in the corresponding shader, etc.</member>
        <member name="VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT">ename:VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT indicates a potentially non-optimal use of Vulkan. E.g. using flink:vkCmdClearColorImage when a RenderPass load_op would have worked.</member>
        <member name="VK_DEBUG_REPORT_INFORMATION_BIT_EXT">ename:VK_DEBUG_REPORT_INFORMATION_BIT_EXT indicates an informational message such as resource details that may be handy when debugging an application.</member>
        <member name="VK_DEBUG_REPORT_DEBUG_BIT_EXT">ename:VK_DEBUG_REPORT_DEBUG_BIT_EXT indicates diagnostic information from the loader and layers.</member>
      </members>
    </type>
    <type name="VkDebugReportObjectTypeEXT" summary="Specify the type of an object handle.">
      <specification />
      <description>
        <para>=== Command Buffer Markers</para>
        <para>Typical Vulkan applications will submit many command buffers in each frame, with each command buffer containing a large number of individual commands. Being able to logically annotate regions of command buffers that belong together as well as hierarchically subdivide the frame is important to a developer's ability to navigate the commands viewed holistically.</para>
        <para>The marker commands fname:vkCmdDebugMarkerBeginEXT and fname:vkCmdDebugMarkerEndEXT define regions of a series of commands that are grouped together, and they can be nested to create a hierarchy. The fname:vkCmdDebugMarkerInsertEXT command allows insertion of a single label within a command buffer.</para>
      </description>
      <members>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT is an unknown object.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT is a sname:VkInstance.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT is a sname:VkPhysicalDevice.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT is a sname:VkDevice.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT is a sname:VkQueue.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT is a sname:VkSemaphore.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT is a sname:VkCommandBuffer.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT is a sname:VkFence.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT is a sname:VkDeviceMemory.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT is a sname:VkBuffer.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT is a sname:VkImage.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT is a sname:VkEvent.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT is a sname:VkQueryPool.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT is a sname:VkBufferView.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT is a sname:VkImageView.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT is a sname:VkShaderModule.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT is a sname:VkPipelineCache.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT is a sname:VkPipelineLayout.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT is a sname:VkRenderPass.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT is a sname:VkPipeline.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT is a sname:VkDescriptorSetLayout.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT is a sname:VkSampler.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT is a sname:VkDescriptorPool.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT is a sname:VkDescriptorSet.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT is a sname:VkFramebuffer.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT is a sname:VkCommandPool.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT is a sname:VkSurfaceKHR.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT is a sname:VkSwapchainKHR.</member>
        <member name="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT">ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT is a sname:VkDebugReportCallbackEXT.</member>
      </members>
    </type>
    <type name="VkDedicatedAllocationBufferCreateInfoNV" summary="Specify that a buffer is bound to a dedicated memory resource.">
      <specification>
        <para>If the pname:pNext list includes a sname:VkDedicatedAllocationBufferCreateInfoNV structure, then that structure includes an enable controlling whether the buffer will have a dedicated memory allocation bound to it.</para>
      </specification>
      <description>
        <para>.Valid Usage **** * If pname:dedicatedAllocation is ename:VK_TRUE, sname:VkBufferCreateInfo::pname:flags must: not include ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT, ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="dedicatedAllocation">pname:dedicatedAllocation indicates whether the buffer will have a dedicated allocation bound to it.</member>
      </members>
    </type>
    <type name="VkDedicatedAllocationImageCreateInfoNV" summary="Specify that an image is bound to a dedicated memory resource.">
      <specification>
        <para>If the pname:pNext list includes a sname:VkDedicatedAllocationImageCreateInfoNV structure, then that structure includes an enable controlling whether the image will have a dedicated memory allocation bound to it.</para>
      </specification>
      <description>
        <para>[NOTE] .Note ==== Using a dedicated allocation for color and depth/stencil attachments or other large images may: improve performance on some devices. ====</para>
        <para>.Valid Usage **** * If pname:dedicatedAllocation is ename:VK_TRUE, sname:VkImageCreateInfo::pname:flags must: not include ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT, ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="dedicatedAllocation">pname:dedicatedAllocation indicates whether the image will have a dedicated allocation bound to it.</member>
      </members>
    </type>
    <type name="VkDedicatedAllocationMemoryAllocateInfoNV" summary="Specify a dedicated memory allocation resource.">
      <specification>
        <para>If the pname:pNext list includes a sname:VkDedicatedAllocationMemoryAllocateInfoNV structure, then that structure includes a handle of the sole buffer or image resource that the memory can: be bound to.</para>
      </specification>
      <description>
        <para>.Valid Usage **** * At least one of pname:image and pname:buffer must: be sname:VK_NULL_HANDLE * If pname:image is not sname:VK_NULL_HANDLE, the image must: have been created with sname:VkDedicatedAllocationImageCreateInfoNV::pname:dedicatedAllocation equal to ename:VK_TRUE * If pname:buffer is not sname:VK_NULL_HANDLE, the buffer must: have been created with sname:VkDedicatedAllocationBufferCreateInfoNV::pname:dedicatedAllocation equal to ename:VK_TRUE * If pname:image is not sname:VK_NULL_HANDLE, sname:VkMemoryAllocateInfo::pname:allocationSize must: equal the sname:VkMemoryRequirements::pname:size of the image * If pname:buffer is not sname:VK_NULL_HANDLE, sname:VkMemoryAllocateInfo::pname:allocationSize must: equal the sname:VkMemoryRequirements::pname:size of the buffer ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="image">pname:image is sname:VK_NULL_HANDLE or a handle of an image which this memory will be bound to.</member>
        <member name="buffer">pname:buffer is sname:VK_NULL_HANDLE or a handle of a buffer which this memory will be bound to.</member>
      </members>
    </type>
    <type name="VkDependencyFlagBits" summary="Bitmask specifying dependencies between subpasses.">
      <specification />
      <description>
        <para>Each subpass dependency defines an execution and memory dependency between two sets of commands, with the second set depending on the first set. When pname:srcSubpass does not equal pname:dstSubpass then the first set of commands is:</para>
        <para>* All commands in the subpass indicated by pname:srcSubpass, if pname:srcSubpass is not ename:VK_SUBPASS_EXTERNAL. * All commands before the render pass instance, if pname:srcSubpass is ename:VK_SUBPASS_EXTERNAL.</para>
        <para>While the corresponding second set of commands is:</para>
        <para>* All commands in the subpass indicated by pname:dstSubpass, if pname:dstSubpass is not ename:VK_SUBPASS_EXTERNAL. * All commands after the render pass instance, if pname:dstSubpass is ename:VK_SUBPASS_EXTERNAL.</para>
        <para>When pname:srcSubpass equals pname:dstSubpass then the first set consists of commands in the subpass before a call to flink:vkCmdPipelineBarrier and the second set consists of commands in the subpass following that same call as described in the &lt;&lt;synchronization-pipeline-barriers-subpass-self-dependencies, Subpass Self-dependency&gt;&gt; section.</para>
        <para>The pname:srcStageMask, pname:dstStageMask, pname:srcAccessMask, pname:dstAccessMask, and pname:dependencyFlags parameters of the dependency are interpreted the same way as for other dependencies, as described in &lt;&lt;synchronization, Synchronization and Cache Control&gt;&gt;.</para>
        <para>.Valid Usage **** * If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:srcStageMask must: not contain ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT * If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:dstStageMask must: not contain ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT * If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:srcStageMask must: not contain ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT * If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:dstStageMask must: not contain ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT * pname:srcSubpass must: be less than or equal to pname:dstSubpass, unless one of them is ename:VK_SUBPASS_EXTERNAL, to avoid cyclic dependencies and ensure a valid execution order * pname:srcSubpass and pname:dstSubpass must: not both be equal to ename:VK_SUBPASS_EXTERNAL * If pname:srcSubpass is equal to pname:dstSubpass, pname:srcStageMask and pname:dstStageMask must: only contain one of ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT, ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT, ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT, ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT, ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, or ename:VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT * If pname:srcSubpass is equal to pname:dstSubpass, the highest bit value included in pname:srcStageMask must: be less than or equal to the lowest bit value in pname:dstStageMask ****</para>
      </description>
      <members />
    </type>
    <type name="VkDescriptorBufferInfo" summary="Structure specifying descriptor buffer info.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:offset must: be less than the size of pname:buffer * If pname:range is not equal to ename:VK_WHOLE_SIZE, pname:range must: be greater than `0` * If pname:range is not equal to ename:VK_WHOLE_SIZE, pname:range must: be less than or equal to the size of pname:buffer minus pname:offset ****</para>
      </description>
      <members>
        <member name="buffer">pname:buffer is the buffer resource.</member>
        <member name="offset">pname:offset is the offset in bytes from the start of pname:buffer. Access to buffer memory via this descriptor uses addressing that is relative to this starting offset.</member>
        <member name="range">pname:range is the size in bytes that is used for this descriptor update, or ename:VK_WHOLE_SIZE to use the range from pname:offset to the end of the buffer. + -- [NOTE] .Note ==== When using ename:VK_WHOLE_SIZE, the effective range must: not be larger than the maximum range for the descriptor type (&lt;&lt;features-limits-maxUniformBufferRange, maxUniformBufferRange&gt;&gt; or &lt;&lt;features-limits-maxStorageBufferRange, maxStorageBufferRange&gt;&gt;). This means that ename:VK_WHOLE_SIZE is not typically useful in the common case where uniform buffer descriptors are suballocated from a buffer that is much larger than pname:maxUniformBufferRange. ==== -- + For ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC and ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC descriptor types, pname:offset is the base offset from which the dynamic offset is applied and pname:range is the static size used for all dynamic offsets.</member>
      </members>
    </type>
    <type name="VkDescriptorImageInfo" summary="Structure specifying descriptor image info.">
      <specification />
      <description>
        <para>Members of sname:VkDescriptorImageInfo that are not used in an update (as described above) are ignored.</para>
      </description>
      <members>
        <member name="sampler">pname:sampler is a sampler handle, and is used in descriptor updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLER and ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER if the binding being updated does not use immutable samplers.</member>
        <member name="imageView">pname:imageView is an image view handle, and is used in descriptor updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.</member>
        <member name="imageLayout">pname:imageLayout is the layout that the image will be in at the time this descriptor is accessed. pname:imageLayout is used in descriptor updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.</member>
      </members>
    </type>
    <type name="VkDescriptorPool" summary="Opaque handle to a descriptor pool object.">
      <specification>
        <para>A _descriptor pool_ maintains a pool of descriptors, from which descriptor sets are allocated. Descriptor pools are externally synchronized, meaning that the application must: not allocate and/or free descriptor sets from the same pool in multiple threads simultaneously.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkDescriptorPoolCreateFlagBits" summary="Bitmask specifying certain supported operations on a descriptor pool.">
      <specification />
      <description>
        <para>If multiple sname:VkDescriptorPoolSize structures appear in the pname:pPoolSizes array then the pool will be created with enough storage for the total number of descriptors of each type.</para>
        <para>Fragmentation of a descriptor pool is possible and may: lead to descriptor set allocation failures. A failure due to fragmentation is defined as failing a descriptor set allocation despite the sum of all outstanding descriptor set allocations from the pool plus the requested allocation requiring no more than the total number of descriptors requested at pool creation. Implementations provide certain guarantees of when fragmentation must: not cause allocation failure, as described below.</para>
        <para>If a descriptor pool has not had any descriptor sets freed since it was created or most recently reset then fragmentation must: not cause an allocation failure (note that this is always the case for a pool created without the ename:VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT bit set). Additionally, if all sets allocated from the pool since it was created or most recently reset use the same number of descriptors (of each type) and the requested allocation also uses that same number of descriptors (of each type), then fragmentation must: not cause an allocation failure.</para>
        <para>If an allocation failure occurs due to fragmentation, an application can: create an additional descriptor pool to perform further descriptor set allocations.</para>
        <para>.Valid Usage **** * pname:maxSets must: be greater than `0` ****</para>
      </description>
      <members />
    </type>
    <type name="VkDescriptorPoolCreateInfo" summary="Structure specifying parameters of a newly created descriptor pool.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags specifies certain supported operations on the pool. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkDescriptorPoolSize" summary="Structure specifying descriptor pool size.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:descriptorCount must: be greater than `0` ****</para>
      </description>
      <members>
        <member name="type">pname:type is the type of descriptor.</member>
        <member name="descriptorCount">pname:descriptorCount is the number of descriptors of that type to allocate.</member>
      </members>
    </type>
    <type name="VkDescriptorSet" summary="Opaque handle to a descriptor set object.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkDescriptorSetAllocateInfo" summary="Structure specifying the allocation parameters for descriptor sets.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:descriptorSetCount must: not be greater than the number of sets that are currently available for allocation in pname:descriptorPool * pname:descriptorPool must: have enough free descriptor capacity remaining to allocate the descriptor sets of the specified layouts ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="descriptorPool">pname:descriptorPool is the pool which the sets will be allocated from.</member>
        <member name="descriptorSetCount">pname:descriptorSetCount determines the number of descriptor sets to be allocated from the pool.</member>
        <member name="pSetLayouts">pname:pSetLayouts is an array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated.</member>
      </members>
    </type>
    <type name="VkDescriptorSetLayout" summary="Opaque handle to a descriptor set layout object.">
      <specification>
        <para>A descriptor set layout object is defined by an array of zero or more descriptor bindings. Each individual descriptor binding is specified by a descriptor type, a count (array size) of the number of descriptors in the binding, a set of shader stages that can: access the binding, and (if using immutable samplers) an array of sampler descriptors.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkDescriptorSetLayoutBinding" summary="Structure specifying a descriptor set layout binding.">
      <specification />
      <description>
        <para>The above layout definition allows the descriptor bindings to be specified sparsely such that not all binding numbers between 0 and the maximum binding number need to be specified in the pname:pBindings array. However, all binding numbers between 0 and the maximum binding number may: consume memory in the descriptor set layout even if not all descriptor bindings are used, though it should: not consume additional memory from the descriptor pool.</para>
        <para>[NOTE] .Note ==== The maximum binding number specified should: be as compact as possible to avoid wasted memory. ====</para>
        <para>.Valid Usage **** * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and pname:descriptorCount is not `0` and pname:pImmutableSamplers is not `NULL`, pname:pImmutableSamplers must: be a pointer to an array of pname:descriptorCount valid sname:VkSampler handles * If pname:descriptorCount is not `0`, pname:stageFlags must: be a valid combination of elink:VkShaderStageFlagBits values ****</para>
      </description>
      <members>
        <member name="binding">pname:binding is the binding number of this entry and corresponds to a resource of the same binding number in the shader stages.</member>
        <member name="descriptorType">pname:descriptorType is a elink:VkDescriptorType specifying which type of resource descriptors are used for this binding.</member>
        <member name="descriptorCount">pname:descriptorCount is the number of descriptors contained in the binding, accessed in a shader as an array. If pname:descriptorCount is zero this binding entry is reserved and the resource must: not be accessed from any stage via this binding within any pipeline using the set layout.</member>
        <member name="stageFlags">pname:stageFlags member is a bitmask of elink:VkShaderStageFlagBits specifying which pipeline shader stages can: access a resource for this binding. ename:VK_SHADER_STAGE_ALL is a shorthand specifying that all defined shader stages, including any additional stages defined by extensions, can: access the resource. + -- If a shader stage is not included in pname:stageFlags, then a resource must: not be accessed from that stage via this binding within any pipeline using the set layout. There are no limitations on what combinations of stages can: be used by a descriptor binding, and in particular a binding can: be used by both graphics stages and the compute stage. --</member>
        <member name="pImmutableSamplers">pname:pImmutableSamplers affects initialization of samplers. If pname:descriptorType specifies a ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER type descriptor, then pname:pImmutableSamplers can: be used to initialize a set of _immutable samplers_. Immutable samplers are permanently bound into the set layout; later binding a sampler into an immutable sampler slot in a descriptor set is not allowed. If pname:pImmutableSamplers is not `NULL`, then it is considered to be a pointer to an array of sampler handles that will be consumed by the set layout and used for the corresponding binding. If pname:pImmutableSamplers is `NULL`, then the sampler slots are dynamic and sampler handles must: be bound into descriptor sets using this layout. If pname:descriptorType is not one of these descriptor types, then pname:pImmutableSamplers is ignored.</member>
      </members>
    </type>
    <type name="VkDescriptorSetLayoutCreateInfo" summary="Structure specifying parameters of a newly created descriptor set layout.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="bindingCount">pname:bindingCount is the number of elements in pname:pBindings.</member>
        <member name="pBindings">pname:pBindings is a pointer to an array of slink:VkDescriptorSetLayoutBinding structures.</member>
      </members>
    </type>
    <type name="VkDescriptorType" summary="Specifies the type of a descriptor in a descriptor set.">
      <specification />
      <description>
        <para>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the elements of the slink:VkWriteDescriptorSet::pname:pBufferInfo array of slink:VkDescriptorBufferInfo structures will be used to update the descriptors, and other arrays will be ignored.</para>
        <para>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, the slink:VkWriteDescriptorSet::pname:pTexelBufferView array will be used to update the descriptors, and other arrays will be ignored.</para>
        <para>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the elements of the slink:VkWriteDescriptorSet::pname:pImageInfo array of slink:VkDescriptorImageInfo structures will be used to update the descriptors, and other arrays will be ignored.</para>
      </description>
      <members />
    </type>
    <type name="VkDevice" summary="Opaque handle to a device object.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkDeviceCreateInfo" summary="Structure specifying parameters of a newly created device.">
      <specification />
      <description>
        <para>.Valid Usage **** * The pname:queueFamilyIndex member of any given element of pname:pQueueCreateInfos must: be unique within pname:pQueueCreateInfos ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="queueCreateInfoCount">pname:queueCreateInfoCount is the unsigned integer size of the pname:pQueueCreateInfos array. Refer to the &lt;&lt;devsandqueues-queue-creation,Queue Creation&gt;&gt; section below for further details.</member>
        <member name="pQueueCreateInfos">pname:pQueueCreateInfos is a pointer to an array of slink:VkDeviceQueueCreateInfo structures describing the queues that are requested to be created along with the logical device. Refer to the &lt;&lt;devsandqueues-queue-creation,Queue Creation&gt;&gt; section below for further details.</member>
        <member name="enabledLayerCount">pname:enabledLayerCount is deprecated and ignored.</member>
        <member name="ppEnabledLayerNames">pname:ppEnabledLayerNames is deprecated and ignored. See &lt;&lt;extended-functionality-device-layer-deprecation,Device Layer Deprecation&gt;&gt;.</member>
        <member name="enabledExtensionCount">pname:enabledExtensionCount is the number of device extensions to enable.</member>
        <member name="ppEnabledExtensionNames">pname:ppEnabledExtensionNames is a pointer to an array of pname:enabledExtensionCount null-terminated UTF-8 strings containing the names of extensions to enable for the created device. See the &lt;&lt;extended-functionality-extensions,Extensions&gt;&gt; section for further details.</member>
        <member name="pEnabledFeatures">pname:pEnabledFeatures is `NULL` or a pointer to a slink:VkPhysicalDeviceFeatures structure that contains boolean indicators of all the features to be enabled. Refer to the &lt;&lt;features-features,Features&gt;&gt; section for further details.</member>
      </members>
    </type>
    <type name="VkDeviceMemory" summary="Opaque handle to a device memory object.">
      <specification>
        <para>A Vulkan device operates on data in device memory via memory objects that are represented in the API by a sname:VkDeviceMemory handle.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkDeviceQueueCreateInfo" summary="Structure specifying parameters of a newly created device queue.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:queueFamilyIndex must: be less than pname:pQueueFamilyPropertyCount returned by fname:vkGetPhysicalDeviceQueueFamilyProperties * pname:queueCount must: be less than or equal to the pname:queueCount member of the sname:VkQueueFamilyProperties structure, as returned by fname:vkGetPhysicalDeviceQueueFamilyProperties in the pname:pQueueFamilyProperties[pname:queueFamilyIndex] * Each element of pname:pQueuePriorities must: be between `0.0` and `1.0` inclusive ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="queueFamilyIndex">pname:queueFamilyIndex is an unsigned integer indicating the index of the queue family to create on this device. This index corresponds to the index of an element of the pname:pQueueFamilyProperties array that was returned by fname:vkGetPhysicalDeviceQueueFamilyProperties.</member>
        <member name="queueCount">pname:queueCount is an unsigned integer specifying the number of queues to create in the queue family indicated by pname:queueFamilyIndex.</member>
        <member name="pQueuePriorities">pname:pQueuePriorities is an array of pname:queueCount normalized floating point values, specifying priorities of work that will be submitted to each created queue. See &lt;&lt;devsandqueues-priority,Queue Priority&gt;&gt; for more information.</member>
      </members>
    </type>
    <type name="VkDeviceSize" summary="Vulkan device memory size and offsets.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkDispatchIndirectCommand" summary="Structure specifying a dispatch indirect command.">
      <specification />
      <description>
        <para>The members of sname:VkDispatchIndirectCommand structure have the same meaning as the similarly named parameters of flink:vkCmdDispatch.</para>
        <para>.Valid Usage **** * pname:x must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[0] * pname:y must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[1] * pname:z must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[2] ****</para>
      </description>
      <members>
        <member name="x">pname:x is the number of local workgroups to dispatch in the X dimension.</member>
        <member name="y">pname:y is the number of local workgroups to dispatch in the Y dimension.</member>
        <member name="z">pname:z is the number of local workgroups to dispatch in the Z dimension.</member>
      </members>
    </type>
    <type name="VkDisplayModeCreateInfoKHR" summary="Structure specifying parameters of a newly created display mode object.">
      <specification />
      <description>
        <para>.Valid Usage **** * The pname:width and pname:height members of the pname:visibleRegion member of pname:parameters must: be greater than `0` * The pname:refreshRate member of pname:parameters must: be greater than `0` ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use, and must: be zero.</member>
        <member name="parameters">pname:parameters is a sname:VkDisplayModeParametersKHR structure describing the display parameters to use in creating the new mode. If the parameters are not compatible with the specified display, the implementation must: return ename:VK_ERROR_INITIALIZATION_FAILED.</member>
      </members>
    </type>
    <type name="VkDisplayModeParametersKHR" summary="Structure describing display parameters associated with a display mode.">
      <specification />
      <description>
        <para>[NOTE] .Note ==== For example, a 60Hz display mode would report a pname:refreshRate of 60,000. ====</para>
      </description>
      <members>
        <member name="visibleRegion">pname:visibleRegion is the 2D extents of the visible region.</member>
        <member name="refreshRate">pname:refreshRate is a code:uint32_t that is the number of times the display is refreshed each second multiplied by 1000.</member>
      </members>
    </type>
    <type name="VkDisplayModePropertiesKHR" summary="Structure describing display mode properties.">
      <specification />
      <description />
      <members>
        <member name="displayMode">pname:displayMode is a handle to the display mode described in this structure. This handle will be valid for the lifetime of the Vulkan instance.</member>
        <member name="parameters">pname:parameters is a sname:VkDisplayModeParametersKHR structure describing the display parameters associated with pname:displayMode.</member>
      </members>
    </type>
    <type name="VkDisplayPlaneAlphaFlagBitsKHR" summary="Alpha blending type.">
      <specification />
      <description />
      <members>
        <member name="VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR">ename:VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR: The source image will be treated as opaque.</member>
        <member name="VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR">ename:VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR: A global alpha value must: be specified that will be applied to all pixels in the source image.</member>
        <member name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR">ename:VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR: The alpha value will be determined by the alpha channel of the source image's pixels. If the source format contains no alpha values, no blending will be applied. The source alpha values are not premultiplied into the source image's other color channels.</member>
        <member name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR">ename:VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR: This is equivalent to ename:VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR except the source alpha values are assumed to be premultiplied into the source image's other color channels.</member>
      </members>
    </type>
    <type name="VkDisplayPlaneCapabilitiesKHR" summary="Structure describing capabilities of a mode and plane combination.">
      <specification />
      <description>
        <para>The minimum and maximum position and extent fields describe the hardware limits, if any, as they apply to the specified display mode and plane. Vendors may: support displaying a subset of a swapchain's presentable images on the specified display plane. This is expressed by returning pname:minSrcPosition, pname:maxSrcPosition, pname:minSrcExtent, and pname:maxSrcExtent values that indicate a range of possible positions and sizes may: be used to specify the region within the presentable images that source pixels will be read from when creating a swapchain on the specified display mode and plane.</para>
        <para>Vendors may: also support mapping the presentable images' content to a subset or superset of the visible region in the specified display mode. This is expressed by returning pname:minDstPosition, pname:maxDstPosition, pname:minDstExtent and pname:maxDstExtent values that indicate a range of possible positions and sizes may: be used to describe the region within the display mode that the source pixels will be mapped to.</para>
        <para>Other vendors may: support only a 1-1 mapping between pixels in the presentable images and the display mode. This may: be indicated by returning [eq]#(0,0)# for pname:minSrcPosition, pname:maxSrcPosition, pname:minDstPosition, and pname:maxDstPosition, and (display mode width, display mode height) for pname:minSrcExtent, pname:maxSrcExtent, pname:minDstExtent, and pname:maxDstExtent.</para>
        <para>These values indicate the limits of the hardware's individual fields. Not all combinations of values within the offset and extent ranges returned in sname:VkDisplayPlaneCapabilitiesKHR are guaranteed to be supported. Vendors may: still fail presentation requests that specify unsupported combinations.</para>
      </description>
      <members>
        <member name="supportedAlpha">pname:supportedAlpha is a bitmask of elink:VkDisplayPlaneAlphaFlagBitsKHR describing the supported alpha blending modes.</member>
        <member name="minSrcPosition">pname:minSrcPosition is the minimum source rectangle offset supported by this plane using the specified mode.</member>
        <member name="maxSrcPosition">pname:maxSrcPosition is the maximum source rectangle offset supported by this plane using the specified mode. The pname:x and pname:y components of pname:maxSrcPosition must: each be greater than or equal to the pname:x and pname:y components of pname:minSrcPosition, respectively.</member>
        <member name="minSrcExtent">pname:minSrcExtent is the minimum source rectangle size supported by this plane using the specified mode.</member>
        <member name="maxSrcExtent">pname:maxSrcExtent is the maximum source rectangle size supported by this plane using the specified mode.</member>
        <member name="minDstPosition">pname:minDstPosition, pname:maxDstPosition, pname:minDstExtent, pname:maxDstExtent all have similar semantics to their corresponding "Src" equivalents, but apply to the output region within the mode rather than the input region within the source image. Unlike the "Src" offsets, pname:minDstPosition and pname:maxDstPosition may: contain negative values.</member>
      </members>
    </type>
    <type name="VkDisplayPlanePropertiesKHR" summary="Structure describing display plane properties.">
      <specification />
      <description />
      <members>
        <member name="currentDisplay">pname:currentDisplay is the handle of the display the plane is currently associated with. If the plane is not currently attached to any displays, this will be sname:VK_NULL_HANDLE.</member>
        <member name="currentStackIndex">pname:currentStackIndex is the current z-order of the plane. This will be between 0 and the value returned by fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pname:pPropertyCount.</member>
      </members>
    </type>
    <type name="VkDisplayPresentInfoKHR" summary="Structure describing parameters of a queue presentation to a swapchain.">
      <specification />
      <description>
        <para>If the extent of the pname:srcRect and pname:dstRect are not equal, the presented pixels will be scaled accordingly.</para>
        <para>.Valid Usage **** * pname:srcRect must: specify a rectangular region that is a subset of the image being presented * pname:dstRect must: specify a rectangular region that is a subset of the pname:visibleRegion parameter of the display mode the swapchain being presented uses * If the pname:persistentContent member of the sname:VkDisplayPropertiesKHR structure returned by fname:vkGetPhysicalDeviceDisplayPropertiesKHR for the display the present operation targets then pname:persistent must: be ename:VK_FALSE ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="srcRect">pname:srcRect is a rectangular region of pixels to present. It must: be a subset of the image being presented. If sname:VkDisplayPresentInfoKHR is not specified, this region will be assumed to be the entire presentable image.</member>
        <member name="dstRect">pname:dstRect is a rectangular region within the visible region of the swapchain's display mode. If sname:VkDisplayPresentInfoKHR is not specified, this region will be assumed to be the entire visible region of the visible region of the swapchain's mode. If the specified rectangle is a subset of the display mode's visible region, content from display planes below the swapchain's plane will be visible outside the rectangle. If there are no planes below the swapchain's, the area outside the specified rectangle will be black. If portions of the specified rectangle are outside of the display's visible region, pixels mapping only to those portions of the rectangle will be discarded.</member>
        <member name="persistent">pname:persistent: If this is ename:VK_TRUE, the display engine will enable buffered mode on displays that support it. This allows the display engine to stop sending content to the display until a new image is presented. The display will instead maintain a copy of the last presented image. This allows less power to be used, but may: increase presentation latency. If sname:VkDisplayPresentInfoKHR is not specified, persistent mode will not be used.</member>
      </members>
    </type>
    <type name="VkDisplayPropertiesKHR" summary="Structure describing an available display device.">
      <specification />
      <description>
        <para>[NOTE] .Note ==== For devices which have no natural value to return here, implementations should: return the maximum resolution supported. ====</para>
        <para>* pname:supportedTransforms tells which transforms are supported by this display. This will contain one or more of the bits from sname:VkSurfaceTransformFlagsKHR. * pname:planeReorderPossible tells whether the planes on this display can: have their z order changed. If this is ename:VK_TRUE, the application can: re-arrange the planes on this display in any order relative to each other. * pname:persistentContent tells whether the display supports self-refresh/internal buffering. If this is true, the application can: submit persistent present operations on swapchains created against this display.</para>
        <para>[NOTE] .Note ==== Persistent presents may: have higher latency, and may: use less power when the screen content is updated infrequently, or when only a portion of the screen needs to be updated in most frames. ====</para>
      </description>
      <members>
        <member name="display">pname:display is a handle that is used to refer to the display described here. This handle will be valid for the lifetime of the Vulkan instance.</member>
        <member name="displayName">pname:displayName is a pointer to a NULL-terminated string containing the name of the display. Generally, this will be the name provided by the display's EDID. It can: be `NULL` if no suitable name is available.</member>
        <member name="physicalDimensions">pname:physicalDimensions describes the physical width and height of the visible portion of the display, in millimeters.</member>
        <member name="physicalResolution">pname:physicalResolution describes the physical, native, or preferred resolution of the display.</member>
      </members>
    </type>
    <type name="VkDisplaySurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created display plane surface object.">
      <specification />
      <description>
        <para>[NOTE] .Note ==== Creating a display surface must: not modify the state of the displays, planes, or other resources it names. For example, it must: not apply the specified mode to be set on the associated display. Application of display configuration occurs as a side effect of presenting to a display surface. ====</para>
        <para>.Valid Usage **** * pname:planeIndex must: be less than the number of display planes supported by the device as determined by calling fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR * If the pname:planeReorderPossible member of the sname:VkDisplayPropertiesKHR structure returned by fname:vkGetPhysicalDeviceDisplayPropertiesKHR for the display corresponding to pname:displayMode is ename:VK_TRUE then pname:planeStackIndex must: be less than the number of display planes supported by the device as determined by calling fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR; otherwise pname:planeStackIndex must: equal the pname:currentStackIndex member of sname:VkDisplayPlanePropertiesKHR returned by fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR for the display plane corresponding to pname:displayMode * If pname:alphaMode is ename:VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR then pname:globalAlpha must: be between `0` and `1`, inclusive * pname:alphaMode must: be `0` or one of the bits present in the pname:supportedAlpha member of sname:VkDisplayPlaneCapabilitiesKHR returned by fname:vkGetDisplayPlaneCapabilitiesKHR for the display plane corresponding to pname:displayMode * The pname:width and pname:height members of pname:imageExtent must: be less than the pname:maxImageDimensions2D member of sname:VkPhysicalDeviceLimits ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use, and must: be zero.</member>
        <member name="displayMode">pname:displayMode is the mode to use when displaying this surface.</member>
        <member name="planeIndex">pname:planeIndex is the plane on which this surface appears.</member>
        <member name="planeStackIndex">pname:planeStackIndex is the z-order of the plane.</member>
        <member name="transform">pname:transform is the transform to apply to the images as part of the scanout operation.</member>
        <member name="globalAlpha">pname:globalAlpha is the global alpha value. This value is ignored if pname:alphaMode is not ename:VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR.</member>
        <member name="alphaMode">pname:alphaMode is the type of alpha blending to use.</member>
        <member name="imageSize">pname:imageSize The size of the presentable images to use with the surface.</member>
      </members>
    </type>
    <type name="VkDrawIndexedIndirectCommand" summary="Structure specifying a draw indexed indirect command.">
      <specification />
      <description>
        <para>The members of sname:VkDrawIndexedIndirectCommand have the same meaning as the similarly named parameters of flink:vkCmdDrawIndexed.</para>
        <para>.Valid Usage **** * For a given vertex buffer binding, any attribute data fetched must: be entirely contained within the corresponding vertex buffer binding, as described in &lt;&lt;fxvertex-input&gt;&gt; * (pname:indexSize * (pname:firstIndex + pname:indexCount) + pname:offset) must: be less than or equal to the size of the currently bound index buffer, with pname:indexSize being based on the type specified by pname:indexType, where the index buffer, pname:indexType, and pname:offset are specified via fname:vkCmdBindIndexBuffer * If the &lt;&lt;features-features-drawIndirectFirstInstance,drawIndirectFirstInstance&gt;&gt; feature is not enabled, pname:firstInstance must: be code:0 ****</para>
      </description>
      <members>
        <member name="indexCount">pname:indexCount is the number of vertices to draw.</member>
        <member name="instanceCount">pname:instanceCount is the number of instances to draw.</member>
        <member name="firstIndex">pname:firstIndex is the base index within the index buffer.</member>
        <member name="vertexOffset">pname:vertexOffset is the value added to the vertex index before indexing into the vertex buffer.</member>
        <member name="firstInstance">pname:firstInstance is the instance ID of the first instance to draw.</member>
      </members>
    </type>
    <type name="VkDrawIndirectCommand" summary="Structure specifying a draw indirect command.">
      <specification />
      <description>
        <para>The members of sname:VkDrawIndirectCommand have the same meaning as the similarly named parameters of flink:vkCmdDraw.</para>
        <para>.Valid Usage **** * For a given vertex buffer binding, any attribute data fetched must: be entirely contained within the corresponding vertex buffer binding, as described in &lt;&lt;fxvertex-input&gt;&gt; * If the &lt;&lt;features-features-drawIndirectFirstInstance,drawIndirectFirstInstance&gt;&gt; feature is not enabled, pname:firstInstance must: be code:0 ****</para>
      </description>
      <members>
        <member name="vertexCount">pname:vertexCount is the number of vertices to draw.</member>
        <member name="instanceCount">pname:instanceCount is the number of instances to draw.</member>
        <member name="firstVertex">pname:firstVertex is the index of the first vertex to draw.</member>
        <member name="firstInstance">pname:firstInstance is the instance ID of the first instance to draw.</member>
      </members>
    </type>
    <type name="VkDynamicState" summary="Indicate which dynamic state is taken from dynamic state commands.">
      <specification />
      <description />
      <members>
        <member name="VK_DYNAMIC_STATE_VIEWPORT">ename:VK_DYNAMIC_STATE_VIEWPORT indicates that the pname:pViewports state in sname:VkPipelineViewportStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetViewport before any draw commands. The number of viewports used by a pipeline is still specified by the pname:viewportCount member of sname:VkPipelineViewportStateCreateInfo.</member>
        <member name="VK_DYNAMIC_STATE_SCISSOR">ename:VK_DYNAMIC_STATE_SCISSOR indicates that the pname:pScissors state in sname:VkPipelineViewportStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetScissor before any draw commands. The number of scissor rectangles used by a pipeline is still specified by the pname:scissorCount member of sname:VkPipelineViewportStateCreateInfo.</member>
        <member name="VK_DYNAMIC_STATE_LINE_WIDTH">ename:VK_DYNAMIC_STATE_LINE_WIDTH indicates that the pname:lineWidth state in sname:VkPipelineRasterizationStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetLineWidth before any draw commands that generate line primitives for the rasterizer.</member>
        <member name="VK_DYNAMIC_STATE_DEPTH_BIAS">ename:VK_DYNAMIC_STATE_DEPTH_BIAS indicates that the pname:depthBiasConstantFactor, pname:depthBiasClamp and pname:depthBiasSlopeFactor states in sname:VkPipelineRasterizationStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetDepthBias before any draws are performed with pname:depthBiasEnable in sname:VkPipelineRasterizationStateCreateInfo set to ename:VK_TRUE.</member>
        <member name="VK_DYNAMIC_STATE_BLEND_CONSTANTS">ename:VK_DYNAMIC_STATE_BLEND_CONSTANTS indicates that the pname:blendConstants state in sname:VkPipelineColorBlendStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetBlendConstants before any draws are performed with a pipeline state with sname:VkPipelineColorBlendAttachmentState member pname:blendEnable set to ename:VK_TRUE and any of the blend functions using a constant blend color.</member>
        <member name="VK_DYNAMIC_STATE_DEPTH_BOUNDS">ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS indicates that the pname:minDepthBounds and pname:maxDepthBounds states of slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetDepthBounds before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:depthBoundsTestEnable set to ename:VK_TRUE.</member>
        <member name="VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK">ename:VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK indicates that the pname:compareMask state in sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and pname:back will be ignored and must: be set dynamically with flink:vkCmdSetStencilCompareMask before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:stencilTestEnable set to ename:VK_TRUE</member>
        <member name="VK_DYNAMIC_STATE_STENCIL_WRITE_MASK">ename:VK_DYNAMIC_STATE_STENCIL_WRITE_MASK indicates that the pname:writeMask state in sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and pname:back will be ignored and must: be set dynamically with flink:vkCmdSetStencilWriteMask before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:stencilTestEnable set to ename:VK_TRUE</member>
        <member name="VK_DYNAMIC_STATE_STENCIL_REFERENCE">ename:VK_DYNAMIC_STATE_STENCIL_REFERENCE indicates that the pname:reference state in sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and pname:back will be ignored and must: be set dynamically with flink:vkCmdSetStencilReference before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:stencilTestEnable set to ename:VK_TRUE</member>
      </members>
    </type>
    <type name="VkEvent" summary="Opaque handle to a event object.">
      <specification>
        <para>Events represent a fine-grained synchronization primitive that can: be used to gauge progress through a sequence of commands executed on a queue by Vulkan. An event is initially in the unsignaled state. It can: be signaled by a device, using commands inserted into the command buffer, or by the host. It can: also be reset to the unsignaled state by a device or the host. The host can: query the state of an event. A device can: wait for one or more events to become signaled.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkEventCreateInfo" summary="Structure specifying parameters of a newly created event.">
      <specification />
      <description />
      <members>
        <member name="flags">pname:flags is reserved for future use.</member>
      </members>
    </type>
    <type name="VkExportMemoryWin32HandleInfoNV" summary="Specify security attributes and access rights for Win32 memory handles.">
      <specification>
        <para>When slink:VkExportMemoryAllocateInfoNV::pname:handleTypes includes ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV, add a sname:VkExportMemoryWin32HandleInfoNV to the pname:pNext chain of the slink:VkExportMemoryAllocateInfoNV structure to specify security attributes and access rights for the memory object's external handle.</para>
      </specification>
      <description>
        <para>If this structure is not present, or if pname:pAttributes is set to `NULL`, default security descriptor values will be used, and child processes created by the application will not inherit the handle, as described in the MSDN documentation for ``Synchronization Object Security and Access Rights''[1]. Further, if the structure is not present, the access rights will be</para>
        <para>code:DXGI_SHARED_RESOURCE_READ | code:DXGI_SHARED_RESOURCE_WRITE</para>
        <para>[1] https://msdn.microsoft.com/en-us/library/windows/desktop/ms686670.aspx</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="pAttributes">pname:pAttributes is a pointer to a Windows code:SECURITY_ATTRIBUTES structure specifying security attributes of the handle.</member>
        <member name="dwAccess">pname:dwAccess is a code:DWORD specifying access rights of the handle.</member>
      </members>
    </type>
    <type name="VkExtensionProperties" summary="Structure specifying a extension properties.">
      <specification />
      <description />
      <members>
        <member name="extensionName">pname:extensionName is a null-terminated string specifying the name of the extension.</member>
        <member name="specVersion">pname:specVersion is the version of this extension. It is an integer, incremented with backward compatible changes.</member>
      </members>
    </type>
    <type name="VkExtent2D" summary="Structure specifying a two-dimensional extent.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkExtent3D" summary="Structure specifying a three-dimensional extent.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkExternalImageFormatPropertiesNV" summary="Structure specifying external image format properties.">
      <specification />
      <description />
      <members>
        <member name="imageFormatProperties">pname:imageFormatProperties will be filled in as when calling flink:vkGetPhysicalDeviceImageFormatProperties, but the values returned may: vary depending on the external handle type requested.</member>
        <member name="externalMemoryFeatures">pname:externalMemoryFeatures is a bitmask of elink:VkExternalMemoryFeatureFlagBitsNV indicating properties of the external memory handle type (flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType) being queried, or 0 if the external memory handle type is 0.</member>
        <member name="exportFromImportedHandleTypes">pname:exportFromImportedHandleTypes is a bitmask of elink:VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for every external handle type that may: be used to create memory from which the handles of the type specified in flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType can: be exported, or 0 if the external memory handle type is 0.</member>
        <member name="compatibleHandleTypes">pname:compatibleHandleTypes is a bitmask of elink:VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for every external handle type that may: be specified simultaneously with the handle type specified by flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType when calling flink:vkAllocateMemory, or 0 if the external memory handle type is 0. pname:compatibleHandleTypes will always contain flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType</member>
      </members>
    </type>
    <type name="VkExternalMemoryFeatureFlagBitsNV" summary="Bitmask specifying external memory features.">
      <specification />
      <description />
      <members>
        <member name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV">ename:VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV: External memory of the specified type must: be created as a dedicated allocation when used in the manner specified.</member>
        <member name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV">ename:VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV: The implementation supports exporting handles of the specified type.</member>
        <member name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV">ename:VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV: The implementation supports importing handles of the specified type.</member>
      </members>
    </type>
    <type name="VkExternalMemoryHandleTypeFlagBitsNV" summary="Bitmask specifying memory handle types.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkExternalMemoryImageCreateInfoNV" summary="Specify that an image may be backed by external memory.">
      <specification>
        <para>If the pname:pNext list includes a sname:VkExternalMemoryImageCreateInfoNV structure, then that structure defines a set of external memory handle types that may: be used as backing store for the image.</para>
      </specification>
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="handleTypes">pname:handleTypes is a bitmask of elink:VkExternalMemoryHandleTypeFlagBitsNV specifying one or more external memory handle types. The types must: all be compatible with each other and the other image creation parameters, as reported by flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV.</member>
      </members>
    </type>
    <type name="VkFence" summary="Opaque handle to a fence object.">
      <specification>
        <para>Fences can: be used by the host to determine completion of execution of _queue operations_.</para>
        <para>A fence's status is always either _signaled_ or _unsignaled_. The host can: poll the status of a single fence, or wait for any or all of a group of fences to become signaled.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkFenceCreateFlagBits" summary="Bitmask specifying initial state and behavior of a fence.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkFenceCreateInfo" summary="Structure specifying parameters of a newly created fence.">
      <specification />
      <description />
      <members>
        <member name="flags">pname:flags defines the initial state and behavior of the fence. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkFilter" summary="Specify filters used for texture lookups.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkFlags" summary="Vulkan bitmasks.">
      <specification />
      <description>
        <para>Bitmasks are passed to many commands and structures to compactly represent options, but basetype:VkFlags is not used directly in the API. Instead, a etext:Vk*Flags type which is an alias of basetype:VkFlags, and whose name matches the corresponding etext:Vk*FlagBits that are valid for that type, is used. These aliases are described in the &lt;&lt;boilerplate-flags,Flag Types&gt;&gt; appendix of the Specification.</para>
      </description>
      <members />
    </type>
    <type name="VkFormat" summary="Available image formats.">
      <specification />
      <description />
      <members>
        <member name="VK_FORMAT_UNDEFINED">ename:VK_FORMAT_UNDEFINED:: The format is not specified.</member>
        <member name="VK_FORMAT_R4G4_UNORM_PACK8">ename:VK_FORMAT_R4G4_UNORM_PACK8:: A two-component, 8-bit packed unsigned normalized format that has a 4-bit R component in bits 4..7, and a 4-bit G component in bits 0..3.</member>
        <member name="VK_FORMAT_R4G4B4A4_UNORM_PACK16">ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 4-bit R component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit B component in bits 4..7, and a 4-bit A component in bits 0..3.</member>
        <member name="VK_FORMAT_B4G4R4A4_UNORM_PACK16">ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 4-bit B component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit R component in bits 4..7, and a 4-bit A component in bits 0..3.</member>
        <member name="VK_FORMAT_R5G6B5_UNORM_PACK16">ename:VK_FORMAT_R5G6B5_UNORM_PACK16:: A three-component, 16-bit packed unsigned normalized format that has a 5-bit R component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit B component in bits 0..4.</member>
        <member name="VK_FORMAT_B5G6R5_UNORM_PACK16">ename:VK_FORMAT_B5G6R5_UNORM_PACK16:: A three-component, 16-bit packed unsigned normalized format that has a 5-bit B component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit R component in bits 0..4.</member>
        <member name="VK_FORMAT_R5G5B5A1_UNORM_PACK16">ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 5-bit R component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit B component in bits 1..5, and a 1-bit A component in bit 0.</member>
        <member name="VK_FORMAT_B5G5R5A1_UNORM_PACK16">ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 5-bit B component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit R component in bits 1..5, and a 1-bit A component in bit 0.</member>
        <member name="VK_FORMAT_A1R5G5B5_UNORM_PACK16">ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 1-bit A component in bit 15, a 5-bit R component in bits 10..14, a 5-bit G component in bits 5..9, and a 5-bit B component in bits 0..4.</member>
        <member name="VK_FORMAT_R8_UNORM">ename:VK_FORMAT_R8_UNORM:: A one-component, 8-bit unsigned normalized format that has a single 8-bit R component.</member>
        <member name="VK_FORMAT_R8_SNORM">ename:VK_FORMAT_R8_SNORM:: A one-component, 8-bit signed normalized format that has a single 8-bit R component.</member>
        <member name="VK_FORMAT_R8_USCALED">ename:VK_FORMAT_R8_USCALED:: A one-component, 8-bit unsigned scaled integer format that has a single 8-bit R component.</member>
        <member name="VK_FORMAT_R8_SSCALED">ename:VK_FORMAT_R8_SSCALED:: A one-component, 8-bit signed scaled integer format that has a single 8-bit R component.</member>
        <member name="VK_FORMAT_R8_UINT">ename:VK_FORMAT_R8_UINT:: A one-component, 8-bit unsigned integer format that has a single 8-bit R component.</member>
        <member name="VK_FORMAT_R8_SINT">ename:VK_FORMAT_R8_SINT:: A one-component, 8-bit signed integer format that has a single 8-bit R component.</member>
        <member name="VK_FORMAT_R8_SRGB">ename:VK_FORMAT_R8_SRGB:: A one-component, 8-bit unsigned normalized format that has a single 8-bit R component stored with sRGB nonlinear encoding.</member>
        <member name="VK_FORMAT_R8G8_UNORM">ename:VK_FORMAT_R8G8_UNORM:: A two-component, 16-bit unsigned normalized format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.</member>
        <member name="VK_FORMAT_R8G8_SNORM">ename:VK_FORMAT_R8G8_SNORM:: A two-component, 16-bit signed normalized format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.</member>
        <member name="VK_FORMAT_R8G8_USCALED">ename:VK_FORMAT_R8G8_USCALED:: A two-component, 16-bit unsigned scaled integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.</member>
        <member name="VK_FORMAT_R8G8_SSCALED">ename:VK_FORMAT_R8G8_SSCALED:: A two-component, 16-bit signed scaled integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.</member>
        <member name="VK_FORMAT_R8G8_UINT">ename:VK_FORMAT_R8G8_UINT:: A two-component, 16-bit unsigned integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.</member>
        <member name="VK_FORMAT_R8G8_SINT">ename:VK_FORMAT_R8G8_SINT:: A two-component, 16-bit signed integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.</member>
        <member name="VK_FORMAT_R8G8_SRGB">ename:VK_FORMAT_R8G8_SRGB:: A two-component, 16-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, and an 8-bit G component stored with sRGB nonlinear encoding in byte 1.</member>
        <member name="VK_FORMAT_R8G8B8_UNORM">ename:VK_FORMAT_R8G8B8_UNORM:: A three-component, 24-bit unsigned normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.</member>
        <member name="VK_FORMAT_R8G8B8_SNORM">ename:VK_FORMAT_R8G8B8_SNORM:: A three-component, 24-bit signed normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.</member>
        <member name="VK_FORMAT_R8G8B8_USCALED">ename:VK_FORMAT_R8G8B8_USCALED:: A three-component, 24-bit unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.</member>
        <member name="VK_FORMAT_R8G8B8_SSCALED">ename:VK_FORMAT_R8G8B8_SSCALED:: A three-component, 24-bit signed scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.</member>
        <member name="VK_FORMAT_R8G8B8_UINT">ename:VK_FORMAT_R8G8B8_UINT:: A three-component, 24-bit unsigned integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.</member>
        <member name="VK_FORMAT_R8G8B8_SINT">ename:VK_FORMAT_R8G8B8_SINT:: A three-component, 24-bit signed integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.</member>
        <member name="VK_FORMAT_R8G8B8_SRGB">ename:VK_FORMAT_R8G8B8_SRGB:: A three-component, 24-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and an 8-bit B component stored with sRGB nonlinear encoding in byte 2.</member>
        <member name="VK_FORMAT_B8G8R8_UNORM">ename:VK_FORMAT_B8G8R8_UNORM:: A three-component, 24-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.</member>
        <member name="VK_FORMAT_B8G8R8_SNORM">ename:VK_FORMAT_B8G8R8_SNORM:: A three-component, 24-bit signed normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.</member>
        <member name="VK_FORMAT_B8G8R8_USCALED">ename:VK_FORMAT_B8G8R8_USCALED:: A three-component, 24-bit unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.</member>
        <member name="VK_FORMAT_B8G8R8_SSCALED">ename:VK_FORMAT_B8G8R8_SSCALED:: A three-component, 24-bit signed scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.</member>
        <member name="VK_FORMAT_B8G8R8_UINT">ename:VK_FORMAT_B8G8R8_UINT:: A three-component, 24-bit unsigned integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.</member>
        <member name="VK_FORMAT_B8G8R8_SINT">ename:VK_FORMAT_B8G8R8_SINT:: A three-component, 24-bit signed integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.</member>
        <member name="VK_FORMAT_B8G8R8_SRGB">ename:VK_FORMAT_B8G8R8_SRGB:: A three-component, 24-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and an 8-bit R component stored with sRGB nonlinear encoding in byte 2.</member>
        <member name="VK_FORMAT_R8G8B8A8_UNORM">ename:VK_FORMAT_R8G8B8A8_UNORM:: A four-component, 32-bit unsigned normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_R8G8B8A8_SNORM">ename:VK_FORMAT_R8G8B8A8_SNORM:: A four-component, 32-bit signed normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_R8G8B8A8_USCALED">ename:VK_FORMAT_R8G8B8A8_USCALED:: A four-component, 32-bit unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_R8G8B8A8_SSCALED">ename:VK_FORMAT_R8G8B8A8_SSCALED:: A four-component, 32-bit signed scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_R8G8B8A8_UINT">ename:VK_FORMAT_R8G8B8A8_UINT:: A four-component, 32-bit unsigned integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_R8G8B8A8_SINT">ename:VK_FORMAT_R8G8B8A8_SINT:: A four-component, 32-bit signed integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_R8G8B8A8_SRGB">ename:VK_FORMAT_R8G8B8A8_SRGB:: A four-component, 32-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit B component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_B8G8R8A8_UNORM">ename:VK_FORMAT_B8G8R8A8_UNORM:: A four-component, 32-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_B8G8R8A8_SNORM">ename:VK_FORMAT_B8G8R8A8_SNORM:: A four-component, 32-bit signed normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_B8G8R8A8_USCALED">ename:VK_FORMAT_B8G8R8A8_USCALED:: A four-component, 32-bit unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_B8G8R8A8_SSCALED">ename:VK_FORMAT_B8G8R8A8_SSCALED:: A four-component, 32-bit signed scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_B8G8R8A8_UINT">ename:VK_FORMAT_B8G8R8A8_UINT:: A four-component, 32-bit unsigned integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_B8G8R8A8_SINT">ename:VK_FORMAT_B8G8R8A8_SINT:: A four-component, 32-bit signed integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_B8G8R8A8_SRGB">ename:VK_FORMAT_B8G8R8A8_SRGB:: A four-component, 32-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit R component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.</member>
        <member name="VK_FORMAT_A8B8G8R8_UNORM_PACK32">ename:VK_FORMAT_A8B8G8R8_UNORM_PACK32:: A four-component, 32-bit packed unsigned normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.</member>
        <member name="VK_FORMAT_A8B8G8R8_SNORM_PACK32">ename:VK_FORMAT_A8B8G8R8_SNORM_PACK32:: A four-component, 32-bit packed signed normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.</member>
        <member name="VK_FORMAT_A8B8G8R8_USCALED_PACK32">ename:VK_FORMAT_A8B8G8R8_USCALED_PACK32:: A four-component, 32-bit packed unsigned scaled integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.</member>
        <member name="VK_FORMAT_A8B8G8R8_SSCALED_PACK32">ename:VK_FORMAT_A8B8G8R8_SSCALED_PACK32:: A four-component, 32-bit packed signed scaled integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.</member>
        <member name="VK_FORMAT_A8B8G8R8_UINT_PACK32">ename:VK_FORMAT_A8B8G8R8_UINT_PACK32:: A four-component, 32-bit packed unsigned integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.</member>
        <member name="VK_FORMAT_A8B8G8R8_SINT_PACK32">ename:VK_FORMAT_A8B8G8R8_SINT_PACK32:: A four-component, 32-bit packed signed integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.</member>
        <member name="VK_FORMAT_A8B8G8R8_SRGB_PACK32">ename:VK_FORMAT_A8B8G8R8_SRGB_PACK32:: A four-component, 32-bit packed unsigned normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component stored with sRGB nonlinear encoding in bits 16..23, an 8-bit G component stored with sRGB nonlinear encoding in bits 8..15, and an 8-bit R component stored with sRGB nonlinear encoding in bits 0..7.</member>
        <member name="VK_FORMAT_A2R10G10B10_UNORM_PACK32">ename:VK_FORMAT_A2R10G10B10_UNORM_PACK32:: A four-component, 32-bit packed unsigned normalized format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.</member>
        <member name="VK_FORMAT_A2R10G10B10_SNORM_PACK32">ename:VK_FORMAT_A2R10G10B10_SNORM_PACK32:: A four-component, 32-bit packed signed normalized format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.</member>
        <member name="VK_FORMAT_A2R10G10B10_USCALED_PACK32">ename:VK_FORMAT_A2R10G10B10_USCALED_PACK32:: A four-component, 32-bit packed unsigned scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.</member>
        <member name="VK_FORMAT_A2R10G10B10_SSCALED_PACK32">ename:VK_FORMAT_A2R10G10B10_SSCALED_PACK32:: A four-component, 32-bit packed signed scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.</member>
        <member name="VK_FORMAT_A2R10G10B10_UINT_PACK32">ename:VK_FORMAT_A2R10G10B10_UINT_PACK32:: A four-component, 32-bit packed unsigned integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.</member>
        <member name="VK_FORMAT_A2R10G10B10_SINT_PACK32">ename:VK_FORMAT_A2R10G10B10_SINT_PACK32:: A four-component, 32-bit packed signed integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.</member>
        <member name="VK_FORMAT_A2B10G10R10_UNORM_PACK32">ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32:: A four-component, 32-bit packed unsigned normalized format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.</member>
        <member name="VK_FORMAT_A2B10G10R10_SNORM_PACK32">ename:VK_FORMAT_A2B10G10R10_SNORM_PACK32:: A four-component, 32-bit packed signed normalized format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.</member>
        <member name="VK_FORMAT_A2B10G10R10_USCALED_PACK32">ename:VK_FORMAT_A2B10G10R10_USCALED_PACK32:: A four-component, 32-bit packed unsigned scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.</member>
        <member name="VK_FORMAT_A2B10G10R10_SSCALED_PACK32">ename:VK_FORMAT_A2B10G10R10_SSCALED_PACK32:: A four-component, 32-bit packed signed scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.</member>
        <member name="VK_FORMAT_A2B10G10R10_UINT_PACK32">ename:VK_FORMAT_A2B10G10R10_UINT_PACK32:: A four-component, 32-bit packed unsigned integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.</member>
        <member name="VK_FORMAT_A2B10G10R10_SINT_PACK32">ename:VK_FORMAT_A2B10G10R10_SINT_PACK32:: A four-component, 32-bit packed signed integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.</member>
        <member name="VK_FORMAT_R16_UNORM">ename:VK_FORMAT_R16_UNORM:: A one-component, 16-bit unsigned normalized format that has a single 16-bit R component.</member>
        <member name="VK_FORMAT_R16_SNORM">ename:VK_FORMAT_R16_SNORM:: A one-component, 16-bit signed normalized format that has a single 16-bit R component.</member>
        <member name="VK_FORMAT_R16_USCALED">ename:VK_FORMAT_R16_USCALED:: A one-component, 16-bit unsigned scaled integer format that has a single 16-bit R component.</member>
        <member name="VK_FORMAT_R16_SSCALED">ename:VK_FORMAT_R16_SSCALED:: A one-component, 16-bit signed scaled integer format that has a single 16-bit R component.</member>
        <member name="VK_FORMAT_R16_UINT">ename:VK_FORMAT_R16_UINT:: A one-component, 16-bit unsigned integer format that has a single 16-bit R component.</member>
        <member name="VK_FORMAT_R16_SINT">ename:VK_FORMAT_R16_SINT:: A one-component, 16-bit signed integer format that has a single 16-bit R component.</member>
        <member name="VK_FORMAT_R16_SFLOAT">ename:VK_FORMAT_R16_SFLOAT:: A one-component, 16-bit signed floating-point format that has a single 16-bit R component.</member>
        <member name="VK_FORMAT_R16G16_UNORM">ename:VK_FORMAT_R16G16_UNORM:: A two-component, 32-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.</member>
        <member name="VK_FORMAT_R16G16_SNORM">ename:VK_FORMAT_R16G16_SNORM:: A two-component, 32-bit signed normalized format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.</member>
        <member name="VK_FORMAT_R16G16_USCALED">ename:VK_FORMAT_R16G16_USCALED:: A two-component, 32-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.</member>
        <member name="VK_FORMAT_R16G16_SSCALED">ename:VK_FORMAT_R16G16_SSCALED:: A two-component, 32-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.</member>
        <member name="VK_FORMAT_R16G16_UINT">ename:VK_FORMAT_R16G16_UINT:: A two-component, 32-bit unsigned integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.</member>
        <member name="VK_FORMAT_R16G16_SINT">ename:VK_FORMAT_R16G16_SINT:: A two-component, 32-bit signed integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.</member>
        <member name="VK_FORMAT_R16G16_SFLOAT">ename:VK_FORMAT_R16G16_SFLOAT:: A two-component, 32-bit signed floating-point format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.</member>
        <member name="VK_FORMAT_R16G16B16_UNORM">ename:VK_FORMAT_R16G16B16_UNORM:: A three-component, 48-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.</member>
        <member name="VK_FORMAT_R16G16B16_SNORM">ename:VK_FORMAT_R16G16B16_SNORM:: A three-component, 48-bit signed normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.</member>
        <member name="VK_FORMAT_R16G16B16_USCALED">ename:VK_FORMAT_R16G16B16_USCALED:: A three-component, 48-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.</member>
        <member name="VK_FORMAT_R16G16B16_SSCALED">ename:VK_FORMAT_R16G16B16_SSCALED:: A three-component, 48-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.</member>
        <member name="VK_FORMAT_R16G16B16_UINT">ename:VK_FORMAT_R16G16B16_UINT:: A three-component, 48-bit unsigned integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.</member>
        <member name="VK_FORMAT_R16G16B16_SINT">ename:VK_FORMAT_R16G16B16_SINT:: A three-component, 48-bit signed integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.</member>
        <member name="VK_FORMAT_R16G16B16_SFLOAT">ename:VK_FORMAT_R16G16B16_SFLOAT:: A three-component, 48-bit signed floating-point format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.</member>
        <member name="VK_FORMAT_R16G16B16A16_UNORM">ename:VK_FORMAT_R16G16B16A16_UNORM:: A four-component, 64-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.</member>
        <member name="VK_FORMAT_R16G16B16A16_SNORM">ename:VK_FORMAT_R16G16B16A16_SNORM:: A four-component, 64-bit signed normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.</member>
        <member name="VK_FORMAT_R16G16B16A16_USCALED">ename:VK_FORMAT_R16G16B16A16_USCALED:: A four-component, 64-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.</member>
        <member name="VK_FORMAT_R16G16B16A16_SSCALED">ename:VK_FORMAT_R16G16B16A16_SSCALED:: A four-component, 64-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.</member>
        <member name="VK_FORMAT_R16G16B16A16_UINT">ename:VK_FORMAT_R16G16B16A16_UINT:: A four-component, 64-bit unsigned integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.</member>
        <member name="VK_FORMAT_R16G16B16A16_SINT">ename:VK_FORMAT_R16G16B16A16_SINT:: A four-component, 64-bit signed integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.</member>
        <member name="VK_FORMAT_R16G16B16A16_SFLOAT">ename:VK_FORMAT_R16G16B16A16_SFLOAT:: A four-component, 64-bit signed floating-point format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.</member>
        <member name="VK_FORMAT_R32_UINT">ename:VK_FORMAT_R32_UINT:: A one-component, 32-bit unsigned integer format that has a single 32-bit R component.</member>
        <member name="VK_FORMAT_R32_SINT">ename:VK_FORMAT_R32_SINT:: A one-component, 32-bit signed integer format that has a single 32-bit R component.</member>
        <member name="VK_FORMAT_R32_SFLOAT">ename:VK_FORMAT_R32_SFLOAT:: A one-component, 32-bit signed floating-point format that has a single 32-bit R component.</member>
        <member name="VK_FORMAT_R32G32_UINT">ename:VK_FORMAT_R32G32_UINT:: A two-component, 64-bit unsigned integer format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.</member>
        <member name="VK_FORMAT_R32G32_SINT">ename:VK_FORMAT_R32G32_SINT:: A two-component, 64-bit signed integer format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.</member>
        <member name="VK_FORMAT_R32G32_SFLOAT">ename:VK_FORMAT_R32G32_SFLOAT:: A two-component, 64-bit signed floating-point format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.</member>
        <member name="VK_FORMAT_R32G32B32_UINT">ename:VK_FORMAT_R32G32B32_UINT:: A three-component, 96-bit unsigned integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.</member>
        <member name="VK_FORMAT_R32G32B32_SINT">ename:VK_FORMAT_R32G32B32_SINT:: A three-component, 96-bit signed integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.</member>
        <member name="VK_FORMAT_R32G32B32_SFLOAT">ename:VK_FORMAT_R32G32B32_SFLOAT:: A three-component, 96-bit signed floating-point format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.</member>
        <member name="VK_FORMAT_R32G32B32A32_UINT">ename:VK_FORMAT_R32G32B32A32_UINT:: A four-component, 128-bit unsigned integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.</member>
        <member name="VK_FORMAT_R32G32B32A32_SINT">ename:VK_FORMAT_R32G32B32A32_SINT:: A four-component, 128-bit signed integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.</member>
        <member name="VK_FORMAT_R32G32B32A32_SFLOAT">ename:VK_FORMAT_R32G32B32A32_SFLOAT:: A four-component, 128-bit signed floating-point format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.</member>
        <member name="VK_FORMAT_R64_UINT">ename:VK_FORMAT_R64_UINT:: A one-component, 64-bit unsigned integer format that has a single 64-bit R component.</member>
        <member name="VK_FORMAT_R64_SINT">ename:VK_FORMAT_R64_SINT:: A one-component, 64-bit signed integer format that has a single 64-bit R component.</member>
        <member name="VK_FORMAT_R64_SFLOAT">ename:VK_FORMAT_R64_SFLOAT:: A one-component, 64-bit signed floating-point format that has a single 64-bit R component.</member>
        <member name="VK_FORMAT_R64G64_UINT">ename:VK_FORMAT_R64G64_UINT:: A two-component, 128-bit unsigned integer format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.</member>
        <member name="VK_FORMAT_R64G64_SINT">ename:VK_FORMAT_R64G64_SINT:: A two-component, 128-bit signed integer format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.</member>
        <member name="VK_FORMAT_R64G64_SFLOAT">ename:VK_FORMAT_R64G64_SFLOAT:: A two-component, 128-bit signed floating-point format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.</member>
        <member name="VK_FORMAT_R64G64B64_UINT">ename:VK_FORMAT_R64G64B64_UINT:: A three-component, 192-bit unsigned integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.</member>
        <member name="VK_FORMAT_R64G64B64_SINT">ename:VK_FORMAT_R64G64B64_SINT:: A three-component, 192-bit signed integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.</member>
        <member name="VK_FORMAT_R64G64B64_SFLOAT">ename:VK_FORMAT_R64G64B64_SFLOAT:: A three-component, 192-bit signed floating-point format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.</member>
        <member name="VK_FORMAT_R64G64B64A64_UINT">ename:VK_FORMAT_R64G64B64A64_UINT:: A four-component, 256-bit unsigned integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.</member>
        <member name="VK_FORMAT_R64G64B64A64_SINT">ename:VK_FORMAT_R64G64B64A64_SINT:: A four-component, 256-bit signed integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.</member>
        <member name="VK_FORMAT_R64G64B64A64_SFLOAT">ename:VK_FORMAT_R64G64B64A64_SFLOAT:: A four-component, 256-bit signed floating-point format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.</member>
        <member name="VK_FORMAT_B10G11R11_UFLOAT_PACK32">ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32:: A three-component, 32-bit packed unsigned floating-point format that has a 10-bit B component in bits 22..31, an 11-bit G component in bits 11..21, an 11-bit R component in bits 0..10. See &lt;&lt;fundamentals-fp10&gt;&gt; and &lt;&lt;fundamentals-fp11&gt;&gt;.</member>
        <member name="VK_FORMAT_E5B9G9R9_UFLOAT_PACK32">ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:: A three-component, 32-bit packed unsigned floating-point format that has a 5-bit shared exponent in bits 27..31, a 9-bit B component mantissa in bits 18..26, a 9-bit G component mantissa in bits 9..17, and a 9-bit R component mantissa in bits 0..8.</member>
        <member name="VK_FORMAT_D16_UNORM">ename:VK_FORMAT_D16_UNORM:: A one-component, 16-bit unsigned normalized format that has a single 16-bit depth component.</member>
        <member name="VK_FORMAT_X8_D24_UNORM_PACK32">ename:VK_FORMAT_X8_D24_UNORM_PACK32:: A two-component, 32-bit format that has 24 unsigned normalized bits in the depth component and, optionally:, 8 bits that are unused.</member>
        <member name="VK_FORMAT_D32_SFLOAT">ename:VK_FORMAT_D32_SFLOAT:: A one-component, 32-bit signed floating-point format that has 32-bits in the depth component.</member>
        <member name="VK_FORMAT_S8_UINT">ename:VK_FORMAT_S8_UINT:: A one-component, 8-bit unsigned integer format that has 8-bits in the stencil component.</member>
        <member name="VK_FORMAT_D16_UNORM_S8_UINT">ename:VK_FORMAT_D16_UNORM_S8_UINT:: A two-component, 24-bit format that has 16 unsigned normalized bits in the depth component and 8 unsigned integer bits in the stencil component.</member>
        <member name="VK_FORMAT_D24_UNORM_S8_UINT">ename:VK_FORMAT_D24_UNORM_S8_UINT:: A two-component, 32-bit packed format that has 8 unsigned integer bits in the stencil component, and 24 unsigned normalized bits in the depth component.</member>
        <member name="VK_FORMAT_D32_SFLOAT_S8_UINT">ename:VK_FORMAT_D32_SFLOAT_S8_UINT:: A two-component format that has 32 signed float bits in the depth component and 8 unsigned integer bits in the stencil component. There are optionally: 24-bits that are unused.</member>
        <member name="VK_FORMAT_BC1_RGB_UNORM_BLOCK">ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK:: A three-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data. This format has no alpha and is considered opaque.</member>
        <member name="VK_FORMAT_BC1_RGB_SRGB_BLOCK">ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK:: A three-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding. This format has no alpha and is considered opaque.</member>
        <member name="VK_FORMAT_BC1_RGBA_UNORM_BLOCK">ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK:: A four-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data, and provides 1 bit of alpha.</member>
        <member name="VK_FORMAT_BC1_RGBA_SRGB_BLOCK">ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK:: A four-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding, and provides 1 bit of alpha.</member>
        <member name="VK_FORMAT_BC2_UNORM_BLOCK">ename:VK_FORMAT_BC2_UNORM_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.</member>
        <member name="VK_FORMAT_BC2_SRGB_BLOCK">ename:VK_FORMAT_BC2_SRGB_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding.</member>
        <member name="VK_FORMAT_BC3_UNORM_BLOCK">ename:VK_FORMAT_BC3_UNORM_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.</member>
        <member name="VK_FORMAT_BC3_SRGB_BLOCK">ename:VK_FORMAT_BC3_SRGB_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding.</member>
        <member name="VK_FORMAT_BC4_UNORM_BLOCK">ename:VK_FORMAT_BC4_UNORM_BLOCK:: A one-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized red texel data.</member>
        <member name="VK_FORMAT_BC4_SNORM_BLOCK">ename:VK_FORMAT_BC4_SNORM_BLOCK:: A one-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of signed normalized red texel data.</member>
        <member name="VK_FORMAT_BC5_UNORM_BLOCK">ename:VK_FORMAT_BC5_UNORM_BLOCK:: A two-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.</member>
        <member name="VK_FORMAT_BC5_SNORM_BLOCK">ename:VK_FORMAT_BC5_SNORM_BLOCK:: A two-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of signed normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.</member>
        <member name="VK_FORMAT_BC6H_UFLOAT_BLOCK">ename:VK_FORMAT_BC6H_UFLOAT_BLOCK:: A three-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned floating-point RGB texel data.</member>
        <member name="VK_FORMAT_BC6H_SFLOAT_BLOCK">ename:VK_FORMAT_BC6H_SFLOAT_BLOCK:: A three-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of signed floating-point RGB texel data.</member>
        <member name="VK_FORMAT_BC7_UNORM_BLOCK">ename:VK_FORMAT_BC7_UNORM_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_BC7_SRGB_BLOCK">ename:VK_FORMAT_BC7_SRGB_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK">ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:: A three-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data. This format has no alpha and is considered opaque.</member>
        <member name="VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK">ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:: A three-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding. This format has no alpha and is considered opaque.</member>
        <member name="VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK">ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:: A four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data, and provides 1 bit of alpha.</member>
        <member name="VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK">ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:: A four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding, and provides 1 bit of alpha.</member>
        <member name="VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK">ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:: A four-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.</member>
        <member name="VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK">ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:: A four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding applied.</member>
        <member name="VK_FORMAT_EAC_R11_UNORM_BLOCK">ename:VK_FORMAT_EAC_R11_UNORM_BLOCK:: A one-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized red texel data.</member>
        <member name="VK_FORMAT_EAC_R11_SNORM_BLOCK">ename:VK_FORMAT_EAC_R11_SNORM_BLOCK:: A one-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of signed normalized red texel data.</member>
        <member name="VK_FORMAT_EAC_R11G11_UNORM_BLOCK">ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK:: A two-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.</member>
        <member name="VK_FORMAT_EAC_R11G11_SNORM_BLOCK">ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK:: A two-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of signed normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.</member>
        <member name="VK_FORMAT_ASTC_4x4_UNORM_BLOCK">ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_4x4_SRGB_BLOCK">ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ASTC_5x4_UNORM_BLOCK">ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x4 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_5x4_SRGB_BLOCK">ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ASTC_5x5_UNORM_BLOCK">ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x5 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_5x5_SRGB_BLOCK">ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ASTC_6x5_UNORM_BLOCK">ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x5 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_6x5_SRGB_BLOCK">ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ASTC_6x6_UNORM_BLOCK">ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x6 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_6x6_SRGB_BLOCK">ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ASTC_8x5_UNORM_BLOCK">ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x5 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_8x5_SRGB_BLOCK">ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ASTC_8x6_UNORM_BLOCK">ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x6 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_8x6_SRGB_BLOCK">ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ASTC_8x8_UNORM_BLOCK">ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x8 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_8x8_SRGB_BLOCK">ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x8 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ASTC_10x5_UNORM_BLOCK">ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x5 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_10x5_SRGB_BLOCK">ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ASTC_10x6_UNORM_BLOCK">ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x6 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_10x6_SRGB_BLOCK">ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ASTC_10x8_UNORM_BLOCK">ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x8 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_10x8_SRGB_BLOCK">ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x8 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ASTC_10x10_UNORM_BLOCK">ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x10 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_10x10_SRGB_BLOCK">ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x10 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ASTC_12x10_UNORM_BLOCK">ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x10 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_12x10_SRGB_BLOCK">ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x10 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
        <member name="VK_FORMAT_ASTC_12x12_UNORM_BLOCK">ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x12 rectangle of unsigned normalized RGBA texel data.</member>
        <member name="VK_FORMAT_ASTC_12x12_SRGB_BLOCK">ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x12 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.</member>
      </members>
    </type>
    <type name="VkFormatFeatureFlagBits" summary="Bitmask specifying features supported by a buffer.">
      <specification />
      <description>
        <para>The pname:linearTilingFeatures and pname:optimalTilingFeatures members of the sname:VkFormatProperties structure describe what features are supported by ename:VK_IMAGE_TILING_LINEAR and ename:VK_IMAGE_TILING_OPTIMAL images, respectively.</para>
        <para>The following bits may: be set in pname:linearTilingFeatures and pname:optimalTilingFeatures, indicating they are supported by images or image views created with the queried flink:vkGetPhysicalDeviceFormatProperties::pname:format:</para>
        <para>ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT:: sname:VkImageView can: be sampled from. See &lt;&lt;descriptorsets-sampledimage, sampled images&gt;&gt; section.</para>
        <para>ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT:: sname:VkImageView can: be used as storage image. See &lt;&lt;descriptorsets-storageimage, storage images&gt;&gt; section.</para>
        <para>ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT:: sname:VkImageView can: be used as storage image that supports atomic operations.</para>
        <para>ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT:: sname:VkImageView can: be used as a framebuffer color attachment and as an input attachment.</para>
        <para>ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT:: sname:VkImageView can: be used as a framebuffer color attachment that supports blending and as an input attachment.</para>
        <para>ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT:: sname:VkImageView can: be used as a framebuffer depth/stencil attachment and as an input attachment.</para>
        <para>ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT:: sname:VkImage can: be used as pname:srcImage for the fname:vkCmdBlitImage command.</para>
        <para>ename:VK_FORMAT_FEATURE_BLIT_DST_BIT:: sname:VkImage can: be used as pname:dstImage for the fname:vkCmdBlitImage command.</para>
        <para>ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT:: If ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT is also set, sname:VkImageView can: be used with a sampler that has either of pname:magFilter or pname:minFilter set to ename:VK_FILTER_LINEAR, or pname:mipmapMode set to ename:VK_SAMPLER_MIPMAP_MODE_LINEAR. If ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT is also set, sname:VkImage can be used as the pname:srcImage to flink:vkCmdBlitImage with a pname:filter of ename:VK_FILTER_LINEAR. This bit must: only be exposed for formats that also support the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT or ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT. + If the format being queried is a depth/stencil format, this bit only indicates that the depth aspect (not the stencil aspect) of an image of this format supports linear filtering, and that linear filtering of the depth aspect is supported whether depth compare is enabled in the sampler or not. If this bit is not present, linear filtering with depth compare disabled is unsupported and linear filtering with depth compare enabled is supported, but may: compute the filtered value in an implementation-dependent manner which differs from the normal rules of linear filtering. The resulting value must: be in the range [eq]#[0,1]# and should: be proportional to, or a weighted average of, the number of comparison passes or failures.</para>
        <para>ifdef::VK_IMG_filter_cubic[] include::VK_IMG_filter_cubic/filter_cubic_sampled_bit_description.txt[] endif::VK_IMG_filter_cubic[]</para>
        <para>The following features may: appear in pname:bufferFeatures, indicating they are supported by buffers or buffer views created with the queried flink:vkGetPhysicalDeviceFormatProperties::pname:format:</para>
        <para>ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT:: Format can: be used to create a sname:VkBufferView that can: be bound to a ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER descriptor.</para>
        <para>ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT:: Format can: be used to create a sname:VkBufferView that can: be bound to a ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor.</para>
        <para>ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT:: Atomic operations are supported on ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER with this format.</para>
        <para>ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT:: Format can: be used as a vertex attribute format (sname:VkVertexInputAttributeDescription::pname:format).</para>
        <para>[NOTE] .Note ==== If no format feature flags are supported, then the only possible use would be image transfers - which alone are not useful. As such, if no format feature flags are supported, the format itself is not supported, and images of that format cannot be created. ====</para>
        <para>If pname:format is a block-compression format, then buffers must: not support any features for the format.</para>
      </description>
      <members />
    </type>
    <type name="VkFormatProperties" summary="Structure specifying image format properties.">
      <specification />
      <description>
        <para>Supported features are described as a set of elink:VkFormatFeatureFlagBits:</para>
      </description>
      <members>
        <member name="linearTilingFeatures">pname:linearTilingFeatures describes the features supported by ename:VK_IMAGE_TILING_LINEAR.</member>
        <member name="optimalTilingFeatures">pname:optimalTilingFeatures describes the features supported by ename:VK_IMAGE_TILING_OPTIMAL.</member>
        <member name="bufferFeatures">pname:bufferFeatures describes the features supported by buffers.</member>
      </members>
    </type>
    <type name="VkFramebuffer" summary="Opaque handle to a framebuffer object.">
      <specification>
        <para>Render passes operate in conjunction with _framebuffers_. Framebuffers represent a collection of specific memory attachments that a render pass instance uses.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkFramebufferCreateInfo" summary="Structure specifying parameters of a newly created framebuffer.">
      <specification />
      <description>
        <para>Image subresources used as attachments must: not be used via any non-attachment usage for the duration of a render pass instance.</para>
        <para>[NOTE] .Note ==== This restriction means that the render pass has full knowledge of all uses of all of the attachments, so that the implementation is able to make correct decisions about when and how to perform layout transitions, when to overlap execution of subpasses, etc. ====</para>
        <para>It is legal for a subpass to use no color or depth/stencil attachments, and rather use shader side effects such as image stores and atomics to produce an output. In this case, the subpass continues to use the pname:width, pname:height, and pname:layers of the framebuffer to define the dimensions of the rendering area, and the pname:rasterizationSamples from each pipeline's slink:VkPipelineMultisampleStateCreateInfo to define the number of samples used in rasterization; however, if slink:VkPhysicalDeviceFeatures::pname:variableMultisampleRate is code:VK_FALSE, then all pipelines to be bound with a given zero-attachment subpass must: have the same value for slink:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples.</para>
        <para>.Valid Usage **** * pname:attachmentCount must: be equal to the attachment count specified in pname:renderPass * Any given element of pname:pAttachments that is used as a color attachment or resolve attachment by pname:renderPass must: have been created with a pname:usage value including ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT * Any given element of pname:pAttachments that is used as a depth/stencil attachment by pname:renderPass must: have been created with a pname:usage value including ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT * Any given element of pname:pAttachments that is used as an input attachment by pname:renderPass must: have been created with a pname:usage value including ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT * Any given element of pname:pAttachments must: have been created with an elink:VkFormat value that matches the elink:VkFormat specified by the corresponding sname:VkAttachmentDescription in pname:renderPass * Any given element of pname:pAttachments must: have been created with a pname:samples value that matches the pname:samples value specified by the corresponding sname:VkAttachmentDescription in pname:renderPass * Any given element of pname:pAttachments must: have dimensions at least as large as the corresponding framebuffer dimension * Any given element of pname:pAttachments must: only specify a single mip level * Any given element of pname:pAttachments must: have been created with the identity swizzle * pname:width must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxFramebufferWidth * pname:height must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxFramebufferHeight * pname:layers must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxFramebufferLayers ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="renderPass">pname:renderPass is a render pass that defines what render passes the framebuffer will be compatible with. See &lt;&lt;renderpass-compatibility,Render Pass Compatibility&gt;&gt; for details.</member>
        <member name="attachmentCount">pname:attachmentCount is the number of attachments.</member>
        <member name="pAttachments">pname:pAttachments is an array of sname:VkImageView handles, each of which will be used as the corresponding attachment in a render pass instance.</member>
        <member name="width">pname:width, pname:height and pname:layers define the dimensions of the framebuffer.</member>
      </members>
    </type>
    <type name="VkFrontFace" summary="Interpret polygon front-facing orientation.">
      <specification>
        <para>The first step of polygon rasterization is to determine whether the triangle is _back-facing_ or _front-facing_. This determination is made based on the sign of the (clipped or unclipped) polygon's area computed in framebuffer coordinates. One way to compute this area is:</para>
        <para>[latexmath] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ \[ a = -{1 \over 2}\sum_{i=0}^{n-1} x_f^i y_f^{i \oplus 1} - x_f^{i \oplus 1} y_f^i \] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</para>
        <para>where latexmath:[$x_f^i$] and latexmath:[$y_f^i$] are the [eq]#x# and [eq]#y# framebuffer coordinates of the [eq]##i##th vertex of the [eq]#n#-vertex polygon (vertices are numbered starting at zero for the purposes of this computation) and [eq]#i {oplus} 1# is [eq]#(i + 1) mod n#.</para>
      </specification>
      <description>
        <para>If pname:frontFace is set to ename:VK_FRONT_FACE_COUNTER_CLOCKWISE, a triangle with positive area is considered front-facing. If it is set to ename:VK_FRONT_FACE_CLOCKWISE, a triangle with negative area is considered front-facing. Any triangle which is not front-facing is back-facing, including zero-area triangles.</para>
      </description>
      <members />
    </type>
    <type name="VkGraphicsPipelineCreateInfo" summary="Structure specifying parameters of a newly created graphics pipeline.">
      <specification />
      <description>
        <para>The parameters pname:basePipelineHandle and pname:basePipelineIndex are described in more detail in &lt;&lt;pipelines-pipeline-derivatives,Pipeline Derivatives&gt;&gt;.</para>
        <para>pname:pStages points to an array of slink:VkPipelineShaderStageCreateInfo structures, which were previously described in &lt;&lt;pipelines-compute,Compute Pipelines&gt;&gt;.</para>
        <para>Bits which can: be set in pname:flags are:</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is a bitmask of elink:VkPipelineCreateFlagBits controlling how the pipeline will be generated, as described below.</member>
        <member name="stageCount">pname:stageCount is the number of entries in the pname:pStages array.</member>
        <member name="pStages">pname:pStages is an array of size pname:stageCount structures of type slink:VkPipelineShaderStageCreateInfo describing the set of the shader stages to be included in the graphics pipeline.</member>
        <member name="pVertexInputState">pname:pVertexInputState is a pointer to an instance of the slink:VkPipelineVertexInputStateCreateInfo structure.</member>
        <member name="pInputAssemblyState">pname:pInputAssemblyState is a pointer to an instance of the slink:VkPipelineInputAssemblyStateCreateInfo structure which determines input assembly behavior, as described in &lt;&lt;drawing, Drawing Commands&gt;&gt;.</member>
        <member name="pTessellationState">pname:pTessellationState is a pointer to an instance of the slink:VkPipelineTessellationStateCreateInfo structure, or `NULL` if the pipeline does not include a tessellation control shader stage and tessellation evaluation shader stage.</member>
        <member name="pViewportState">pname:pViewportState is a pointer to an instance of the slink:VkPipelineViewportStateCreateInfo structure, or `NULL` if the pipeline has rasterization disabled.</member>
        <member name="pRasterizationState">pname:pRasterizationState is a pointer to an instance of the slink:VkPipelineRasterizationStateCreateInfo structure.</member>
        <member name="pMultisampleState">pname:pMultisampleState is a pointer to an instance of the slink:VkPipelineMultisampleStateCreateInfo, or `NULL` if the pipeline has rasterization disabled.</member>
        <member name="pDepthStencilState">pname:pDepthStencilState is a pointer to an instance of the slink:VkPipelineDepthStencilStateCreateInfo structure, or `NULL` if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use a depth/stencil attachment.</member>
        <member name="pColorBlendState">pname:pColorBlendState is a pointer to an instance of the slink:VkPipelineColorBlendStateCreateInfo structure, or `NULL` if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use any color attachments.</member>
        <member name="pDynamicState">pname:pDynamicState is a pointer to slink:VkPipelineDynamicStateCreateInfo and is used to indicate which properties of the pipeline state object are dynamic and can: be changed independently of the pipeline state. This can: be `NULL`, which means no state in the pipeline is considered dynamic.</member>
        <member name="layout">pname:layout is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.</member>
        <member name="renderPass">pname:renderPass is a handle to a render pass object describing the environment in which the pipeline will be used; the pipeline must: only be used with an instance of any render pass compatible with the one provided. See &lt;&lt;renderpass-compatibility,Render Pass Compatibility&gt;&gt; for more information.</member>
        <member name="subpass">pname:subpass is the index of the subpass in the render pass where this pipeline will be used.</member>
        <member name="basePipelineHandle">pname:basePipelineHandle is a pipeline to derive from.</member>
        <member name="basePipelineIndex">pname:basePipelineIndex is an index into the pname:pCreateInfos parameter to use as a pipeline to derive from.</member>
      </members>
    </type>
    <type name="VkImage" summary="Opaque handle to a image object.">
      <specification>
        <para>Images represent multidimensional - up to 3 - arrays of data which can: be used for various purposes (e.g. attachments, textures), by binding them to a graphics or compute pipeline via descriptor sets, or by directly specifying them as parameters to certain commands.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkImageAspectFlagBits" summary="Bitmask specifying which aspects of an image are included in a view.">
      <specification />
      <description>
        <para>The mask must: be only ename:VK_IMAGE_ASPECT_COLOR_BIT, ename:VK_IMAGE_ASPECT_DEPTH_BIT or ename:VK_IMAGE_ASPECT_STENCIL_BIT if pname:format is a color, depth-only or stencil-only format, respectively. If using a depth/stencil format with both depth and stencil components, pname:aspectMask must: include at least one of ename:VK_IMAGE_ASPECT_DEPTH_BIT and ename:VK_IMAGE_ASPECT_STENCIL_BIT, and can: include both.</para>
        <para>When using an imageView of a depth/stencil image to populate a descriptor set (e.g. for sampling in the shader, or for use as an input attachment), the pname:aspectMask must: only include one bit and selects whether the imageView is used for depth reads (i.e. using a floating-point sampler or input attachment in the shader) or stencil reads (i.e. using an unsigned integer sampler or input attachment in the shader). When an imageView of a depth/stencil image is used as a depth/stencil framebuffer attachment, the pname:aspectMask is ignored and both depth and stencil image subresources are used.</para>
        <para>The pname:components member is of type slink:VkComponentMapping, and describes a remapping from components of the image to components of the vector returned by shader image instructions. This remapping must: be identity for storage image descriptors, input attachment descriptors, and framebuffer attachments.</para>
        <para>.Valid Usage **** * If pname:levelCount is not ename:VK_REMAINING_MIP_LEVELS, [eq]#(pname:baseMipLevel + pname:levelCount)# must: be less than or equal to the pname:mipLevels specified in slink:VkImageCreateInfo when the image was created * If pname:layerCount is not ename:VK_REMAINING_ARRAY_LAYERS, [eq]#(pname:baseArrayLayer + pname:layerCount)# must: be less than or equal to the pname:arrayLayers specified in slink:VkImageCreateInfo when the image was created ****</para>
      </description>
      <members />
    </type>
    <type name="VkImageBlit" summary="Structure specifying an image blit operation.">
      <specification />
      <description>
        <para>For each element of the pname:pRegions array, a blit operation is performed the specified source and destination regions.</para>
        <para>.Valid Usage **** * The pname:aspectMask member of pname:srcSubresource and pname:dstSubresource must: match * The pname:layerCount member of pname:srcSubresource and pname:dstSubresource must: match * If either of the calling command's pname:srcImage or pname:dstImage parameters are of elink:VkImageType ename:VK_IMAGE_TYPE_3D, the pname:baseArrayLayer and pname:layerCount members of both pname:srcSubresource and pname:dstSubresource must: be `0` and `1`, respectively * The pname:aspectMask member of pname:srcSubresource must: specify aspects present in the calling command's pname:srcImage * The pname:aspectMask member of pname:dstSubresource must: specify aspects present in the calling command's pname:dstImage * The pname:layerCount member of pname:dstSubresource must: be equal to the pname:layerCount member of pname:srcSubresource * pname:srcOffset[0].pname:x and pname:srcOffset[1].pname:x must: both be greater than or equal to `0` and less than or equal to the source image subresource width * pname:srcOffset[0].pname:y and pname:srcOffset[1].pname:y must: both be greater than or equal to `0` and less than or equal to the source image subresource height ** If the calling command's pname:srcImage is of type ename:VK_IMAGE_TYPE_1D, then pname:srcOffset[0].y must: be `0` and pname:srcOffset[1].y must: be `1`. * pname:srcOffset[0].pname:z and pname:srcOffset[1].pname:z must: both be greater than or equal to `0` and less than or equal to the source image subresource depth ** If the calling command's pname:srcImage is of type ename:VK_IMAGE_TYPE_1D or ename:VK_IMAGE_TYPE_2D, then pname:srcOffset[0].z must: be `0` and pname:srcOffset[1].z must: be `1`. * pname:dstOffset[0].pname:x and pname:dstOffset[1].pname:x must: both be greater than or equal to `0` and less than or equal to the destination image subresource width * pname:dstOffset[0].pname:y and pname:dstOffset[1].pname:y must: both be greater than or equal to `0` and less than or equal to the destination image subresource height ** If the calling command's pname:dstImage is of type ename:VK_IMAGE_TYPE_1D, then pname:dstOffset[0].y must: be `0` and pname:dstOffset[1].y must: be `1`. * pname:dstOffset[0].pname:z and pname:dstOffset[1].pname:z must: both be greater than or equal to `0` and less than or equal to the destination image subresource depth ** If the calling command's pname:dstImage is of type ename:VK_IMAGE_TYPE_1D or ename:VK_IMAGE_TYPE_2D, then pname:dstOffset[0].z must: be `0` and pname:dstOffset[1].z must: be `1`. ****</para>
      </description>
      <members>
        <member name="srcSubresource">pname:srcSubresource is the subresource to blit from.</member>
        <member name="srcOffsets">pname:srcOffsets is an array of two slink:VkOffset3D structures specifying the bounds of the source region within pname:srcSubresource.</member>
        <member name="dstSubresource">pname:dstSubresource is the subresource to blit into.</member>
        <member name="dstOffsets">pname:dstOffsets is an array of two slink:VkOffset3D structures specifying the bounds of the destination region within pname:dstSubresource.</member>
      </members>
    </type>
    <type name="VkImageCopy" summary="Structure specifying an image copy operation.">
      <specification />
      <description>
        <para>.Valid Usage **** * The pname:aspectMask member of pname:srcSubresource and pname:dstSubresource must: match * The pname:layerCount member of pname:srcSubresource and pname:dstSubresource must: match * If either of the calling command's pname:srcImage or pname:dstImage parameters are of elink:VkImageType ename:VK_IMAGE_TYPE_3D, the pname:baseArrayLayer and pname:layerCount members of both pname:srcSubresource and pname:dstSubresource must: be `0` and `1`, respectively * The pname:aspectMask member of pname:srcSubresource must: specify aspects present in the calling command's pname:srcImage * The pname:aspectMask member of pname:dstSubresource must: specify aspects present in the calling command's pname:dstImage * pname:srcOffset.x and (pname:extent.width + pname:srcOffset.x) must: both be greater than or equal to `0` and less than or equal to the source image subresource width * pname:srcOffset.y and (pname:extent.height + pname:srcOffset.y) must: both be greater than or equal to `0` and less than or equal to the source image subresource height ** If the calling command's pname:srcImage is of type ename:VK_IMAGE_TYPE_1D, then pname:srcOffset.y must: be `0` and pname:extent.height must: be `1`. * pname:srcOffset.z and (pname:extent.depth + pname:srcOffset.z) must: both be greater than or equal to `0` and less than or equal to the source image subresource depth ** If the calling command's pname:srcImage is of type ename:VK_IMAGE_TYPE_1D or ename:VK_IMAGE_TYPE_2D, then pname:srcOffset.z must: be `0` and pname:extent.depth must: be `1`. * pname:dstOffset.x and (pname:extent.width + pname:dstOffset.x) must: both be greater than or equal to `0` and less than or equal to the destination image subresource width * pname:dstOffset.y and (pname:extent.height + pname:dstOffset.y) must: both be greater than or equal to `0` and less than or equal to the destination image subresource height ** If the calling command's pname:dstImage is of type ename:VK_IMAGE_TYPE_1D, then pname:dstOffset.y must: be `0` and pname:extent.height must: be `1`. * pname:dstOffset.z and (pname:extent.depth + pname:dstOffset.z) must: both be greater than or equal to `0` and less than or equal to the destination image subresource depth ** If the calling command's pname:dstImage is of type ename:VK_IMAGE_TYPE_1D or ename:VK_IMAGE_TYPE_2D, then pname:dstOffset.z must: be `0` and pname:extent.depth must: be `1`. * If the calling command's pname:srcImage is a compressed format image: ** all members of pname:srcOffset must: be a multiple of the corresponding dimensions of the compressed texel block ** pname:extent.width must: be a multiple of the compressed texel block width or (pname:extent.width + pname:srcOffset.x) must: equal the source image subresource width ** pname:extent.height must: be a multiple of the compressed texel block height or (pname:extent.height + pname:srcOffset.y) must: equal the source image subresource height ** pname:extent.depth must: be a multiple of the compressed texel block depth or (pname:extent.depth + pname:srcOffset.z) must: equal the source image subresource depth * If the calling command's pname:dstImage is a compressed format image: ** all members of pname:dstOffset must: be a multiple of the corresponding dimensions of the compressed texel block ** pname:extent.width must: be a multiple of the compressed texel block width or (pname:extent.width + pname:dstOffset.x) must: equal the destination image subresource width ** pname:extent.height must: be a multiple of the compressed texel block height or (pname:extent.height + pname:dstOffset.y) must: equal the destination image subresource height ** pname:extent.depth must: be a multiple of the compressed texel block depth or (pname:extent.depth + pname:dstOffset.z) must: equal the destination image subresource depth * pname:srcOffset, pname:dstOffset, and pname:extent must: respect the image transfer granularity requirements of the queue family that it will be submitted against, as described in &lt;&lt;devsandqueues-physical-device-enumeration,Physical Device Enumeration&gt;&gt; ****</para>
      </description>
      <members>
        <member name="srcSubresource">pname:srcSubresource and pname:dstSubresource are slink:VkImageSubresourceLayers structures specifying the image subresources of the images used for the source and destination image data, respectively.</member>
        <member name="srcOffset">pname:srcOffset and pname:dstOffset select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data.</member>
        <member name="extent">pname:extent is the size in texels of the source image to copy in pname:width, pname:height and pname:depth.</member>
      </members>
    </type>
    <type name="VkImageCreateFlagBits" summary="Bitmask specifying additional parameters of an image.">
      <specification />
      <description>
        <para>If any of the bits ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT, ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set, ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT must: not also be set.</para>
        <para>See &lt;&lt;sparsememory-sparseresourcefeatures,Sparse Resource Features&gt;&gt; and &lt;&lt;sparsememory-physicalfeatures,Sparse Physical Device Features&gt;&gt; for more details.</para>
      </description>
      <members>
        <member name="VK_IMAGE_CREATE_SPARSE_BINDING_BIT">ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT indicates that the image will be backed using sparse memory binding.</member>
        <member name="VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT">ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT indicates that the image can: be partially backed using sparse memory binding. Images created with this flag must: also be created with the ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag.</member>
        <member name="VK_IMAGE_CREATE_SPARSE_ALIASED_BIT">ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT indicates that the image will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another image (or another portion of the same image). Images created with this flag must: also be created with the ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag</member>
        <member name="VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT">ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT indicates that the image can: be used to create a sname:VkImageView with a different format from the image.</member>
        <member name="VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT">ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT indicates that the image can: be used to create a sname:VkImageView of type ename:VK_IMAGE_VIEW_TYPE_CUBE or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY.</member>
      </members>
    </type>
    <type name="VkImageCreateInfo" summary="Structure specifying the parameters of a newly created image object.">
      <specification />
      <description>
        <para>Valid limits for the image pname:extent, pname:mipLevels, pname:arrayLayers and pname:samples members are queried with the flink:vkGetPhysicalDeviceImageFormatProperties command.</para>
        <para>Images created with pname:tiling equal to ename:VK_IMAGE_TILING_LINEAR have further restrictions on their limits and capabilities compared to images created with pname:tiling equal to ename:VK_IMAGE_TILING_OPTIMAL. Creation of images with tiling ename:VK_IMAGE_TILING_LINEAR may: not be supported unless other parameters meet all of the constraints:</para>
        <para>* pname:imageType is ename:VK_IMAGE_TYPE_2D * pname:format is not a depth/stencil format * pname:mipLevels is 1 * pname:arrayLayers is 1 * pname:samples is ename:VK_SAMPLE_COUNT_1_BIT * pname:usage only includes ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT and/or ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT</para>
        <para>Implementations may: support additional limits and capabilities beyond those listed above. To determine the specific capabilities of an implementation, query the valid pname:usage bits by calling flink:vkGetPhysicalDeviceFormatProperties and the valid limits for pname:mipLevels and pname:arrayLayers by calling flink:vkGetPhysicalDeviceImageFormatProperties.</para>
        <para>.Valid Usage **** * If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:pQueueFamilyIndices must: be a pointer to an array of pname:queueFamilyIndexCount basetype:uint32_t values * If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:queueFamilyIndexCount must: be greater than `1` * pname:format must: not be ename:VK_FORMAT_UNDEFINED * The pname:width, pname:height, and pname:depth members of pname:extent must: all be greater than `0` * pname:mipLevels must: be greater than `0` * pname:arrayLayers must: be greater than `0` * If pname:flags contains ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, pname:imageType must be ename:VK_IMAGE_TYPE_2D * If pname:imageType is ename:VK_IMAGE_TYPE_1D, pname:extent.width must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxImageDimension1D, or sname:VkImageFormatProperties::pname:maxExtent.width (as returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage, and pname:flags equal to those in this structure) - whichever is higher * If pname:imageType is ename:VK_IMAGE_TYPE_2D and pname:flags does not contain ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, pname:extent.width and pname:extent.height must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxImageDimension2D, or sname:VkImageFormatProperties::pname:maxExtent.width/height (as returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage, and pname:flags equal to those in this structure) - whichever is higher * If pname:imageType is ename:VK_IMAGE_TYPE_2D and pname:flags contains ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, pname:extent.width and pname:extent.height must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxImageDimensionCube, or sname:VkImageFormatProperties::pname:maxExtent.width/height (as returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage, and pname:flags equal to those in this structure) - whichever is higher * If pname:imageType is ename:VK_IMAGE_TYPE_2D and pname:flags contains ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, pname:extent.width and pname:extent.height must: be equal and pname:arrayLayers must: be greater than or equal to 6 * If pname:imageType is ename:VK_IMAGE_TYPE_3D, pname:extent.width, pname:extent.height and pname:extent.depth must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxImageDimension3D, or sname:VkImageFormatProperties::pname:maxExtent.width/height/depth (as returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage, and pname:flags equal to those in this structure) - whichever is higher * If pname:imageType is ename:VK_IMAGE_TYPE_1D, both pname:extent.height and pname:extent.depth must: be `1` * If pname:imageType is ename:VK_IMAGE_TYPE_2D, pname:extent.depth must: be `1` * pname:mipLevels must: be less than or equal to [eq]#{lfloor}log~2~(max(pname:extent.width, pname:extent.height, pname:extent.depth)){rfloor} + 1#. * If any of pname:extent.width, pname:extent.height, or pname:extent.depth are greater than the equivalently named members of sname:VkPhysicalDeviceLimits::pname:maxImageDimension3D, pname:mipLevels must: be less than or equal to sname:VkImageFormatProperties::pname:maxMipLevels (as returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage, and pname:flags equal to those in this structure) * pname:arrayLayers must: be less than or equal to sname:VkImageFormatProperties::pname:maxArrayLayers (as returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage, and pname:flags equal to those in this structure) * If pname:samples is not ename:VK_SAMPLE_COUNT_1_BIT, pname:imageType must: be ename:VK_IMAGE_TYPE_2D, pname:flags must: not contain ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, pname:tiling must: be ename:VK_IMAGE_TILING_OPTIMAL, and pname:mipLevels must: be equal to `1` * If pname:usage includes ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, then bits other than ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT must: not be set * If pname:usage includes ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, pname:extent.width must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxFramebufferWidth * If pname:usage includes ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, pname:extent.height must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxFramebufferHeight * pname:samples must: be a bit value that is set in sname:VkImageFormatProperties::pname:sampleCounts returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage, and pname:flags equal to those in this structure * If the &lt;&lt;features-features-textureCompressionETC2,ETC2 texture compression&gt;&gt; feature is not enabled, pname:format must: not be ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK, ename:VK_FORMAT_EAC_R11_UNORM_BLOCK, ename:VK_FORMAT_EAC_R11_SNORM_BLOCK, ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK, or ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK * If the &lt;&lt;features-features-textureCompressionASTC_LDR,ASTC LDR texture compression&gt;&gt; feature is not enabled, pname:format must: not be ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK, ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK, ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK, ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK, ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK, ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK, ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK, ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK, ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK, ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK, ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK, ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK, ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK, or ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK * If the &lt;&lt;features-features-textureCompressionBC,BC texture compression&gt;&gt; feature is not enabled, pname:format must: not be ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK, ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK, ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK, ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK, ename:VK_FORMAT_BC2_UNORM_BLOCK, ename:VK_FORMAT_BC2_SRGB_BLOCK, ename:VK_FORMAT_BC3_UNORM_BLOCK, ename:VK_FORMAT_BC3_SRGB_BLOCK, ename:VK_FORMAT_BC4_UNORM_BLOCK, ename:VK_FORMAT_BC4_SNORM_BLOCK, ename:VK_FORMAT_BC5_UNORM_BLOCK, ename:VK_FORMAT_BC5_SNORM_BLOCK, ename:VK_FORMAT_BC6H_UFLOAT_BLOCK, ename:VK_FORMAT_BC6H_SFLOAT_BLOCK, ename:VK_FORMAT_BC7_UNORM_BLOCK, or ename:VK_FORMAT_BC7_SRGB_BLOCK * If the &lt;&lt;features-features-shaderStorageImageMultisample,multisampled storage images&gt;&gt; feature is not enabled, and pname:usage contains ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:samples must: be ename:VK_SAMPLE_COUNT_1_BIT * If the &lt;&lt;features-features-sparseBinding,sparse bindings&gt;&gt; feature is not enabled, pname:flags must: not contain ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT * If the &lt;&lt;features-features-sparseResidencyImage2D,sparse residency for 2D images&gt;&gt; feature is not enabled, and pname:imageType is ename:VK_IMAGE_TYPE_2D, pname:flags must: not contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT * If the &lt;&lt;features-features-sparseResidencyImage3D,sparse residency for 3D images&gt;&gt; feature is not enabled, and pname:imageType is ename:VK_IMAGE_TYPE_3D, pname:flags must: not contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT * If the &lt;&lt;features-features-sparseResidency2Samples,sparse residency for images with 2 samples&gt;&gt; feature is not enabled, pname:imageType is ename:VK_IMAGE_TYPE_2D, and pname:samples is ename:VK_SAMPLE_COUNT_2_BIT, pname:flags must: not contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT * If the &lt;&lt;features-features-sparseResidency4Samples,sparse residency for images with 4 samples&gt;&gt; feature is not enabled, pname:imageType is ename:VK_IMAGE_TYPE_2D, and pname:samples is ename:VK_SAMPLE_COUNT_4_BIT, pname:flags must: not contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT * If the &lt;&lt;features-features-sparseResidency8Samples,sparse residency for images with 8 samples&gt;&gt; feature is not enabled, pname:imageType is ename:VK_IMAGE_TYPE_2D, and pname:samples is ename:VK_SAMPLE_COUNT_8_BIT, pname:flags must: not contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT * If the &lt;&lt;features-features-sparseResidency16Samples,sparse residency for images with 16 samples&gt;&gt; feature is not enabled, pname:imageType is ename:VK_IMAGE_TYPE_2D, and pname:samples is ename:VK_SAMPLE_COUNT_16_BIT, pname:flags must: not contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT * If pname:tiling is ename:VK_IMAGE_TILING_LINEAR, pname:format must: be a format that has at least one supported feature bit present in the value of sname:VkFormatProperties::pname:linearTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format * If pname:tiling is ename:VK_IMAGE_TILING_LINEAR, and sname:VkFormatProperties::pname:linearTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, pname:usage must: not contain ename:VK_IMAGE_USAGE_SAMPLED_BIT * If pname:tiling is ename:VK_IMAGE_TILING_LINEAR, and sname:VkFormatProperties::pname:linearTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT, pname:usage must: not contain ename:VK_IMAGE_USAGE_STORAGE_BIT * If pname:tiling is ename:VK_IMAGE_TILING_LINEAR, and sname:VkFormatProperties::pname:linearTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT, pname:usage must: not contain ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT * If pname:tiling is ename:VK_IMAGE_TILING_LINEAR, and sname:VkFormatProperties::pname:linearTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:usage must: not contain ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT * If pname:tiling is ename:VK_IMAGE_TILING_OPTIMAL, pname:format must: be a format that has at least one supported feature bit present in the value of sname:VkFormatProperties::pname:optimalTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format * If pname:tiling is ename:VK_IMAGE_TILING_OPTIMAL, and sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, pname:usage must: not contain ename:VK_IMAGE_USAGE_SAMPLED_BIT * If pname:tiling is ename:VK_IMAGE_TILING_OPTIMAL, and sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT, pname:usage must: not contain ename:VK_IMAGE_USAGE_STORAGE_BIT * If pname:tiling is ename:VK_IMAGE_TILING_OPTIMAL, and sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT, pname:usage must: not contain ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT * If pname:tiling is ename:VK_IMAGE_TILING_OPTIMAL, and sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:usage must: not contain ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT * If pname:flags contains ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT or ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT, it must: also contain ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is a bitmask describing additional parameters of the image. See elink:VkImageCreateFlagBits below for a description of the supported bits.</member>
        <member name="imageType">pname:imageType is a elink:VkImageType specifying the basic dimensionality of the image, as described below. Layers in array textures do not count as a dimension for the purposes of the image type.</member>
        <member name="format">pname:format is a elink:VkFormat describing the format and type of the data elements that will be contained in the image.</member>
        <member name="extent">pname:extent is a slink:VkExtent3D describing the number of data elements in each dimension of the base level.</member>
        <member name="mipLevels">pname:mipLevels describes the number of levels of detail available for minified sampling of the image.</member>
        <member name="arrayLayers">pname:arrayLayers is the number of layers in the image.</member>
        <member name="samples">pname:samples is the number of sub-data element samples in the image as defined in elink:VkSampleCountFlagBits. See &lt;&lt;primsrast-multisampling,Multisampling&gt;&gt;.</member>
        <member name="tiling">pname:tiling is a elink:VkImageTiling specifying the tiling arrangement of the data elements in memory, as described below.</member>
        <member name="usage">pname:usage is a bitmask describing the intended usage of the image. See elink:VkImageUsageFlagBits below for a description of the supported bits.</member>
        <member name="sharingMode">pname:sharingMode is the sharing mode of the image when it will be accessed by multiple queue families, and must: be one of the values described for elink:VkSharingMode in the &lt;&lt;resources-sharing,Resource Sharing&gt;&gt; section below.</member>
        <member name="queueFamilyIndexCount">pname:queueFamilyIndexCount is the number of entries in the pname:pQueueFamilyIndices array.</member>
        <member name="pQueueFamilyIndices">pname:pQueueFamilyIndices is a list of queue families that will access this image (ignored if pname:sharingMode is not ename:VK_SHARING_MODE_CONCURRENT).</member>
        <member name="initialLayout">pname:initialLayout selects the initial elink:VkImageLayout state of all image subresources of the image. See &lt;&lt;resources-image-layouts,Image Layouts&gt;&gt;. pname:initialLayout must: be ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED.</member>
      </members>
    </type>
    <type name="VkImageFormatProperties" summary="Structure specifying a image format properties.">
      <specification />
      <description>
        <para>[NOTE] .Note ==== There is no mechanism to query the size of an image before creating it, to compare that size against pname:maxResourceSize. If an application attempts to create an image that exceeds this limit, the creation will fail or the image will be invalid. While the advertised limit must: be at least 2^31^, it may: not be possible to create an image that approaches that size, particularly for ename:VK_IMAGE_TYPE_1D. ====</para>
        <para>If the combination of parameters to fname:vkGetPhysicalDeviceImageFormatProperties is not supported by the implementation for use in flink:vkCreateImage, then all members of sname:VkImageFormatProperties will be filled with zero.</para>
      </description>
      <members>
        <member name="maxExtent">pname:maxExtent are the maximum image dimensions. See the &lt;&lt;features-extentperimagetype,Allowed Extent Values&gt;&gt; section below for how these values are constrained by pname:type.</member>
        <member name="maxMipLevels">pname:maxMipLevels is the maximum number of mipmap levels. pname:maxMipLevels must: either be equal to 1 (valid only if pname:tiling is ename:VK_IMAGE_TILING_LINEAR) or be equal to [eq]#{lceil}log~2~(max(pname:width, pname:height, pname:depth)){rceil} {plus} 1#. [eq]#pname:width#, [eq]#pname:height#, and [eq]#pname:depth# are taken from the corresponding members of pname:maxExtent.</member>
        <member name="maxArrayLayers">pname:maxArrayLayers is the maximum number of array layers. pname:maxArrayLayers must: either be equal to 1 or be greater than or equal to the pname:maxImageArrayLayers member of slink:VkPhysicalDeviceLimits. A value of 1 is valid only if pname:tiling is ename:VK_IMAGE_TILING_LINEAR or if pname:type is ename:VK_IMAGE_TYPE_3D.</member>
        <member name="sampleCounts">pname:sampleCounts is a bitmask of elink:VkSampleCountFlagBits specifying all the supported sample counts for this image as described &lt;&lt;features-supported-sample-counts, below&gt;&gt;.</member>
        <member name="maxResourceSize">pname:maxResourceSize is an upper bound on the total image size in bytes, inclusive of all image subresources. Implementations may: have an address space limit on total size of a resource, which is advertised by this property. pname:maxResourceSize must: be at least 2^31^.</member>
      </members>
    </type>
    <type name="VkImageLayout" summary="Layout of image and image subresources.">
      <specification />
      <description>
        <para>For each mechanism of accessing an image in the API, there is a parameter or structure member that controls the image layout used to access the image. For transfer commands, this is a parameter to the command (see &lt;&lt;clears&gt;&gt; and &lt;&lt;copies&gt;&gt;). For use as a framebuffer attachment, this is a member in the substructures of the sname:VkRenderPassCreateInfo (see &lt;&lt;renderpass,Render Pass&gt;&gt;). For use in a descriptor set, this is a member in the sname:VkDescriptorImageInfo structure (see &lt;&lt;descriptorsets-updates&gt;&gt;). At the time that any command buffer command accessing an image executes on any queue, the layouts of the image subresources that are accessed must: all match the layout specified via the API controlling those accesses.</para>
        <para>The image layout of each image subresource must: be well-defined at each point in the image subresource's lifetime. This means that when performing a layout transition on the image subresource, the old layout value must: either equal the current layout of the image subresource (at the time the transition executes), or else be ename:VK_IMAGE_LAYOUT_UNDEFINED (implying that the contents of the image subresource need not be preserved). The new layout used in a transition must: not be ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED.</para>
      </description>
      <members>
        <member name="VK_IMAGE_LAYOUT_UNDEFINED">ename:VK_IMAGE_LAYOUT_UNDEFINED: Supports no device access. This layout must: only be used as the pname:initialLayout member of sname:VkImageCreateInfo or sname:VkAttachmentDescription, or as the pname:oldLayout in an image transition. When transitioning out of this layout, the contents of the memory are not guaranteed to be preserved.</member>
        <member name="VK_IMAGE_LAYOUT_PREINITIALIZED">ename:VK_IMAGE_LAYOUT_PREINITIALIZED: Supports no device access. This layout must: only be used as the pname:initialLayout member of sname:VkImageCreateInfo or sname:VkAttachmentDescription, or as the pname:oldLayout in an image transition. When transitioning out of this layout, the contents of the memory are preserved. This layout is intended to be used as the initial layout for an image whose contents are written by the host, and hence the data can: be written to memory immediately, without first executing a layout transition. Currently, ename:VK_IMAGE_LAYOUT_PREINITIALIZED is only useful with ename:VK_IMAGE_TILING_LINEAR images because there is not a standard layout defined for ename:VK_IMAGE_TILING_OPTIMAL images.</member>
        <member name="VK_IMAGE_LAYOUT_GENERAL">ename:VK_IMAGE_LAYOUT_GENERAL: Supports all types of device access.</member>
        <member name="VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL">ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: must: only be used as a color or resolve attachment in a sname:VkFramebuffer. This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT usage bit enabled.</member>
        <member name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL">ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: must: only be used as a depth/stencil attachment in a sname:VkFramebuffer. This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bit enabled.</member>
        <member name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL">ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: must: only be used as a read-only depth/stencil attachment in a sname:VkFramebuffer and/or as a read-only image in a shader (which can: be read as a sampled image, combined image/sampler and/or input attachment). This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bit enabled. Only image subresources of images created with ename:VK_IMAGE_USAGE_SAMPLED_BIT can: be used as sampled image or combined image/sampler in a shader. Similarly, only image subresources of images created with ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT can: be used as input attachments.</member>
        <member name="VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL">ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: must: only be used as a read-only image in a shader (which can: be read as a sampled image, combined image/sampler and/or input attachment). This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_SAMPLED_BIT or ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT usage bit enabled.</member>
        <member name="VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL">ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: must: only be used as a source image of a transfer command (see the definition of &lt;&lt;synchronization-transfer,ename:VK_PIPELINE_STAGE_TRANSFER_BIT&gt;&gt;). This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage bit enabled.</member>
        <member name="VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL">ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: must: only be used as a destination image of a transfer command. This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT usage bit enabled. ifdef::VK_KHR_swapchain[]</member>
        <member name="VK_IMAGE_LAYOUT_PRESENT_SRC_KHR">ename:VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: must: only be used for presenting a swapchain image for display. A swapchain's image must: be transitioned to this layout before calling flink:vkQueuePresentKHR, and must: be transitioned away from this layout after calling flink:vkAcquireNextImageKHR. endif::VK_KHR_swapchain[]</member>
      </members>
    </type>
    <type name="VkImageMemoryBarrier" summary="Structure specifying the parameters of an image memory barrier.">
      <specification />
      <description>
        <para>If pname:oldLayout differs from pname:newLayout, a layout transition occurs as part of the image memory barrier, affecting the data contained in the region of the image defined by the pname:subresourceRange. If pname:oldLayout is ename:VK_IMAGE_LAYOUT_UNDEFINED, then the data is undefined after the layout transition. This may: allow a more efficient transition, since the data may: be discarded. The layout transition must: occur after all operations using the old layout are completed and before all operations using the new layout are started. This is achieved by ensuring that there is a memory dependency between previous accesses and the layout transition, as well as between the layout transition and subsequent accesses, where the layout transition occurs between the two halves of a memory dependency in an image memory barrier.</para>
        <para>Layout transitions that are performed via image memory barriers are automatically ordered against other layout transitions, including those that occur as part of a render pass instance.</para>
        <para>[NOTE] .Note ==== See &lt;&lt;resources-image-layouts&gt;&gt; for details on available image layouts and their usages. ====</para>
        <para>.Valid Usage **** * pname:oldLayout must: be ename:VK_IMAGE_LAYOUT_UNDEFINED or the current layout of the image subresources affected by the barrier * pname:newLayout must: not be ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED * If pname:image was created with a sharing mode of ename:VK_SHARING_MODE_CONCURRENT, pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex must: both be ename:VK_QUEUE_FAMILY_IGNORED * If pname:image was created with a sharing mode of ename:VK_SHARING_MODE_EXCLUSIVE, pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex must: either both be ename:VK_QUEUE_FAMILY_IGNORED, or both be a valid queue family (see &lt;&lt;devsandqueues-queueprops&gt;&gt;) * If pname:image was created with a sharing mode of ename:VK_SHARING_MODE_EXCLUSIVE, and pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex are valid queue families, at least one of them must: be the same as the family of the queue that will execute this barrier * pname:subresourceRange must: be a valid image subresource range for the image (see &lt;&lt;resources-image-views&gt;&gt;) * If pname:image has a depth/stencil format with both depth and stencil components, then pname:aspectMask member of pname:subresourceRange must: include both ename:VK_IMAGE_ASPECT_DEPTH_BIT and ename:VK_IMAGE_ASPECT_STENCIL_BIT * If either pname:oldLayout or pname:newLayout is ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then pname:image must: have been created with ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT set * If either pname:oldLayout or pname:newLayout is ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL then pname:image must: have been created with ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set * If either pname:oldLayout or pname:newLayout is ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then pname:image must: have been created with ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set * If either pname:oldLayout or pname:newLayout is ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then pname:image must: have been created with ename:VK_IMAGE_USAGE_SAMPLED_BIT or ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set * If either pname:oldLayout or pname:newLayout is ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then pname:image must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT set * If either pname:oldLayout or pname:newLayout is ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then pname:image must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT set ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="srcAccessMask">pname:srcAccessMask is a bitmask of the classes of memory accesses performed by the first set of commands that will participate in the dependency.</member>
        <member name="dstAccessMask">pname:dstAccessMask is a bitmask of the classes of memory accesses performed by the second set of commands that will participate in the dependency.</member>
        <member name="oldLayout">pname:oldLayout describes the current layout of the image subresource(s).</member>
        <member name="newLayout">pname:newLayout describes the new layout of the image subresource(s).</member>
        <member name="srcQueueFamilyIndex">pname:srcQueueFamilyIndex is the queue family that is relinquishing ownership of the image subresource(s) to another queue, or ename:VK_QUEUE_FAMILY_IGNORED if there is no transfer of ownership).</member>
        <member name="dstQueueFamilyIndex">pname:dstQueueFamilyIndex is the queue family that is acquiring ownership of the image subresource(s) from another queue, or ename:VK_QUEUE_FAMILY_IGNORED if there is no transfer of ownership).</member>
        <member name="image">pname:image is a handle to the image whose backing memory is affected by the barrier.</member>
        <member name="subresourceRange">pname:subresourceRange describes an area of the backing memory for pname:image (see &lt;&lt;resources-image-views&gt;&gt; for the description of sname:VkImageSubresourceRange), as well as the set of image subresources whose image layouts are modified.</member>
      </members>
    </type>
    <type name="VkImageResolve" summary="Structure specifying an image resolve operation.">
      <specification />
      <description>
        <para>.Valid Usage **** * The pname:aspectMask member of pname:srcSubresource and pname:dstSubresource must: only contain ename:VK_IMAGE_ASPECT_COLOR_BIT * The pname:layerCount member of pname:srcSubresource and pname:dstSubresource must: match * If either of the calling command's pname:srcImage or pname:dstImage parameters are of elink:VkImageType ename:VK_IMAGE_TYPE_3D, the pname:baseArrayLayer and pname:layerCount members of both pname:srcSubresource and pname:dstSubresource must: be `0` and `1`, respectively * pname:srcOffset.x and (pname:extent.width + pname:srcOffset.x) must: both be greater than or equal to `0` and less than or equal to the source image subresource width * pname:srcOffset.y and (pname:extent.height + pname:srcOffset.y) must: both be greater than or equal to `0` and less than or equal to the source image subresource height ** If the calling command's pname:srcImage is of type ename:VK_IMAGE_TYPE_1D, then pname:srcOffset.y must: be `0` and pname:extent.height must: be `1`. * pname:srcOffset.z and (pname:extent.depth + pname:srcOffset.z) must: both be greater than or equal to `0` and less than or equal to the source image subresource depth ** If the calling command's pname:srcImage is of type ename:VK_IMAGE_TYPE_1D or ename:VK_IMAGE_TYPE_2D, then pname:srcOffset.z must: be `0` and pname:extent.depth must: be `1`. * pname:dstOffset.x and (pname:extent.width + pname:dstOffset.x) must: both be greater than or equal to `0` and less than or equal to the destination image subresource width * pname:dstOffset.y and (pname:extent.height + pname:dstOffset.y) must: both be greater than or equal to `0` and less than or equal to the destination image subresource height ** If the calling command's pname:dstImage is of type ename:VK_IMAGE_TYPE_1D, then pname:dstOffset.y must: be `0` and pname:extent.height must: be `1`. * pname:dstOffset.z and (pname:extent.depth + pname:dstOffset.z) must: both be greater than or equal to `0` and less than or equal to the destination image subresource depth ** If the calling command's pname:dstImage is of type ename:VK_IMAGE_TYPE_1D or ename:VK_IMAGE_TYPE_2D, then pname:dstOffset.z must: be `0` and pname:extent.depth must: be `1`. ****</para>
      </description>
      <members>
        <member name="srcSubresource">pname:srcSubresource and pname:dstSubresource are slink:VkImageSubresourceLayers structures specifying the image subresources of the images used for the source and destination image data, respectively. Resolve of depth/stencil images is not supported.</member>
        <member name="srcOffset">pname:srcOffset and pname:dstOffset select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data.</member>
        <member name="extent">pname:extent is the size in texels of the source image to resolve in pname:width, pname:height and pname:depth.</member>
      </members>
    </type>
    <type name="VkImageSubresource" summary="Structure specifying a image subresource.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:mipLevel must: be less than the pname:mipLevels specified in slink:VkImageCreateInfo when the image was created * pname:arrayLayer must: be less than the pname:arrayLayers specified in slink:VkImageCreateInfo when the image was created ****</para>
      </description>
      <members>
        <member name="aspectMask">pname:aspectMask is a elink:VkImageAspectFlags selecting the image _aspect_.</member>
        <member name="mipLevel">pname:mipLevel selects the mipmap level.</member>
        <member name="arrayLayer">pname:arrayLayer selects the array layer.</member>
      </members>
    </type>
    <type name="VkImageSubresourceLayers" summary="Structure specifying a image subresource layers.">
      <specification />
      <description>
        <para>.Valid Usage **** * If pname:aspectMask contains ename:VK_IMAGE_ASPECT_COLOR_BIT, it must: not contain either of ename:VK_IMAGE_ASPECT_DEPTH_BIT or ename:VK_IMAGE_ASPECT_STENCIL_BIT * pname:aspectMask must: not contain ename:VK_IMAGE_ASPECT_METADATA_BIT * pname:mipLevel must: be less than the pname:mipLevels specified in slink:VkImageCreateInfo when the image was created * [eq]#(pname:baseArrayLayer + pname:layerCount)# must: be less than or equal to the pname:arrayLayers specified in slink:VkImageCreateInfo when the image was created ****</para>
      </description>
      <members>
        <member name="aspectMask">pname:aspectMask is a combination of elink:VkImageAspectFlagBits, selecting the color, depth and/or stencil aspects to be copied.</member>
        <member name="mipLevel">pname:mipLevel is the mipmap level to copy from.</member>
        <member name="baseArrayLayer">pname:baseArrayLayer and pname:layerCount are the starting layer and number of layers to copy.</member>
      </members>
    </type>
    <type name="VkImageSubresourceRange" summary="Structure specifying a image subresource range.">
      <specification />
      <description>
        <para>The number of mipmap levels and array layers must: be a subset of the image subresources in the image. If an application wants to use all mip levels or layers in an image after the pname:baseMipLevel or pname:baseArrayLayer, it can: set pname:levelCount and pname:layerCount to the special values ename:VK_REMAINING_MIP_LEVELS and ename:VK_REMAINING_ARRAY_LAYERS without knowing the exact number of mip levels or layers.</para>
        <para>For cube and cube array image views, the layers of the image view starting at pname:baseArrayLayer correspond to faces in the order +X, -X, +Y, -Y, +Z, -Z. For cube arrays, each set of six sequential layers is a single cube, so the number of cube maps in a cube map array view is _pname:layerCount / 6_, and image array layer _pname:baseArrayLayer + i_ is face index _i mod 6_ of cube _i / 6_. If the number of layers in the view, whether set explicitly in pname:layerCount or implied by ename:VK_REMAINING_ARRAY_LAYERS, is not a multiple of 6, behavior when indexing the last cube is undefined.</para>
        <para>pname:aspectMask is a bitmask indicating the format being used. Bits which may: be set include:</para>
      </description>
      <members>
        <member name="aspectMask">pname:aspectMask is a bitmask indicating which aspect(s) of the image are included in the view. See elink:VkImageAspectFlagBits.</member>
        <member name="baseMipLevel">pname:baseMipLevel is the first mipmap level accessible to the view.</member>
        <member name="levelCount">pname:levelCount is the number of mipmap levels (starting from pname:baseMipLevel) accessible to the view.</member>
        <member name="baseArrayLayer">pname:baseArrayLayer is the first array layer accessible to the view.</member>
        <member name="layerCount">pname:layerCount is the number of array layers (starting from pname:baseArrayLayer) accessible to the view.</member>
      </members>
    </type>
    <type name="VkImageTiling" summary="Specifies the tiling arrangement of data in an image.">
      <specification />
      <description>
        <para>ename:VK_IMAGE_TILING_OPTIMAL specifies optimal tiling (texels are laid out in an implementation-dependent arrangement, for more optimal memory access), and ename:VK_IMAGE_TILING_LINEAR specifies linear tiling (texels are laid out in memory in row-major order, possibly with some padding on each row).</para>
      </description>
      <members />
    </type>
    <type name="VkImageType" summary="Specifies the type of an image object.">
      <specification />
      <description>
        <para>These values specify one-, two-, or three-dimensional images, respectively.</para>
      </description>
      <members />
    </type>
    <type name="VkImageUsageFlagBits" summary="Bitmask specifying intended usage of an image.">
      <specification />
      <description />
      <members>
        <member name="VK_IMAGE_USAGE_TRANSFER_SRC_BIT">ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT indicates that the image can: be used as the source of a transfer command.</member>
        <member name="VK_IMAGE_USAGE_TRANSFER_DST_BIT">ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT indicates that the image can: be used as the destination of a transfer command.</member>
        <member name="VK_IMAGE_USAGE_SAMPLED_BIT">ename:VK_IMAGE_USAGE_SAMPLED_BIT indicates that the image can: be used to create a sname:VkImageView suitable for occupying a sname:VkDescriptorSet slot either of type ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and be sampled by a shader.</member>
        <member name="VK_IMAGE_USAGE_STORAGE_BIT">ename:VK_IMAGE_USAGE_STORAGE_BIT indicates that the image can: be used to create a sname:VkImageView suitable for occupying a sname:VkDescriptorSet slot of type ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.</member>
        <member name="VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT">ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT indicates that the image can: be used to create a sname:VkImageView suitable for use as a color or resolve attachment in a sname:VkFramebuffer.</member>
        <member name="VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT">ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT indicates that the image can: be used to create a sname:VkImageView suitable for use as a depth/stencil attachment in a sname:VkFramebuffer.</member>
        <member name="VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT">ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT indicates that the memory bound to this image will have been allocated with the ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT (see &lt;&lt;memory&gt;&gt; for more detail). This bit can: be set for any image that can: be used to create a sname:VkImageView suitable for use as a color, resolve, depth/stencil, or input attachment.</member>
        <member name="VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT">ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT indicates that the image can: be used to create a sname:VkImageView suitable for occupying sname:VkDescriptorSet slot of type ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT; be read from a shader as an input attachment; and be used as an input attachment in a framebuffer.</member>
      </members>
    </type>
    <type name="VkImageView" summary="Opaque handle to a image view object.">
      <specification>
        <para>Image objects are not directly accessed by pipeline shaders for reading or writing image data. Instead, _image views_ representing contiguous ranges of the image subresources and containing additional metadata are used for that purpose. Views must: be created on images of compatible types, and must: represent a valid subset of image subresources.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkImageViewCreateInfo" summary="Structure specifying parameters of a newly created image view.">
      <specification />
      <description>
        <para>If pname:image was created with the ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, pname:format can: be different from the image's format, but if they are not equal they must: be _compatible_. Image format compatibility is defined in the &lt;&lt;features-formats-compatibility-classes,Format Compatibility Classes&gt;&gt; section.</para>
        <para>.Image and image view parameter compatibility requirements [cols="15%h,35%,50%",options="header"] |==== | Dim, Arrayed, MS | Image parameters | View parameters | | pname:imageType = ci.pname:imageType + pname:width = ci.pname:extent.width + pname:height = ci.pname:extent.height + pname:depth = ci.pname:extent.depth + pname:arrayLayers = ci.pname:arrayLayers + pname:samples = ci.pname:samples + where ci is the slink:VkImageCreateInfo used to create pname:image. | pname:baseArrayLayer and pname:layerCount are members of the pname:subresourceRange member. | 1D, 0, 0 | pname:imageType = ename:VK_IMAGE_TYPE_1D + pname:width {geq} 1 + pname:height = 1 + pname:depth = 1 + pname:arrayLayers {geq} 1 + pname:samples = 1 | pname:viewType = ename:VK_VIEW_TYPE_1D + pname:baseArrayLayer {geq} 0 + pname:layerCount = 1 | 1D, 1, 0 | pname:imageType = ename:VK_IMAGE_TYPE_1D + pname:width {geq} 1 + pname:height = 1 + pname:depth = 1 + pname:arrayLayers {geq} 1 + pname:samples = 1 | pname:viewType = ename:VK_VIEW_TYPE_1D_ARRAY + pname:baseArrayLayer {geq} 0 + pname:layerCount {geq} 1 | 2D, 0, 0 | pname:imageType = ename:VK_IMAGE_TYPE_2D + pname:width {geq} 1 + pname:height {geq} 1 + pname:depth = 1 + pname:arrayLayers {geq} 1 + pname:samples = 1 | pname:viewType = ename:VK_VIEW_TYPE_2D + pname:baseArrayLayer {geq} 0 + pname:layerCount = 1 | 2D, 1, 0 | pname:imageType = ename:VK_IMAGE_TYPE_2D + pname:width {geq} 1 + pname:height {geq} 1 + pname:depth = 1 + pname:arrayLayers {geq} 1 + pname:samples = 1 | pname:viewType = ename:VK_VIEW_TYPE_2D_ARRAY + pname:baseArrayLayer {geq} 0 + pname:layerCount {geq} 1 | 2D, 0, 1 | pname:imageType = ename:VK_IMAGE_TYPE_2D + pname:width {geq} 1 + pname:height {geq} 1 + pname:depth = 1 + pname:arrayLayers {geq} 1 + pname:samples &gt; 1 | pname:viewType = ename:VK_VIEW_TYPE_2D + pname:baseArrayLayer {geq} 0 + pname:layerCount = 1 | 2D, 1, 1 | pname:imageType = ename:VK_IMAGE_TYPE_2D + pname:width {geq} 1 + pname:height {geq} 1 + pname:depth = 1 + pname:arrayLayers {geq} 1 + pname:samples &gt; 1 | pname:viewType = ename:VK_VIEW_TYPE_2D_ARRAY + pname:baseArrayLayer {geq} 0 + pname:layerCount {geq} 1 | CUBE, 0, 0 | pname:imageType = ename:VK_IMAGE_TYPE_2D + pname:width {geq} 1 + pname:height = pname:width + pname:depth = 1 + pname:arrayLayers {geq} 6 + pname:samples = 1 + pname:flags includes ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT | pname:viewType = ename:VK_VIEW_TYPE_CUBE + pname:baseArrayLayer {geq} 0 + pname:layerCount = 6 | CUBE, 1, 0 | pname:imageType = ename:VK_IMAGE_TYPE_2D + pname:width {geq} 1 + pname:height = width + pname:depth = 1 + _N_ {geq} 1 + pname:arrayLayers {geq} 6 {times} _N_ + pname:samples = 1 + pname:flags includes ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT | pname:viewType = ename:VK_VIEW_TYPE_CUBE_ARRAY + pname:baseArrayLayer {geq} 0 + pname:layerCount = 6 {times} _N_, _N_ {geq} 1 | 3D, 0, 0 | pname:imageType = ename:VK_IMAGE_TYPE_3D + pname:width {geq} 1 + pname:height {geq} 1 + pname:depth {geq} 1 + pname:arrayLayers = 1 + pname:samples = 1 | pname:viewType = ename:VK_VIEW_TYPE_3D + pname:baseArrayLayer = 0 + pname:layerCount = 1 |====</para>
        <para>.Valid Usage **** * If pname:image was not created with ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT then pname:viewType must: not be ename:VK_IMAGE_VIEW_TYPE_CUBE or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY * If the &lt;&lt;features-features-imageCubeArray,image cubemap arrays&gt;&gt; feature is not enabled, pname:viewType must: not be ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY * If the &lt;&lt;features-features-textureCompressionETC2,ETC2 texture compression&gt;&gt; feature is not enabled, pname:format must: not be ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK, ename:VK_FORMAT_EAC_R11_UNORM_BLOCK, ename:VK_FORMAT_EAC_R11_SNORM_BLOCK, ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK, or ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK * If the &lt;&lt;features-features-textureCompressionASTC_LDR,ASTC LDR texture compression&gt;&gt; feature is not enabled, pname:format must: not be ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK, ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK, ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK, ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK, ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK, ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK, ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK, ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK, ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK, ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK, ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK, ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK, ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK, or ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK * If the &lt;&lt;features-features-textureCompressionBC,BC texture compression&gt;&gt; feature is not enabled, pname:format must: not be ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK, ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK, ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK, ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK, ename:VK_FORMAT_BC2_UNORM_BLOCK, ename:VK_FORMAT_BC2_SRGB_BLOCK, ename:VK_FORMAT_BC3_UNORM_BLOCK, ename:VK_FORMAT_BC3_SRGB_BLOCK, ename:VK_FORMAT_BC4_UNORM_BLOCK, ename:VK_FORMAT_BC4_SNORM_BLOCK, ename:VK_FORMAT_BC5_UNORM_BLOCK, ename:VK_FORMAT_BC5_SNORM_BLOCK, ename:VK_FORMAT_BC6H_UFLOAT_BLOCK, ename:VK_FORMAT_BC6H_SFLOAT_BLOCK, ename:VK_FORMAT_BC7_UNORM_BLOCK, or ename:VK_FORMAT_BC7_SRGB_BLOCK * If pname:image was created with ename:VK_IMAGE_TILING_LINEAR, pname:format must: be format that has at least one supported feature bit present in the value of sname:VkFormatProperties::pname:linearTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format * If pname:image was created with ename:VK_IMAGE_TILING_LINEAR and pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, pname:format must: be supported for sampled images, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format * If pname:image was created with ename:VK_IMAGE_TILING_LINEAR and pname:usage containing ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:format must: be supported for storage images, as specified by the ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format * If pname:image was created with ename:VK_IMAGE_TILING_LINEAR and pname:usage containing ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, pname:format must: be supported for color attachments, as specified by the ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format * If pname:image was created with ename:VK_IMAGE_TILING_LINEAR and pname:usage containing ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:format must: be supported for depth/stencil attachments, as specified by the ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format * If pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL, pname:format must: be format that has at least one supported feature bit present in the value of sname:VkFormatProperties::pname:optimalTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format * If pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL and pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, pname:format must: be supported for sampled images, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT flag in sname:VkFormatProperties::pname:optimalTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format * If pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL and pname:usage containing ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:format must: be supported for storage images, as specified by the ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT flag in sname:VkFormatProperties::pname:optimalTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format * If pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL and pname:usage containing ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, pname:format must: be supported for color attachments, as specified by the ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT flag in sname:VkFormatProperties::pname:optimalTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format * If pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL and pname:usage containing ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:format must: be supported for depth/stencil attachments, as specified by the ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT flag in sname:VkFormatProperties::pname:optimalTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format * pname:subresourceRange must: be a valid image subresource range for pname:image (see &lt;&lt;resources-image-views&gt;&gt;) * If pname:image was created with the ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, pname:format must: be compatible with the pname:format used to create pname:image, as defined in &lt;&lt;features-formats-compatibility-classes,Format Compatibility Classes&gt;&gt; * If pname:image was not created with the ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, pname:format must: be identical to the pname:format used to create pname:image * pname:subResourceRange and pname:viewType must: be compatible with the image, as described in the &lt;&lt;resources-image-views-compatibility,compatibility table&gt;&gt; ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="image">pname:image is a sname:VkImage on which the view will be created.</member>
        <member name="viewType">pname:viewType is the type of the image view.</member>
        <member name="format">pname:format is a elink:VkFormat describing the format and type used to interpret data elements in the image.</member>
        <member name="components">pname:components specifies a remapping of color components (or of depth or stencil components after they have been converted into color components). See slink:VkComponentMapping.</member>
        <member name="subresourceRange">pname:subresourceRange is a slink:VkImageSubresourceRange selecting the set of mipmap levels and array layers to be accessible to the view.</member>
      </members>
    </type>
    <type name="VkImageViewType" summary="Image view types.">
      <specification />
      <description>
        <para>The exact image view type is partially implicit, based on the image's type and sample count, as well as the view creation parameters as described in the &lt;&lt;resources-image-views-compatibility,table below&gt;&gt;. This table also shows which SPIR-V OpTypeImage Dim and Arrayed parameters correspond to each image view type.</para>
      </description>
      <members />
    </type>
    <type name="VkImportMemoryWin32HandleInfoNV" summary="Import Win32 memory created on the same physical device.">
      <specification>
        <para>To import memory created on the same physical device but outside of the current Vulkan instance, add a slink:VkImportMemoryWin32HandleInfoNV structure to the pname:pNext chain of the slink:VkMemoryAllocateInfo structure, specifying a handle to and the type of the memory.</para>
      </specification>
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="handleType">pname:handleType is 0 or a flag specifying the type of memory handle in pname:handle. Flags which may: be specified are: + --</member>
      </members>
    </type>
    <type name="VkIndexType" summary="Type of index buffer indices.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:offset must: be less than the size of pname:buffer * The sum of pname:offset and the address of the range of sname:VkDeviceMemory object that is backing pname:buffer, must: be a multiple of the type indicated by pname:indexType * pname:buffer must: have been created with the ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT flag ****</para>
      </description>
      <members />
    </type>
    <type name="VkInstance" summary="Opaque handle to a instance object.">
      <specification>
        <para>There is no global state in Vulkan and all per-application state is stored in a sname:VkInstance object. Creating a sname:VkInstance object initializes the Vulkan library and allows the application to pass information about itself to the implementation.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkInstanceCreateInfo" summary="Structure specifying parameters of a newly created instance.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="pApplicationInfo">pname:pApplicationInfo is `NULL` or a pointer to an instance of sname:VkApplicationInfo. If not `NULL`, this information helps implementations recognize behavior inherent to classes of applications. slink:VkApplicationInfo is defined in detail below.</member>
        <member name="enabledLayerCount">pname:enabledLayerCount is the number of global layers to enable.</member>
        <member name="ppEnabledLayerNames">pname:ppEnabledLayerNames is a pointer to an array of pname:enabledLayerCount null-terminated UTF-8 strings containing the names of layers to enable for the created instance. See the &lt;&lt;extended-functionality-layers,Layers&gt;&gt; section for further details.</member>
        <member name="enabledExtensionCount">pname:enabledExtensionCount is the number of global extensions to enable.</member>
        <member name="ppEnabledExtensionNames">pname:ppEnabledExtensionNames is a pointer to an array of pname:enabledExtensionCount null-terminated UTF-8 strings containing the names of extensions to enable.</member>
      </members>
    </type>
    <type name="VkInternalAllocationType" summary="Allocation type.">
      <specification />
      <description />
      <members>
        <member name="VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE">ename:VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - The allocation is intended for execution by the host.</member>
      </members>
    </type>
    <type name="VkLayerProperties" summary="Structure specifying layer properties.">
      <specification />
      <description />
      <members>
        <member name="layerName">pname:layerName is a null-terminated UTF-8 string specifying the name of the layer. Use this name in the pname:ppEnabledLayerNames array passed in the slink:VkInstanceCreateInfo structure to enable this layer for an instance.</member>
        <member name="specVersion">pname:specVersion is the Vulkan version the layer was written to, encoded as described in the &lt;&lt;fundamentals-versionnum,API Version Numbers and Semantics&gt;&gt; section.</member>
        <member name="implementationVersion">pname:implementationVersion is the version of this layer. It is an integer, increasing with backward compatible changes.</member>
        <member name="description">pname:description is a null-terminated UTF-8 string providing additional details that can: be used by the application to identify the layer.</member>
      </members>
    </type>
    <type name="VkLogicOp" summary="Framebuffer logical operations.">
      <specification />
      <description>
        <para>&lt;&lt;&lt;</para>
        <para>The logical operations supported by Vulkan are summarized in the following table in which</para>
        <para>* [eq]#{lnot}# is bitwise invert, * [eq]#{land}# is bitwise and, * [eq]#{lor}# is bitwise or, * [eq]#{oplus}# is bitwise exclusive or, * [eq]#s# is the fragment's [eq]#R~s0~, G~s0~, B~s0~# or [eq]#A~s0~# component value for the fragment output corresponding to the color attachment being updated, and * [eq]#d# is the color attachment's [eq]#R, G, B# or [eq]#A# component value:</para>
        <para>.Logical Operations [width="75%",options="header",align="center"] |==== |Mode                            | Operation |ename:VK_LOGIC_OP_CLEAR         | [eq]#0# |ename:VK_LOGIC_OP_AND           | [eq]#s {land} d# |ename:VK_LOGIC_OP_AND_REVERSE   | [eq]#s {land} {lnot} d# |ename:VK_LOGIC_OP_COPY          | [eq]#s# |ename:VK_LOGIC_OP_AND_INVERTED  | [eq]#{lnot} s {land} d# |ename:VK_LOGIC_OP_NO_OP         | [eq]#d# |ename:VK_LOGIC_OP_XOR           | [eq]#s {oplus} d# |ename:VK_LOGIC_OP_OR            | [eq]#s {lor} d# |ename:VK_LOGIC_OP_NOR           | [eq]#{lnot} (s {lor} d)# |ename:VK_LOGIC_OP_EQUIVALENT    | [eq]#{lnot} (s {oplus} d)# |ename:VK_LOGIC_OP_INVERT        | [eq]#{lnot} d# |ename:VK_LOGIC_OP_OR_REVERSE    | [eq]#s {lor} {lnot} d# |ename:VK_LOGIC_OP_COPY_INVERTED | [eq]#{lnot} s# |ename:VK_LOGIC_OP_OR_INVERTED   | [eq]#{lnot} s {lor} d# |ename:VK_LOGIC_OP_NAND          | [eq]#{lnot} (s {land} d)# |ename:VK_LOGIC_OP_SET           | all 1s |====</para>
        <para>The result of the logical operation is then written to the color attachment as controlled by the component write mask, described in &lt;&lt;framebuffer-blendoperations,Blend Operations&gt;&gt;.</para>
      </description>
      <members />
    </type>
    <type name="VkMappedMemoryRange" summary="Structure specifying a mapped memory range.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:memory must: currently be mapped * If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:offset and pname:size must: specify a range contained within the currently mapped range of pname:memory * If pname:size is equal to ename:VK_WHOLE_SIZE, pname:offset must: be within the currently mapped range of pname:memory * pname:offset must: be a multiple of sname:VkPhysicalDeviceLimits::pname:nonCoherentAtomSize * If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be a multiple of sname:VkPhysicalDeviceLimits::pname:nonCoherentAtomSize ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="memory">pname:memory is the memory object to which this range belongs.</member>
        <member name="offset">pname:offset is the zero-based byte offset from the beginning of the memory object.</member>
        <member name="size">pname:size is either the size of range, or ename:VK_WHOLE_SIZE to affect the range from pname:offset to the end of the current mapping of the allocation.</member>
      </members>
    </type>
    <type name="VkMemoryAllocateInfo" summary="Structure containing parameters of a memory allocation.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:allocationSize must: be less than or equal to the amount of memory available to the sname:VkMemoryHeap specified by pname:memoryTypeIndex and the calling command's sname:VkDevice * pname:allocationSize must: be greater than `0` ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="allocationSize">pname:allocationSize is the size of the allocation in bytes</member>
        <member name="memoryTypeIndex">pname:memoryTypeIndex is the memory type index, which selects the properties of the memory to be allocated, as well as the heap the memory will come from.</member>
      </members>
    </type>
    <type name="VkMemoryBarrier" summary="Structure specifying a memory barrier.">
      <specification />
      <description>
        <para>pname:srcAccessMask and pname:dstAccessMask, along with pname:srcStageMask and pname:dstStageMask from flink:vkCmdPipelineBarrier, define the two halves of a memory dependency and an execution dependency. Memory accesses using the set of access types in pname:srcAccessMask performed in pipeline stages in pname:srcStageMask by the first set of commands must: complete and be available to later commands. The side effects of the first set of commands will be visible to memory accesses using the set of access types in pname:dstAccessMask performed in pipeline stages in pname:dstStageMask by the second set of commands. If the barrier is by-region, these requirements only apply to invocations within the same framebuffer-space region, for pipeline stages that perform framebuffer-space work. The execution dependency guarantees that execution of work by the destination stages of the second set of commands will not begin until execution of work by the source stages of the first set of commands has completed.</para>
        <para>A common type of memory dependency is to avoid a read-after-write hazard. In this case, the source access mask and stages will include writes from a particular stage, and the destination access mask and stages will indicate how those writes will be read in subsequent commands. However, barriers can: also express write-after-read dependencies and write-after-write dependencies, and are even useful to express read-after-read dependencies across an image layout change.</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="srcAccessMask">pname:srcAccessMask is a bitmask of the classes of memory accesses performed by the first set of commands that will participate in the dependency.</member>
        <member name="dstAccessMask">pname:dstAccessMask is a bitmask of the classes of memory accesses performed by the second set of commands that will participate in the dependency.</member>
      </members>
    </type>
    <type name="VkMemoryHeap" summary="Structure specifying a memory heap.">
      <specification />
      <description />
      <members>
        <member name="size">pname:size is the total memory size in bytes in the heap.</member>
        <member name="flags">pname:flags is a bitmask of attribute flags for the heap. The bits specified in pname:flags are: + --</member>
      </members>
    </type>
    <type name="VkMemoryHeapFlagBits" summary="Bitmask specifying attribute flags for a heap.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkMemoryPropertyFlagBits" summary="Bitmask specifying properties for a memory type.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkMemoryRequirements" summary="Structure specifying memory requirements.">
      <specification />
      <description />
      <members>
        <member name="size">pname:size is the size, in bytes, of the memory allocation required: for the resource.</member>
        <member name="alignment">pname:alignment is the alignment, in bytes, of the offset within the allocation required: for the resource.</member>
        <member name="memoryTypeBits">pname:memoryTypeBits is a bitmask and contains one bit set for every supported memory type for the resource. Bit `i` is set if and only if the memory type `i` in the sname:VkPhysicalDeviceMemoryProperties structure for the physical device is supported for the resource.</member>
      </members>
    </type>
    <type name="VkMemoryType" summary="Structure specifying memory type.">
      <specification />
      <description />
      <members>
        <member name="heapIndex">pname:heapIndex describes which memory heap this memory type corresponds to, and must: be less than pname:memoryHeapCount from the sname:VkPhysicalDeviceMemoryProperties structure.</member>
        <member name="propertyFlags">pname:propertyFlags is a bitmask of properties for this memory type. The bits specified in pname:propertyFlags are: + --</member>
      </members>
    </type>
    <type name="VkMirSurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created Mir surface object.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="connection">pname:connection and pname:surface are pointers to the code:MirConnection and code:MirSurface for the window to associate the surface with.</member>
      </members>
    </type>
    <type name="VkOffset2D" summary="Structure specifying a two-dimensional offset.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkOffset3D" summary="Structure specifying a three-dimensional offset.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkPhysicalDevice" summary="Opaque handle to a physical device object.">
      <specification>
        <para>Vulkan separates the concept of _physical_ and _logical_ devices. A physical device usually represents a single device in a system (perhaps made up of several individual hardware devices working together), of which there are a finite number. A logical device represents an application's view of the device.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkPhysicalDeviceFeatures" summary="Structure describing the fine-grained features that can be supported by an implementation.">
      <specification />
      <description>
        <para>The members of the sname:VkPhysicalDeviceFeatures structure describe the following features:</para>
        <para>*  pname:robustBufferAccess indicates that accesses to buffers are bounds-checked against the range of the buffer descriptor (as determined by sname:VkDescriptorBufferInfo::pname:range, sname:VkBufferViewCreateInfo::pname:range, or the size of the buffer). Out of bounds accesses must: not cause application termination, and the effects of shader loads, stores, and atomics must: conform to an implementation-dependent behavior as described below. ** A buffer access is considered to be out of bounds if any of the following are true: *** The pointer was formed by code:OpImageTexelPointer and the coordinate is less than zero or greater than or equal to the number of whole elements in the bound range. *** The pointer was not formed by code:OpImageTexelPointer and the object pointed to is not wholly contained within the bound range. + -- [NOTE] .Note ==== If a SPIR-V code:OpLoad instruction loads a structure and the tail end of the structure is out of bounds, then all members of the structure are considered out of bounds even if the members at the end are not statically used. ==== -- + *** If any buffer access in a given SPIR-V block is determined to be out of bounds, then any other access of the same type (load, store, or atomic) in the same SPIR-V block that accesses an address less than 16 bytes away from the out of bounds address may: also be considered out of bounds. ** Out-of-bounds buffer loads will return any of the following values: *** Values from anywhere within the memory range(s) bound to the buffer (possibly including bytes of memory past the end of the buffer, up to the end of the bound range). *** Zero values, or [eq]#(0,0,0,x)# vectors for vector reads where x is a valid value represented in the type of the vector components and may: be any of: **** 0, 1, or the maximum representable positive integer value, for signed or unsigned integer components **** 0.0 or 1.0, for floating-point components ** Out-of-bounds writes may: modify values within the memory range(s) bound to the buffer, but must: not modify any other memory. ** Out-of-bounds atomics may: modify values within the memory range(s) bound to the buffer, but must: not modify any other memory, and return an undefined value. ** Vertex input attributes are considered out of bounds if the address of the attribute plus the size of the attribute is greater than the size of the bound buffer. Further, if any vertex input attribute using a specific vertex input binding is out of bounds, then all vertex input attributes using that vertex input binding for that vertex shader invocation are considered out of bounds. *** If a vertex input attribute is out of bounds, it will be assigned one of the following values: **** Values from anywhere within the memory range(s) bound to the buffer, converted according to the format of the attribute. **** Zero values, format converted according to the format of the attribute. **** Zero values, or [eq]#(0,0,0,x)# vectors, as described above. ** If pname:robustBufferAccess is not enabled, out of bounds accesses may: corrupt any memory within the process and cause undefined behavior up to and including application termination. *  pname:fullDrawIndexUint32 indicates the full 32-bit range of indices is supported for indexed draw calls when using a elink:VkIndexType of ename:VK_INDEX_TYPE_UINT32. pname:maxDrawIndexedIndexValue is the maximum index value that may: be used (aside from the primitive restart index, which is always 2^32^-1 when the elink:VkIndexType is ename:VK_INDEX_TYPE_UINT32). If this feature is supported, pname:maxDrawIndexedIndexValue must: be 2^32^-1; otherwise it must: be no smaller than 2^24^-1. See &lt;&lt;features-limits-maxDrawIndexedIndexValue,maxDrawIndexedIndexValue&gt;&gt;. *  pname:imageCubeArray indicates whether image views with a elink:VkImageViewType of ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY can: be created, and that the corresponding code:SampledCubeArray and code:ImageCubeArray SPIR-V capabilities can: be used in shader code. *  pname:independentBlend indicates whether the sname:VkPipelineColorBlendAttachmentState settings are controlled independently per-attachment. If this feature is not enabled, the sname:VkPipelineColorBlendAttachmentState settings for all color attachments must: be identical. Otherwise, a different sname:VkPipelineColorBlendAttachmentState can: be provided for each bound color attachment. *  pname:geometryShader indicates whether geometry shaders are supported. If this feature is not enabled, the ename:VK_SHADER_STAGE_GEOMETRY_BIT and ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT enum values must: not be used. This also indicates whether shader modules can: declare the code:Geometry capability. *  pname:tessellationShader indicates whether tessellation control and evaluation shaders are supported. If this feature is not enabled, the ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, and ename:VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO enum values must: not be used. This also indicates whether shader modules can: declare the code:Tessellation capability. *  pname:sampleRateShading indicates whether per-sample shading and multisample interpolation are supported. If this feature is not enabled, the pname:sampleShadingEnable member of the sname:VkPipelineMultisampleStateCreateInfo structure must: be set to ename:VK_FALSE and the pname:minSampleShading member is ignored. This also indicates whether shader modules can: declare the code:SampleRateShading capability. *  pname:dualSrcBlend indicates whether blend operations which take two sources are supported. If this feature is not enabled, the ename:VK_BLEND_FACTOR_SRC1_COLOR, ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, ename:VK_BLEND_FACTOR_SRC1_ALPHA, and ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA enum values must: not be used as source or destination blending factors. See &lt;&lt;framebuffer-dsb&gt;&gt;. *  pname:logicOp indicates whether logic operations are supported. If this feature is not enabled, the pname:logicOpEnable member of the sname:VkPipelineColorBlendStateCreateInfo structure must: be set to ename:VK_FALSE, and the pname:logicOp member is ignored. *  pname:multiDrawIndirect indicates whether multiple draw indirect is supported. If this feature is not enabled, the pname:drawCount parameter to the fname:vkCmdDrawIndirect and fname:vkCmdDrawIndexedIndirect commands must: be 0 or 1. The pname:maxDrawIndirectCount member of the sname:VkPhysicalDeviceLimits structure must: also be 1 if this feature is not supported. See &lt;&lt;features-limits-maxDrawIndirectCount,maxDrawIndirectCount&gt;&gt;. * pname:drawIndirectFirstInstance indicates whether indirect draw calls support the pname:firstInstance parameter. If this feature is not enabled, the pname:firstInstance member of all sname:VkDrawIndirectCommand and sname:VkDrawIndexedIndirectCommand structures that are provided to the fname:vkCmdDrawIndirect and fname:vkCmdDrawIndexedIndirect commands must: be 0. *  pname:depthClamp indicates whether depth clamping is supported. If this feature is not enabled, the pname:depthClampEnable member of the sname:VkPipelineRasterizationStateCreateInfo structure must: be set to ename:VK_FALSE. Otherwise, setting pname:depthClampEnable to ename:VK_TRUE will enable depth clamping. *  pname:depthBiasClamp indicates whether depth bias clamping is supported. If this feature is not enabled, the pname:depthBiasClamp member of the sname:VkPipelineRasterizationStateCreateInfo structure must: be set to 0.0 unless the ename:VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state is enabled, and the pname:depthBiasClamp parameter to fname:vkCmdSetDepthBias must: be set to 0.0. *  pname:fillModeNonSolid indicates whether point and wireframe fill modes are supported. If this feature is not enabled, the ename:VK_POLYGON_MODE_POINT and ename:VK_POLYGON_MODE_LINE enum values must: not be used. *  pname:depthBounds indicates whether depth bounds tests are supported. If this feature is not enabled, the pname:depthBoundsTestEnable member of the sname:VkPipelineDepthStencilStateCreateInfo structure must: be set to ename:VK_FALSE. When pname:depthBoundsTestEnable is set to ename:VK_FALSE, the pname:minDepthBounds and pname:maxDepthBounds members of the sname:VkPipelineDepthStencilStateCreateInfo structure are ignored. *  pname:wideLines indicates whether lines with width other than 1.0 are supported. If this feature is not enabled, the pname:lineWidth member of the sname:VkPipelineRasterizationStateCreateInfo structure must: be set to 1.0 unless the ename:VK_DYNAMIC_STATE_LINE_WIDTH dynamic state is enabled, and the pname:lineWidth parameter to fname:vkCmdSetLineWidth must: be set to 1.0. When this feature is supported, the range and granularity of supported line widths are indicated by the pname:lineWidthRange and pname:lineWidthGranularity members of the sname:VkPhysicalDeviceLimits structure, respectively. *  pname:largePoints indicates whether points with size greater than 1.0 are supported. If this feature is not enabled, only a point size of 1.0 written by a shader is supported. The range and granularity of supported point sizes are indicated by the pname:pointSizeRange and pname:pointSizeGranularity members of the sname:VkPhysicalDeviceLimits structure, respectively. *  pname:alphaToOne indicates whether the implementation is able to replace the alpha value of the color fragment output from the fragment shader with the maximum representable alpha value for fixed-point colors or 1.0 for floating-point colors. If this feature is not enabled, then the pname:alphaToOneEnable member of the sname:VkPipelineMultisampleStateCreateInfo structure must: be set to ename:VK_FALSE. Otherwise setting pname:alphaToOneEnable to ename:VK_TRUE will enable alpha-to-one behavior. *  pname:multiViewport indicates whether more than one viewport is supported. If this feature is not enabled, the pname:viewportCount and pname:scissorCount members of the sname:VkPipelineViewportStateCreateInfo structure must: be set to 1. Similarly, the pname:viewportCount parameter to the fname:vkCmdSetViewport command and the pname:scissorCount parameter to the fname:vkCmdSetScissor command must: be 1, and the pname:firstViewport parameter to the fname:vkCmdSetViewport command and the pname:firstScissor parameter to the fname:vkCmdSetScissor command must: be 0. *  pname:samplerAnisotropy indicates whether anisotropic filtering is supported. If this feature is not enabled, the pname:maxAnisotropy member of the sname:VkSamplerCreateInfo structure must: be 1.0. * pname:textureCompressionETC2 indicates whether the ETC2 and EAC compressed texture formats are supported. If this feature is not enabled, the following formats must: not be used to create images: + -- * ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK * ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK * ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK * ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK * ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK * ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK * ename:VK_FORMAT_EAC_R11_UNORM_BLOCK * ename:VK_FORMAT_EAC_R11_SNORM_BLOCK * ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK * ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK -- + flink:vkGetPhysicalDeviceFormatProperties is used to check for the supported properties of individual formats. + * [[features-features-textureCompressionASTC_LDR]] pname:textureCompressionASTC_LDR indicates whether the ASTC LDR compressed texture formats are supported. If this feature is not enabled, the following formats must: not be used to create images: + -- * ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK * ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK * ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK * ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK * ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK * ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK * ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK * ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK * ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK * ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK * ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK * ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK * ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK * ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK * ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK * ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK * ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK * ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK * ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK * ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK * ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK * ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK * ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK * ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK * ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK * ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK * ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK * ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK -- + flink:vkGetPhysicalDeviceFormatProperties is used to check for the supported properties of individual formats. + *  pname:textureCompressionBC indicates whether the BC compressed texture formats are supported. If this feature is not enabled, the following formats must: not be used to create images: + -- * ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK * ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK * ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK * ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK * ename:VK_FORMAT_BC2_UNORM_BLOCK * ename:VK_FORMAT_BC2_SRGB_BLOCK * ename:VK_FORMAT_BC3_UNORM_BLOCK * ename:VK_FORMAT_BC3_SRGB_BLOCK * ename:VK_FORMAT_BC4_UNORM_BLOCK * ename:VK_FORMAT_BC4_SNORM_BLOCK * ename:VK_FORMAT_BC5_UNORM_BLOCK * ename:VK_FORMAT_BC5_SNORM_BLOCK * ename:VK_FORMAT_BC6H_UFLOAT_BLOCK * ename:VK_FORMAT_BC6H_SFLOAT_BLOCK * ename:VK_FORMAT_BC7_UNORM_BLOCK * ename:VK_FORMAT_BC7_SRGB_BLOCK -- + flink:vkGetPhysicalDeviceFormatProperties is used to check for the supported properties of individual formats. + *  pname:occlusionQueryPrecise indicates whether occlusion queries returning actual sample counts are supported. Occlusion queries are created in a sname:VkQueryPool by specifying the pname:queryType of ename:VK_QUERY_TYPE_OCCLUSION in the sname:VkQueryPoolCreateInfo structure which is passed to fname:vkCreateQueryPool. If this feature is enabled, queries of this type can: enable ename:VK_QUERY_CONTROL_PRECISE_BIT in the pname:flags parameter to fname:vkCmdBeginQuery. If this feature is not supported, the implementation supports only boolean occlusion queries. When any samples are passed, boolean queries will return a non-zero result value, otherwise a result value of zero is returned. When this feature is enabled and ename:VK_QUERY_CONTROL_PRECISE_BIT is set, occlusion queries will report the actual number of samples passed. * pname:pipelineStatisticsQuery indicates whether the pipeline statistics queries are supported. If this feature is not enabled, queries of type ename:VK_QUERY_TYPE_PIPELINE_STATISTICS cannot: be created, and none of the elink:VkQueryPipelineStatisticFlagBits bits can: be set in the pname:pipelineStatistics member of the sname:VkQueryPoolCreateInfo structure. * pname:vertexPipelineStoresAndAtomics indicates whether storage buffers and images support stores and atomic operations in the vertex, tessellation, and geometry shader stages. If this feature is not enabled, all storage image, storage texel buffers, and storage buffer variables used by these stages in shader modules must: be decorated with the code:NonWriteable decoration (or the code:readonly memory qualifier in GLSL). * pname:fragmentStoresAndAtomics indicates whether storage buffers and images support stores and atomic operations in the fragment shader stage. If this feature is not enabled, all storage image, storage texel buffers, and storage buffer variables used by the fragment stage in shader modules must: be decorated with the code:NonWriteable decoration (or the code:readonly memory qualifier in GLSL). * pname:shaderTessellationAndGeometryPointSize indicates whether the code:PointSize built-in decoration is available in the tessellation control, tessellation evaluation, and geometry shader stages. If this feature is not enabled, members decorated with the code:PointSize built-in decoration must: not be read from or written to and all points written from a tessellation or geometry shader will have a size of 1.0. This also indicates whether shader modules can: declare the code:TessellationPointSize capability for tessellation control and evaluation shaders, or if the shader modules can: declare the code:GeometryPointSize capability for geometry shaders. An implementation supporting this feature must: also support one or both of the &lt;&lt;features-features-tessellationShader,pname:tessellationShader&gt;&gt; or &lt;&lt;features-features-geometryShader,pname:geometryShader&gt;&gt; features. * pname:shaderImageGatherExtended indicates whether the extended set of image gather instructions are available in shader code. If this feature is not enabled, the code:OpImage*code:Gather instructions do not support the code:Offset and code:ConstOffsets operands. This also indicates whether shader modules can: declare the code:ImageGatherExtended capability. * pname:shaderStorageImageExtendedFormats indicates whether the extended storage image formats are available in shader code. If this feature is not enabled, the formats requiring the code:StorageImageExtendedFormats capability are not supported for storage images. This also indicates whether shader modules can: declare the code:StorageImageExtendedFormats capability. * pname:shaderStorageImageMultisample indicates whether multisampled storage images are supported. If this feature is not enabled, images that are created with a pname:usage that includes ename:VK_IMAGE_USAGE_STORAGE_BIT must: be created with pname:samples equal to ename:VK_SAMPLE_COUNT_1_BIT. This also indicates whether shader modules can: declare the code:StorageImageMultisample capability. * pname:shaderStorageImageReadWithoutFormat indicates whether storage images require a format qualifier to be specified when reading from storage images. If this feature is not enabled, the code:OpImageRead instruction must: not have an code:OpTypeImage of code:Unknown. This also indicates whether shader modules can: declare the code:StorageImageReadWithoutFormat capability. * pname:shaderStorageImageWriteWithoutFormat indicates whether storage images require a format qualifier to be specified when writing to storage images. If this feature is not enabled, the code:OpImageWrite instruction must: not have an code:OpTypeImage of code:Unknown. This also indicates whether shader modules can: declare the code:StorageImageWriteWithoutFormat capability. * pname:shaderUniformBufferArrayDynamicIndexing indicates whether arrays of uniform buffers can: be indexed by _dynamically uniform_ integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must: be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules can: declare the code:UniformBufferArrayDynamicIndexing capability. * pname:shaderSampledImageArrayDynamicIndexing indicates whether arrays of samplers or sampled images can: be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of ename:VK_DESCRIPTOR_TYPE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must: be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules can: declare the code:SampledImageArrayDynamicIndexing capability. * pname:shaderStorageBufferArrayDynamicIndexing indicates whether arrays of storage buffers can: be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must: be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules can: declare the code:StorageBufferArrayDynamicIndexing capability. * pname:shaderStorageImageArrayDynamicIndexing indicates whether arrays of storage images can: be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must: be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules can: declare the code:StorageImageArrayDynamicIndexing capability. *  pname:shaderClipDistance indicates whether clip distances are supported in shader code. If this feature is not enabled, any members decorated with the code:ClipDistance built-in decoration must: not be read from or written to in shader modules. This also indicates whether shader modules can: declare the code:ClipDistance capability. *  pname:shaderCullDistance indicates whether cull distances are supported in shader code. If this feature is not enabled, any members decorated with the code:CullDistance built-in decoration must: not be read from or written to in shader modules. This also indicates whether shader modules can: declare the code:CullDistance capability. *  pname:shaderFloat64 indicates whether 64-bit floats (doubles) are supported in shader code. If this feature is not enabled, 64-bit floating-point types must: not be used in shader code. This also indicates whether shader modules can: declare the code:Float64 capability. *  pname:shaderInt64 indicates whether 64-bit integers (signed and unsigned) are supported in shader code. If this feature is not enabled, 64-bit integer types must: not be used in shader code. This also indicates whether shader modules can: declare the code:Int64 capability. *  pname:shaderInt16 indicates whether 16-bit integers (signed and unsigned) are supported in shader code. If this feature is not enabled, 16-bit integer types must: not be used in shader code. This also indicates whether shader modules can: declare the code:Int16 capability. * pname:shaderResourceResidency indicates whether image operations that return resource residency information are supported in shader code. If this feature is not enabled, the code:OpImageSparse* instructions must: not be used in shader code. This also indicates whether shader modules can: declare the code:SparseResidency capability. The feature requires at least one of the ptext:sparseResidency* features to be supported. *  pname:shaderResourceMinLod indicates whether image operations that specify the minimum resource level-of-detail (LOD) are supported in shader code. If this feature is not enabled, the code:MinLod image operand must: not be used in shader code. This also indicates whether shader modules can: declare the code:MinLod capability. *  pname:sparseBinding indicates whether resource memory can: be managed at opaque sparse block level instead of at the object level. If this feature is not enabled, resource memory must: be bound only on a per-object basis using the fname:vkBindBufferMemory and fname:vkBindImageMemory commands. In this case, buffers and images must: not be created with ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT and ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in the pname:flags member of the sname:VkBufferCreateInfo and sname:VkImageCreateInfo structures, respectively. Otherwise resource memory can: be managed as described in &lt;&lt;sparsememory-sparseresourcefeatures,Sparse Resource Features&gt;&gt;. *  pname:sparseResidencyBuffer indicates whether the device can: access partially resident buffers. If this feature is not enabled, buffers must: not be created with ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkBufferCreateInfo structure. * pname:sparseResidencyImage2D indicates whether the device can: access partially resident 2D images with 1 sample per pixel. If this feature is not enabled, images with an pname:imageType of ename:VK_IMAGE_TYPE_2D and pname:samples set to ename:VK_SAMPLE_COUNT_1_BIT must: not be created with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkImageCreateInfo structure. * pname:sparseResidencyImage3D indicates whether the device can: access partially resident 3D images. If this feature is not enabled, images with an pname:imageType of ename:VK_IMAGE_TYPE_3D must: not be created with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkImageCreateInfo structure. * pname:sparseResidency2Samples indicates whether the physical device can: access partially resident 2D images with 2 samples per pixel. If this feature is not enabled, images with an pname:imageType of ename:VK_IMAGE_TYPE_2D and pname:samples set to ename:VK_SAMPLE_COUNT_2_BIT must: not be created with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkImageCreateInfo structure. * pname:sparseResidency4Samples indicates whether the physical device can: access partially resident 2D images with 4 samples per pixel. If this feature is not enabled, images with an pname:imageType of ename:VK_IMAGE_TYPE_2D and pname:samples set to ename:VK_SAMPLE_COUNT_4_BIT must: not be created with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkImageCreateInfo structure. * pname:sparseResidency8Samples indicates whether the physical device can: access partially resident 2D images with 8 samples per pixel. If this feature is not enabled, images with an pname:imageType of ename:VK_IMAGE_TYPE_2D and pname:samples set to ename:VK_SAMPLE_COUNT_8_BIT must: not be created with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkImageCreateInfo structure. * pname:sparseResidency16Samples indicates whether the physical device can: access partially resident 2D images with 16 samples per pixel. If this feature is not enabled, images with an pname:imageType of ename:VK_IMAGE_TYPE_2D and pname:samples set to ename:VK_SAMPLE_COUNT_16_BIT must: not be created with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkImageCreateInfo structure. * pname:sparseResidencyAliased indicates whether the physical device can: correctly access data aliased into multiple locations. If this feature is not enabled, the ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT and ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT enum values must: not be used in pname:flags members of the sname:VkBufferCreateInfo and sname:VkImageCreateInfo structures, respectively. * pname:variableMultisampleRate indicates whether all pipelines that will be bound to a command buffer during a subpass with no attachments must: have the same value for sname:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples. If set to ename:VK_TRUE, the implementation supports variable multisample rates in a subpass with no attachments. If set to ename:VK_FALSE, then all pipelines bound in such a subpass must: have the same multisample rate. This has no effect in situations where a subpass uses any attachments. *  pname:inheritedQueries indicates whether a secondary command buffer may: be executed while a query is active.</para>
        <para>.Valid Usage **** * If any member of this structure is ename:VK_FALSE, as returned by flink:vkGetPhysicalDeviceFeatures, then it must: be ename:VK_FALSE when passed as part of the sname:VkDeviceCreateInfo struct when creating a device ****</para>
      </description>
      <members />
    </type>
    <type name="VkPhysicalDeviceLimits" summary="Structure reporting implementation-dependent physical device limits.">
      <specification />
      <description />
      <members>
        <member name="maxImageDimension1D">pname:maxImageDimension1D is the maximum dimension (pname:width) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_1D.</member>
        <member name="maxImageDimension2D">pname:maxImageDimension2D is the maximum dimension (pname:width or pname:height) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_2D and without ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.</member>
        <member name="maxImageDimension3D">pname:maxImageDimension3D is the maximum dimension (pname:width, pname:height, or pname:depth) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_3D.</member>
        <member name="maxImageDimensionCube">pname:maxImageDimensionCube is the maximum dimension (pname:width or pname:height) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_2D and with ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.</member>
        <member name="maxImageArrayLayers">pname:maxImageArrayLayers is the maximum number of layers (pname:arrayLayers) for an image.</member>
        <member name="maxTexelBufferElements">pname:maxTexelBufferElements is the maximum number of addressable texels for a buffer view created on a buffer which was created with the ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the pname:usage member of the sname:VkBufferCreateInfo structure.</member>
        <member name="maxUniformBufferRange">pname:maxUniformBufferRange is the maximum value that can: be specified in the pname:range member of any slink:VkDescriptorBufferInfo structures passed to a call to flink:vkUpdateDescriptorSets for descriptors of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.</member>
        <member name="maxStorageBufferRange">pname:maxStorageBufferRange is the maximum value that can: be specified in the pname:range member of any slink:VkDescriptorBufferInfo structures passed to a call to flink:vkUpdateDescriptorSets for descriptors of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.</member>
        <member name="maxPushConstantsSize">pname:maxPushConstantsSize is the maximum size, in bytes, of the pool of push constant memory. For each of the push constant ranges indicated by the pname:pPushConstantRanges member of the sname:VkPipelineLayoutCreateInfo structure, pname:offset + pname:size must: be less than or equal to this limit.</member>
        <member name="maxMemoryAllocationCount"> pname:maxMemoryAllocationCount is the maximum number of device memory allocations, as created by flink:vkAllocateMemory, which can: simultaneously exist.</member>
        <member name="maxSamplerAllocationCount"> pname:maxSamplerAllocationCount is the maximum number of sampler objects, as created by flink:vkCreateSampler, which can: simultaneously exist on a device.</member>
        <member name="bufferImageGranularity">pname:bufferImageGranularity is the granularity, in bytes, at which buffer or linear image resources, and optimal image resources can: be bound to adjacent offsets in the same sname:VkDeviceMemory object without aliasing. See &lt;&lt;resources-bufferimagegranularity,Buffer-Image Granularity&gt;&gt; for more details.</member>
        <member name="sparseAddressSpaceSize">pname:sparseAddressSpaceSize is the total amount of address space available, in bytes, for sparse memory resources. This is an upper bound on the sum of the size of all sparse resources, regardless of whether any memory is bound to them.</member>
        <member name="maxBoundDescriptorSets">pname:maxBoundDescriptorSets is the maximum number of descriptor sets that can: be simultaneously used by a pipeline. All code:DescriptorSet decorations in shader modules must: have a value less than pname:maxBoundDescriptorSets. See &lt;&lt;descriptorsets-sets&gt;&gt;.</member>
        <member name="maxPerStageDescriptorSamplers"> pname:maxPerStageDescriptorSamplers is the maximum number of samplers that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this limit. A descriptor is accessible to a shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-sampler&gt;&gt; and &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;.</member>
        <member name="maxPerStageDescriptorUniformBuffers"> pname:maxPerStageDescriptorUniformBuffers is the maximum number of uniform buffers that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. A descriptor is accessible to a shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-uniformbuffer&gt;&gt; and &lt;&lt;descriptorsets-uniformbufferdynamic&gt;&gt;.</member>
        <member name="maxPerStageDescriptorStorageBuffers"> pname:maxPerStageDescriptorStorageBuffers is the maximum number of storage buffers that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-storagebuffer&gt;&gt; and &lt;&lt;descriptorsets-storagebufferdynamic&gt;&gt;.</member>
        <member name="maxPerStageDescriptorSampledImages"> pname:maxPerStageDescriptorSampledImages is the maximum number of sampled images that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;, &lt;&lt;descriptorsets-sampledimage&gt;&gt;, and &lt;&lt;descriptorsets-uniformtexelbuffer&gt;&gt;.</member>
        <member name="maxPerStageDescriptorStorageImages"> pname:maxPerStageDescriptorStorageImages is the maximum number of storage images that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-storageimage&gt;&gt;, and &lt;&lt;descriptorsets-storagetexelbuffer&gt;&gt;.</member>
        <member name="maxPerStageDescriptorInputAttachments"> pname:maxPerStageDescriptorInputAttachments is the maximum number of input attachments that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. These are only supported for the fragment stage. See &lt;&lt;descriptorsets-inputattachment&gt;&gt;.</member>
        <member name="maxPerStageResources">pname:maxPerStageResources is the maximum number of resources that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, or ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. For the fragment shader stage the framebuffer color attachments also count against this limit.</member>
        <member name="maxDescriptorSetSamplers"> pname:maxDescriptorSetSamplers is the maximum number of samplers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this limit. See &lt;&lt;descriptorsets-sampler&gt;&gt; and &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;.</member>
        <member name="maxDescriptorSetUniformBuffers"> pname:maxDescriptorSetUniformBuffers is the maximum number of uniform buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. See &lt;&lt;descriptorsets-uniformbuffer&gt;&gt; and &lt;&lt;descriptorsets-uniformbufferdynamic&gt;&gt;.</member>
        <member name="maxDescriptorSetUniformBuffersDynamic"> pname:maxDescriptorSetUniformBuffersDynamic is the maximum number of dynamic uniform buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. See &lt;&lt;descriptorsets-uniformbufferdynamic&gt;&gt;.</member>
        <member name="maxDescriptorSetStorageBuffers"> pname:maxDescriptorSetStorageBuffers is the maximum number of storage buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. See &lt;&lt;descriptorsets-storagebuffer&gt;&gt; and &lt;&lt;descriptorsets-storagebufferdynamic&gt;&gt;.</member>
        <member name="maxDescriptorSetStorageBuffersDynamic"> pname:maxDescriptorSetStorageBuffersDynamic is the maximum number of dynamic storage buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. See &lt;&lt;descriptorsets-storagebufferdynamic&gt;&gt;.</member>
        <member name="maxDescriptorSetSampledImages"> pname:maxDescriptorSetSampledImages is the maximum number of sampled images that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit. See &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;, &lt;&lt;descriptorsets-sampledimage&gt;&gt;, and &lt;&lt;descriptorsets-uniformtexelbuffer&gt;&gt;.</member>
        <member name="maxDescriptorSetStorageImages"> pname:maxDescriptorSetStorageImages is the maximum number of storage images that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit. See &lt;&lt;descriptorsets-storageimage&gt;&gt;, and &lt;&lt;descriptorsets-storagetexelbuffer&gt;&gt;.</member>
        <member name="maxDescriptorSetInputAttachments"> pname:maxDescriptorSetInputAttachments is the maximum number of input attachments that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. See &lt;&lt;descriptorsets-inputattachment&gt;&gt;.</member>
        <member name="maxVertexInputAttributes"> pname:maxVertexInputAttributes is the maximum number of vertex input attributes that can: be specified for a graphics pipeline. These are described in the array of sname:VkVertexInputAttributeDescription structures that are provided at graphics pipeline creation time via the pname:pVertexAttributeDescriptions member of the sname:VkPipelineVertexInputStateCreateInfo structure. See &lt;&lt;fxvertex-attrib&gt;&gt; and &lt;&lt;fxvertex-input&gt;&gt;.</member>
        <member name="maxVertexInputBindings">pname:maxVertexInputBindings is the maximum number of vertex buffers that can: be specified for providing vertex attributes to a graphics pipeline. These are described in the array of sname:VkVertexInputBindingDescription structures that are provided at graphics pipeline creation time via the pname:pVertexBindingDescriptions member of the sname:VkPipelineVertexInputStateCreateInfo structure. The pname:binding member of sname:VkVertexInputBindingDescription must: be less than this limit. See &lt;&lt;fxvertex-input&gt;&gt;.</member>
        <member name="maxVertexInputAttributeOffset"> pname:maxVertexInputAttributeOffset is the maximum vertex input attribute offset that can: be added to the vertex input binding stride. The pname:offset member of the sname:VkVertexInputAttributeDescription structure must: be less than or equal to this limit. See &lt;&lt;fxvertex-input&gt;&gt;.</member>
        <member name="maxVertexInputBindingStride"> pname:maxVertexInputBindingStride is the maximum vertex input binding stride that can: be specified in a vertex input binding. The pname:stride member of the sname:VkVertexInputBindingDescription structure must: be less than or equal to this limit. See &lt;&lt;fxvertex-input&gt;&gt;.</member>
        <member name="maxVertexOutputComponents"> pname:maxVertexOutputComponents is the maximum number of components of output variables which can: be output by a vertex shader. See &lt;&lt;shaders-vertex&gt;&gt;.</member>
        <member name="maxTessellationGenerationLevel"> pname:maxTessellationGenerationLevel is the maximum tessellation generation level supported by the fixed-function tessellation primitive generator. See &lt;&lt;tessellation&gt;&gt;.</member>
        <member name="maxTessellationPatchSize"> pname:maxTessellationPatchSize is the maximum patch size, in vertices, of patches that can: be processed by the tessellation control shader and tessellation primitive generator. The pname:patchControlPoints member of the sname:VkPipelineTessellationStateCreateInfo structure specified at pipeline creation time and the value provided in the code:OutputVertices execution mode of shader modules must: be less than or equal to this limit. See &lt;&lt;tessellation&gt;&gt;.</member>
        <member name="maxTessellationControlPerVertexInputComponents"> pname:maxTessellationControlPerVertexInputComponents is the maximum number of components of input variables which can: be provided as per-vertex inputs to the tessellation control shader stage.</member>
        <member name="maxTessellationControlPerVertexOutputComponents"> pname:maxTessellationControlPerVertexOutputComponents is the maximum number of components of per-vertex output variables which can: be output from the tessellation control shader stage.</member>
        <member name="maxTessellationControlPerPatchOutputComponents"> pname:maxTessellationControlPerPatchOutputComponents is the maximum number of components of per-patch output variables which can: be output from the tessellation control shader stage.</member>
        <member name="maxTessellationControlTotalOutputComponents"> pname:maxTessellationControlTotalOutputComponents is the maximum total number of components of per-vertex and per-patch output variables which can: be output from the tessellation control shader stage.</member>
        <member name="maxTessellationEvaluationInputComponents"> pname:maxTessellationEvaluationInputComponents is the maximum number of components of input variables which can: be provided as per-vertex inputs to the tessellation evaluation shader stage.</member>
        <member name="maxTessellationEvaluationOutputComponents"> pname:maxTessellationEvaluationOutputComponents is the maximum number of components of per-vertex output variables which can: be output from the tessellation evaluation shader stage.</member>
        <member name="maxGeometryShaderInvocations"> pname:maxGeometryShaderInvocations is the maximum invocation count supported for instanced geometry shaders. The value provided in the code:Invocations execution mode of shader modules must: be less than or equal to this limit. See &lt;&lt;geometry&gt;&gt;.</member>
        <member name="maxGeometryInputComponents"> pname:maxGeometryInputComponents is the maximum number of components of input variables which can: be provided as inputs to the geometry shader stage.</member>
        <member name="maxGeometryOutputComponents"> pname:maxGeometryOutputComponents is the maximum number of components of output variables which can: be output from the geometry shader stage.</member>
        <member name="maxGeometryOutputVertices"> pname:maxGeometryOutputVertices is the maximum number of vertices which can: be emitted by any geometry shader.</member>
        <member name="maxGeometryTotalOutputComponents"> pname:maxGeometryTotalOutputComponents is the maximum total number of components of output, across all emitted vertices, which can: be output from the geometry shader stage.</member>
        <member name="maxFragmentInputComponents"> pname:maxFragmentInputComponents is the maximum number of components of input variables which can: be provided as inputs to the fragment shader stage.</member>
        <member name="maxFragmentOutputAttachments"> pname:maxFragmentOutputAttachments is the maximum number of output attachments which can: be written to by the fragment shader stage.</member>
        <member name="maxFragmentDualSrcAttachments"> pname:maxFragmentDualSrcAttachments is the maximum number of output attachments which can: be written to by the fragment shader stage when blending is enabled and one of the dual source blend modes is in use. See &lt;&lt;framebuffer-dsb&gt;&gt; and &lt;&lt;features-features-dualSrcBlend,dualSrcBlend&gt;&gt;.</member>
        <member name="maxFragmentCombinedOutputResources"> pname:maxFragmentCombinedOutputResources is the total number of storage buffers, storage images, and output buffers which can: be used in the fragment shader stage.</member>
        <member name="maxComputeSharedMemorySize"> pname:maxComputeSharedMemorySize is the maximum total storage size, in bytes, of all variables declared with the code:WorkgroupLocal storage class in shader modules (or with the code:shared storage qualifier in GLSL) in the compute shader stage.</member>
        <member name="maxComputeWorkGroupCount"> pname:maxComputeWorkGroupCount[3] is the maximum number of local workgroups that can: be dispatched by a single dispatch command. These three values represent the maximum number of local workgroups for the X, Y, and Z dimensions, respectively. The pname:x, pname:y, and pname:z parameters to the flink:vkCmdDispatch command, or members of the slink:VkDispatchIndirectCommand structure must: be less than or equal to the corresponding limit. See &lt;&lt;dispatch&gt;&gt;.</member>
        <member name="maxComputeWorkGroupInvocations"> pname:maxComputeWorkGroupInvocations is the maximum total number of compute shader invocations in a single local workgroup. The product of the X, Y, and Z sizes as specified by the code:LocalSize execution mode in shader modules and by the object decorated by the code:WorkgroupSize decoration must: be less than or equal to this limit.</member>
        <member name="maxComputeWorkGroupSize"> pname:maxComputeWorkGroupSize[3] is the maximum size of a local compute workgroup, per dimension. These three values represent the maximum local workgroup size in the X, Y, and Z dimensions, respectively. The pname:x, pname:y, and pname:z sizes specified by the code:LocalSize execution mode and by the object decorated by the code:WorkgroupSize decoration in shader modules must: be less than or equal to the corresponding limit.</member>
        <member name="subPixelPrecisionBits">pname:subPixelPrecisionBits is the number of bits of subpixel precision in framebuffer coordinates [eq]#x~f~# and [eq]#y~f~#. See &lt;&lt;primsrast&gt;&gt;.</member>
        <member name="subTexelPrecisionBits">pname:subTexelPrecisionBits is the number of bits of precision in the division along an axis of an image used for minification and magnification filters. [eq]#2^pname:subTexelPrecisionBits^# is the actual number of divisions along each axis of the image represented. The filtering hardware will snap to these locations when computing the filtered results.</member>
        <member name="mipmapPrecisionBits">pname:mipmapPrecisionBits is the number of bits of division that the LOD calculation for mipmap fetching get snapped to when determining the contribution from each mip level to the mip filtered results. [eq]#2^pname:mipmapPrecisionBits^# is the actual number of divisions. + -- [NOTE] .Note ==== For example, if this value is 2 bits then when linearly filtering between two levels, each level could: contribute: 0%, 33%, 66%, or 100% (this is just an example and the amount of contribution should: be covered by different equations in the spec). ==== -- +</member>
        <member name="maxDrawIndexedIndexValue"> pname:maxDrawIndexedIndexValue is the maximum index value that can: be used for indexed draw calls when using 32-bit indices. This excludes the primitive restart index value of 0xFFFFFFFF. See &lt;&lt;features-features-fullDrawIndexUint32,fullDrawIndexUint32&gt;&gt;.</member>
        <member name="maxDrawIndirectCount">pname:maxDrawIndirectCount is the maximum draw count that is supported for indirect draw calls. See &lt;&lt;features-features-multiDrawIndirect,multiDrawIndirect&gt;&gt;.</member>
        <member name="maxSamplerLodBias">pname:maxSamplerLodBias is the maximum absolute sampler level of detail bias. The sum of the pname:mipLodBias member of the sname:VkSamplerCreateInfo structure and the code:Bias operand of image sampling operations in shader modules (or 0 if no code:Bias operand is provided to an image sampling operation) are clamped to the range [eq]#[-pname:maxSamplerLodBias,+pname:maxSamplerLodBias]#. See &lt;&lt;samplers-mipLodBias&gt;&gt;.</member>
        <member name="maxSamplerAnisotropy">pname:maxSamplerAnisotropy is the maximum degree of sampler anisotropy. The maximum degree of anisotropic filtering used for an image sampling operation is the minimum of the pname:maxAnisotropy member of the sname:VkSamplerCreateInfo structure and this limit. See &lt;&lt;samplers-maxAnisotropy&gt;&gt;.</member>
        <member name="maxViewports">pname:maxViewports is the maximum number of active viewports. The pname:viewportCount member of the sname:VkPipelineViewportStateCreateInfo structure that is provided at pipeline creation must: be less than or equal to this limit.</member>
        <member name="maxViewportDimensions">pname:maxViewportDimensions[2] are the maximum viewport dimensions in the X (width) and Y (height) dimensions, respectively. The maximum viewport dimensions must: be greater than or equal to the largest image which can: be created and used as a framebuffer attachment. See &lt;&lt;vertexpostproc-viewport,Controlling the Viewport&gt;&gt;.</member>
        <member name="viewportBoundsRange">pname:viewportBoundsRange[2] is the [eq]#[minimum, maximum]# range that the corners of a viewport must: be contained in. This range must: be at least + -- [eq]#[-2 {times} pname:size, 2 {times} pname:size - 1]#, where [eq]#pname:size = max(pname:maxViewportDimensions[0], maxViewportDimensions[1])# See &lt;&lt;vertexpostproc-viewport,Controlling the Viewport&gt;&gt;.  [NOTE] .Note ==== The intent of the pname:viewportBoundsRange limit is to allow a maximum sized viewport to be arbitrarily shifted relative to the output target as long as at least some portion intersects. This would give a bounds limit of [eq]#[-pname:size + 1, 2 {times} pname:size - 1]# which would allow all possible non-empty-set intersections of the output target and the viewport. Since these numbers are typically powers of two, picking the signed number range using the smallest possible number of bits ends up with the specified range. ==== --</member>
        <member name="viewportSubPixelBits">pname:viewportSubPixelBits is the number of bits of subpixel precision for viewport bounds. The subpixel precision that floating-point viewport bounds are interpreted at is given by this limit.</member>
        <member name="minMemoryMapAlignment">pname:minMemoryMapAlignment is the minimum required: alignment, in bytes, of host visible memory allocations within the host address space. When mapping a memory allocation with flink:vkMapMemory, subtracting pname:offset bytes from the returned pointer will always produce an integer multiple of this limit. See &lt;&lt;memory-device-hostaccess&gt;&gt;.</member>
        <member name="minTexelBufferOffsetAlignment"> pname:minTexelBufferOffsetAlignment is the minimum required: alignment, in bytes, for the pname:offset member of the sname:VkBufferViewCreateInfo structure for texel buffers. When a buffer view is created for a buffer which was created with ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the pname:usage member of the sname:VkBufferCreateInfo structure, the pname:offset must: be an integer multiple of this limit.</member>
        <member name="minUniformBufferOffsetAlignment"> pname:minUniformBufferOffsetAlignment is the minimum required: alignment, in bytes, for the pname:offset member of the sname:VkDescriptorBufferInfo structure for uniform buffers. When a descriptor of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC is updated, the pname:offset must: be an integer multiple of this limit. Similarly, dynamic offsets for uniform buffers must: be multiples of this limit.</member>
        <member name="minStorageBufferOffsetAlignment"> pname:minStorageBufferOffsetAlignment is the minimum required: alignment, in bytes, for the pname:offset member of the sname:VkDescriptorBufferInfo structure for storage buffers. When a descriptor of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC is updated, the pname:offset must: be an integer multiple of this limit. Similarly, dynamic offsets for storage buffers must: be multiples of this limit.</member>
        <member name="minTexelOffset">pname:minTexelOffset is the minimum offset value for the code:ConstOffset image operand of any of the code:OpImageSample* or code:OpImageFetch* image instructions.</member>
        <member name="maxTexelOffset">pname:maxTexelOffset is the maximum offset value for the code:ConstOffset image operand of any of the code:OpImageSample* or code:OpImageFetch* image instructions.</member>
        <member name="minTexelGatherOffset">pname:minTexelGatherOffset is the minimum offset value for the code:Offset or code:ConstOffsets image operands of any of the code:OpImage*code:Gather image instructions.</member>
        <member name="maxTexelGatherOffset">pname:maxTexelGatherOffset is the maximum offset value for the code:Offset or code:ConstOffsets image operands of any of the code:OpImage*code:Gather image instructions.</member>
        <member name="minInterpolationOffset">pname:minInterpolationOffset is the minimum negative offset value for the code:offset operand of the code:InterpolateAtOffset extended instruction.</member>
        <member name="maxInterpolationOffset">pname:maxInterpolationOffset is the maximum positive offset value for the code:offset operand of the code:InterpolateAtOffset extended instruction.</member>
        <member name="subPixelInterpolationOffsetBits"> pname:subPixelInterpolationOffsetBits is the number of subpixel fractional bits that the code:x and code:y offsets to the code:InterpolateAtOffset extended instruction may: be rounded to as fixed-point values.</member>
        <member name="maxFramebufferWidth">pname:maxFramebufferWidth is the maximum width for a framebuffer. The pname:width member of the sname:VkFramebufferCreateInfo structure must: be less than or equal to this limit.</member>
        <member name="maxFramebufferHeight">pname:maxFramebufferHeight is the maximum height for a framebuffer. The pname:height member of the sname:VkFramebufferCreateInfo structure must: be less than or equal to this limit.</member>
        <member name="maxFramebufferLayers">pname:maxFramebufferLayers is the maximum layer count for a layered framebuffer. The pname:layers member of the sname:VkFramebufferCreateInfo structure must: be less than or equal to this limit.</member>
        <member name="framebufferColorSampleCounts"> pname:framebufferColorSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the color sample counts that are supported for all framebuffer color attachments.</member>
        <member name="framebufferDepthSampleCounts"> pname:framebufferDepthSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the supported depth sample counts for all framebuffer depth/stencil attachments, when the format includes a depth component.</member>
        <member name="framebufferStencilSampleCounts">pname:framebufferStencilSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the supported stencil sample counts for all framebuffer depth/stencil attachments, when the format includes a stencil component.</member>
        <member name="framebufferNoAttachmentsSampleCounts">pname:framebufferNoAttachmentsSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the supported sample counts for a framebuffer with no attachments.</member>
        <member name="maxColorAttachments">pname:maxColorAttachments is the maximum number of color attachments that can: be used by a subpass in a render pass. The pname:colorAttachmentCount member of the sname:VkSubpassDescription structure must: be less than or equal to this limit.</member>
        <member name="sampledImageColorSampleCounts"> pname:sampledImageColorSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a non-integer color format.</member>
        <member name="sampledImageIntegerSampleCounts"> pname:sampledImageIntegerSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and an integer color format.</member>
        <member name="sampledImageDepthSampleCounts"> pname:sampledImageDepthSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a depth format.</member>
        <member name="sampledImageStencilSampleCounts"> pname:sampledImageStencilSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a stencil format.</member>
        <member name="storageImageSampleCounts"> pname:storageImageSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, and pname:usage containing ename:VK_IMAGE_USAGE_STORAGE_BIT.</member>
        <member name="maxSampleMaskWords">pname:maxSampleMaskWords is the maximum number of array elements of a variable decorated with the code:SampleMask built-in decoration.</member>
        <member name="timestampComputeAndGraphics"> pname:timestampComputeAndGraphics indicates support for timestamps on all graphics and compute queues. If this limit is set to ename:VK_TRUE, all queues that advertise the ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT in the sname:VkQueueFamilyProperties::pname:queueFlags support sname:VkQueueFamilyProperties::pname:timestampValidBits of at least 36. See &lt;&lt;queries-timestamps, Timestamp Queries&gt;&gt;.</member>
        <member name="timestampPeriod">pname:timestampPeriod is the number of nanoseconds required: for a timestamp query to be incremented by 1. See &lt;&lt;queries-timestamps, Timestamp Queries&gt;&gt;.</member>
        <member name="maxClipDistances">pname:maxClipDistances is the maximum number of clip distances that can: be used in a single shader stage. The size of any array declared with the code:ClipDistance built-in decoration in a shader module must: be less than or equal to this limit.</member>
        <member name="maxCullDistances">pname:maxCullDistances is the maximum number of cull distances that can: be used in a single shader stage. The size of any array declared with the code:CullDistance built-in decoration in a shader module must: be less than or equal to this limit.</member>
        <member name="maxCombinedClipAndCullDistances"> pname:maxCombinedClipAndCullDistances is the maximum combined number of clip and cull distances that can: be used in a single shader stage. The sum of the sizes of any pair of arrays declared with the code:ClipDistance and code:CullDistance built-in decoration used by a single shader stage in a shader module must: be less than or equal to this limit.</member>
        <member name="discreteQueuePriorities"> pname:discreteQueuePriorities is the number of discrete priorities that can: be assigned to a queue based on the value of each member of sname:VkDeviceQueueCreateInfo::pname:pQueuePriorities. This must: be at least 2, and levels must: be spread evenly over the range, with at least one level at 1.0, and another at 0.0. See &lt;&lt;devsandqueues-priority&gt;&gt;.</member>
        <member name="pointSizeRange">pname:pointSizeRange[2] is the range [eq]#[pname:minimum,pname:maximum]# of supported sizes for points. Values written to variables decorated with the code:PointSize built-in decoration are clamped to this range.</member>
        <member name="lineWidthRange">pname:lineWidthRange[2] is the range [eq]#[pname:minimum,pname:maximum]# of supported widths for lines. Values specified by the pname:lineWidth member of the sname:VkPipelineRasterizationStateCreateInfo or the pname:lineWidth parameter to fname:vkCmdSetLineWidth are clamped to this range.</member>
        <member name="pointSizeGranularity">pname:pointSizeGranularity is the granularity of supported point sizes. Not all point sizes in the range defined by pname:pointSizeRange are supported. This limit specifies the granularity (or increment) between successive supported point sizes.</member>
        <member name="lineWidthGranularity">pname:lineWidthGranularity is the granularity of supported line widths. Not all line widths in the range defined by pname:lineWidthRange are supported. This limit specifies the granularity (or increment) between successive supported line widths.</member>
        <member name="strictLines">pname:strictLines indicates whether lines are rasterized according to the preferred method of rasterization. If set to ename:VK_FALSE, lines may: be rasterized under a relaxed set of rules. If set to ename:VK_TRUE, lines are rasterized as per the strict definition. See &lt;&lt;primsrast-lines-basic,Basic Line Segment Rasterization&gt;&gt;.</member>
        <member name="standardSampleLocations"> pname:standardSampleLocations indicates whether rasterization uses the standard sample locations as documented in &lt;&lt;primsrast-multisampling,Multisampling&gt;&gt;. If set to ename:VK_TRUE, the implementation uses the documented sample locations. If set to ename:VK_FALSE, the implementation may: use different sample locations.</member>
        <member name="optimalBufferCopyOffsetAlignment"> pname:optimalBufferCopyOffsetAlignment is the optimal buffer offset alignment in bytes for fname:vkCmdCopyBufferToImage and fname:vkCmdCopyImageToBuffer. The per texel alignment requirements are still enforced, this is just an additional alignment recommendation for optimal performance and power.</member>
        <member name="optimalBufferCopyRowPitchAlignment"> pname:optimalBufferCopyRowPitchAlignment is the optimal buffer row pitch alignment in bytes for fname:vkCmdCopyBufferToImage and fname:vkCmdCopyImageToBuffer. Row pitch is the number of bytes between texels with the same X coordinate in adjacent rows (Y coordinates differ by one). The per texel alignment requirements are still enforced, this is just an additional alignment recommendation for optimal performance and power.</member>
        <member name="nonCoherentAtomSize">pname:nonCoherentAtomSize is the size and alignment in bytes that bounds concurrent access to &lt;&lt;memory-device-hostaccess, host-mapped device memory&gt;&gt;.</member>
      </members>
    </type>
    <type name="VkPhysicalDeviceMemoryProperties" summary="Structure specifying physical device memory properties.">
      <specification />
      <description>
        <para>The sname:VkPhysicalDeviceMemoryProperties structure describes a number of _memory heaps_ as well as a number of _memory types_ that can: be used to access memory allocated in those heaps. Each heap describes a memory resource of a particular size, and each memory type describes a set of memory properties (e.g. host cached vs uncached) that can: be used with a given memory heap. Allocations using a particular memory type will consume resources from the heap indicated by that memory type's heap index. More than one memory type may: share each heap, and the heaps and memory types provide a mechanism to advertise an accurate size of the physical memory resources while allowing the memory to be used with a variety of different properties.</para>
        <para>The number of memory heaps is given by pname:memoryHeapCount and is less than or equal to ename:VK_MAX_MEMORY_HEAPS. Each heap is described by an element of the pname:memoryHeaps array, as a sname:VkMemoryHeap structure. The number of memory types available across all memory heaps is given by pname:memoryTypeCount and is less than or equal to ename:VK_MAX_MEMORY_TYPES. Each memory type is described by an element of the pname:memoryTypes array, as a sname:VkMemoryType structure.</para>
        <para>At least one heap must: include ename:VK_MEMORY_HEAP_DEVICE_LOCAL_BIT in slink:VkMemoryHeap::pname:flags. If there are multiple heaps that all have similar performance characteristics, they may: all include ename:VK_MEMORY_HEAP_DEVICE_LOCAL_BIT. In a unified memory architecture (UMA) system, there is often only a single memory heap which is considered to be equally ``local'' to the host and to the device, and such an implementation must: advertise the heap as device-local.</para>
        <para>Each memory type returned by flink:vkGetPhysicalDeviceMemoryProperties must: have its pname:propertyFlags set to one of the following values:</para>
        <para>* 0 * ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT * ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | ename:VK_MEMORY_PROPERTY_HOST_CACHED_BIT * ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | ename:VK_MEMORY_PROPERTY_HOST_CACHED_BIT | ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | ename:VK_MEMORY_PROPERTY_HOST_CACHED_BIT * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | ename:VK_MEMORY_PROPERTY_HOST_CACHED_BIT | ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</para>
        <para>There must: be at least one memory type with both the ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT and ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT bits set in its pname:propertyFlags. There must: be at least one memory type with the ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT bit set in its pname:propertyFlags.</para>
        <para>The memory types are sorted according to a preorder which serves to aid in easily selecting an appropriate memory type. Given two memory types X and Y, the preorder defines [eq]#X {leq} Y# if:</para>
        <para>* the memory property bits set for X are a strict subset of the memory property bits set for Y. Or, * the memory property bits set for X are the same as the memory property bits set for Y, and X uses a memory heap with greater or equal performance (as determined in an implementation-specific manner).</para>
        <para>Memory types are ordered in the list such that X is assigned a lesser pname:memoryTypeIndex than Y if [eq]#(X {leq} Y) {land} {lnot} (Y {leq} X)# according to the preorder. Note that the list of all allowed memory property flag combinations above satisfies this preorder, but other orders would as well. The goal of this ordering is to enable applications to use a simple search loop in selecting the proper memory type, along the lines of:</para>
        <para>[source,{basebackend@docbook:c++:cpp}] --------------------------------------------------- // Find a memory type in "memoryTypeBits" that includes all of "properties" int32_t FindProperties(uint32_t memoryTypeBits, VkMemoryPropertyFlags properties) { for (int32_t i = 0; i &lt; memoryTypeCount; ++i) { if ((memoryTypeBits &amp; (1 &lt;&lt; i)) &amp;&amp; ((memoryTypes[i].propertyFlags &amp; properties) == properties)) return i; } return -1; }</para>
        <para>// Try to find an optimal memory type, or if it does not exist // find any compatible memory type VkMemoryRequirements memoryRequirements; vkGetImageMemoryRequirements(device, image, &amp;memoryRequirements); int32_t memoryType = FindProperties(memoryRequirements.memoryTypeBits, optimalProperties); if (memoryType == -1) memoryType = FindProperties(memoryRequirements.memoryTypeBits, requiredProperties); ---------------------------------------------------</para>
        <para>The loop will find the first supported memory type that has all bits requested in code:properties set. If there is no exact match, it will find a closest match (i.e. a memory type with the fewest additional bits set), which has some additional bits set but which are not detrimental to the behaviors requested by code:properties. The application can: first search for the optimal properties, e.g. a memory type that is device-local or supports coherent cached accesses, as appropriate for the intended usage, and if such a memory type is not present can: fallback to searching for a less optimal but guaranteed set of properties such as "0" or "host-visible and coherent".</para>
      </description>
      <members>
        <member name="memoryTypeCount">pname:memoryTypeCount is the number of valid elements in the pname:memoryTypes array.</member>
        <member name="memoryTypes">pname:memoryTypes is an array of slink:VkMemoryType structures describing the _memory types_ that can: be used to access memory allocated from the heaps specified by pname:memoryHeaps.</member>
        <member name="memoryHeapCount">pname:memoryHeapCount is the number of valid elements in the pname:memoryHeaps array.</member>
        <member name="memoryHeaps">pname:memoryHeaps is an array of slink:VkMemoryHeap structures describing the _memory heaps_ from which memory can: be allocated.</member>
      </members>
    </type>
    <type name="VkPhysicalDeviceProperties" summary="Structure specifying physical device properties.">
      <specification />
      <description>
        <para>The pname:vendorID and pname:deviceID fields are provided to allow applications to adapt to device characteristics that are not adequately exposed by other Vulkan queries. These may: include performance profiles, hardware errata, or other characteristics. In PCI-based implementations, the low sixteen bits of pname:vendorID and pname:deviceID must: contain (respectively) the PCI vendor and device IDs associated with the hardware device, and the remaining bits must: be set to zero. In non-PCI implementations, the choice of what values to return may: be dictated by operating system or platform policies. It is otherwise at the discretion of the implementer, subject to the following constraints and guidelines:</para>
        <para>* For purposes of physical device identification, the _vendor_ of a physical device is the entity responsible for the most salient characteristics of the hardware represented by the physical device handle. In the case of a discrete GPU, this should: be the GPU chipset vendor. In the case of a GPU or other accelerator integrated into a system-on-chip (SoC), this should: be the supplier of the silicon IP used to create the GPU or other accelerator. * If the vendor of the physical device has a valid PCI vendor ID issued by https://pcisig.com/[PCI-SIG], that ID should: be used to construct pname:vendorID as described above for PCI-based implementations. Implementations that do not return a PCI vendor ID in pname:vendorID must: return a valid Khronos vendor ID, obtained as described in the &lt;&lt;vulkan-styleguide,Vulkan Documentation and Extensions&gt;&gt; document in the section ``Registering a Vendor ID with Khronos''. Khronos vendor IDs are allocated starting at 0x10000, to distinguish them from the PCI vendor ID namespace. * The vendor of the physical device is responsible for selecting pname:deviceID. The value selected should: uniquely identify both the device version and any major configuration options (for example, core count in the case of multicore devices). The same device ID should: be used for all physical implementations of that device version and configuration. For example, all uses of a specific silicon IP GPU version and configuration should: use the same device ID, even if those uses occur in different SoCs.</para>
      </description>
      <members>
        <member name="apiVersion">pname:apiVersion is the version of Vulkan supported by the device, encoded as described in the &lt;&lt;fundamentals-versionnum,API Version Numbers and Semantics&gt;&gt; section.</member>
        <member name="driverVersion">pname:driverVersion is the vendor-specified version of the driver.</member>
        <member name="vendorID">pname:vendorID is a unique identifier for the _vendor_ (see below) of the physical device.</member>
        <member name="deviceID">pname:deviceID is a unique identifier for the physical device among devices available from the vendor.</member>
        <member name="deviceType">pname:deviceType is a elink:VkPhysicalDeviceType specifying the type of device.</member>
        <member name="deviceName">pname:deviceName is a null-terminated UTF-8 string containing the name of the device.</member>
        <member name="pipelineCacheUUID">pname:pipelineCacheUUID is an array of size ename:VK_UUID_SIZE, containing 8-bit values that represent a universally unique identifier for the device.</member>
        <member name="limits">pname:limits is the slink:VkPhysicalDeviceLimits structure which specifies device-specific limits of the physical device. See &lt;&lt;features-limits,Limits&gt;&gt; for details.</member>
        <member name="sparseProperties">pname:sparseProperties is the slink:VkPhysicalDeviceSparseProperties structure which specifies various sparse related properties of the physical device. See &lt;&lt;sparsememory-physicalprops,Sparse Properties&gt;&gt; for details.</member>
      </members>
    </type>
    <type name="VkPhysicalDeviceSparseProperties" summary="Structure specifying physical device sparse memory properties.">
      <specification />
      <description />
      <members>
        <member name="residencyStandard2DBlockShape">pname:residencyStandard2DBlockShape is ename:VK_TRUE if the physical device will access all single-sample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the &lt;&lt;sparsememory-sparseblockshapessingle,Standard Sparse Image Block Shapes (Single Sample)&gt;&gt; table. If this property is not supported the value returned in the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure for single-sample 2D images is not required: to match the standard sparse image block dimensions listed in the table.</member>
        <member name="residencyStandard2DMultisampleBlockShape">pname:residencyStandard2DMultisampleBlockShape is ename:VK_TRUE if the physical device will access all multisample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the &lt;&lt;sparsememory-sparseblockshapesmsaa,Standard Sparse Image Block Shapes (MSAA)&gt;&gt; table. If this property is not supported, the value returned in the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure for multisample 2D images is not required: to match the standard sparse image block dimensions listed in the table.</member>
        <member name="residencyStandard3DBlockShape">pname:residencyStandard3DBlockShape is ename:VK_TRUE if the physical device will access all 3D sparse resources using the standard sparse image block shapes (based on image format), as described in the &lt;&lt;sparsememory-sparseblockshapessingle,Standard Sparse Image Block Shapes (Single Sample)&gt;&gt; table. If this property is not supported, the value returned in the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure for 3D images is not required: to match the standard sparse image block dimensions listed in the table.</member>
        <member name="residencyAlignedMipSize">pname:residencyAlignedMipSize is ename:VK_TRUE if images with mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block may: be placed in the mip tail. If this property is not reported, only mip levels with dimensions smaller than the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure will be placed in the mip tail. If this property is reported the implementation is allowed to return ename:VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT in the pname:flags member of sname:VkSparseImageFormatProperties, indicating that mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block will be placed in the mip tail.</member>
        <member name="residencyNonResidentStrict">pname:residencyNonResidentStrict specifies whether the physical device can: consistently access non-resident regions of a resource. If this property is ename:VK_TRUE, access to non-resident regions of resources will be guaranteed to return values as if the resource were populated with 0; writes to non-resident regions will be discarded.</member>
      </members>
    </type>
    <type name="VkPhysicalDeviceType" summary="Supported physical device types.">
      <specification />
      <description>
        <para>The physical device type is advertised for informational purposes only, and does not directly affect the operation of the system. However, the device type may: correlate with other advertised properties or capabilities of the system, such as how many memory heaps there are.</para>
      </description>
      <members>
        <member name="VK_PHYSICAL_DEVICE_TYPE_OTHER">ename:VK_PHYSICAL_DEVICE_TYPE_OTHER The device does not match any other available types.</member>
        <member name="VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU">ename:VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU The device is typically one embedded in or tightly coupled with the host.</member>
        <member name="VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU">ename:VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU The device is typically a separate processor connected to the host via an interlink.</member>
        <member name="VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU">ename:VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU The device is typically a virtual node in a virtualization environment.</member>
        <member name="VK_PHYSICAL_DEVICE_TYPE_CPU">ename:VK_PHYSICAL_DEVICE_TYPE_CPU The device is typically running on the same processors as the host.</member>
      </members>
    </type>
    <type name="VkPipeline" summary="Opaque handle to a pipeline object.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkPipelineBindPoint" summary="Specify the bind point of a pipeline object to a command buffer.">
      <specification />
      <description>
        <para>Once bound, a pipeline binding affects subsequent graphics or compute commands in the command buffer until a different pipeline is bound to the bind point. The pipeline bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE controls the behavior of flink:vkCmdDispatch and flink:vkCmdDispatchIndirect. The pipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS controls the behavior of flink:vkCmdDraw, flink:vkCmdDrawIndexed, flink:vkCmdDrawIndirect, and flink:vkCmdDrawIndexedIndirect. No other commands are affected by the pipeline state.</para>
        <para>.Valid Usage **** * If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_COMPUTE, the sname:VkCommandPool that pname:commandBuffer was allocated from must: support compute operations * If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_GRAPHICS, the sname:VkCommandPool that pname:commandBuffer was allocated from must: support graphics operations * If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_COMPUTE, pname:pipeline must: be a compute pipeline * If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_GRAPHICS, pname:pipeline must: be a graphics pipeline * If the &lt;&lt;features-features-variableMultisampleRate,variable multisample rate&gt;&gt; feature is not supported, pname:pipeline is a graphics pipeline, the current subpass has no attachments, and this is not the first call to this function with a graphics pipeline after transitioning to the current subpass, then the sample count specified by this pipeline must: match that set in the previous pipeline ****</para>
      </description>
      <members />
    </type>
    <type name="VkPipelineCache" summary="Opaque handle to a pipeline cache object.">
      <specification>
        <para>Pipeline cache objects allow the result of pipeline construction to be reused between pipelines and between runs of an application. Reuse between pipelines is achieved by passing the same pipeline cache object when creating multiple related pipelines. Reuse across runs of an application is achieved by retrieving pipeline cache contents in one run of an application, saving the contents, and using them to preinitialize a pipeline cache on a subsequent run. The contents of the pipeline cache objects are managed by the implementation. Applications can: manage the host memory consumed by a pipeline cache object and control the amount of data retrieved from a pipeline cache object.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkPipelineCacheCreateInfo" summary="Structure specifying parameters of a newly created pipeline cache.">
      <specification />
      <description>
        <para>.Valid Usage **** * If pname:initialDataSize is not `0`, it must: be equal to the size of pname:pInitialData, as returned by fname:vkGetPipelineCacheData when pname:pInitialData was originally retrieved * If pname:initialDataSize is not `0`, pname:pInitialData must: have been retrieved from a previous call to fname:vkGetPipelineCacheData ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="initialDataSize">pname:initialDataSize is the number of bytes in pname:pInitialData. If pname:initialDataSize is zero, the pipeline cache will initially be empty.</member>
        <member name="pInitialData">pname:pInitialData is a pointer to previously retrieved pipeline cache data. If the pipeline cache data is incompatible (as defined below) with the device, the pipeline cache will be initially empty. If pname:initialDataSize is zero, pname:pInitialData is ignored.</member>
      </members>
    </type>
    <type name="VkPipelineCacheHeaderVersion" summary="Encode pipeline cache version.">
      <specification />
      <description>
        <para>A consumer of the pipeline cache should: use the cache version to interpret the remainder of the cache header.</para>
      </description>
      <members />
    </type>
    <type name="VkPipelineColorBlendAttachmentState" summary="Structure specifying a pipeline color blend attachment state.">
      <specification />
      <description>
        <para>.Valid Usage **** * If the &lt;&lt;features-features-dualSrcBlend,dual source blending&gt;&gt; feature is not enabled, pname:srcColorBlendFactor must: not be ename:VK_BLEND_FACTOR_SRC1_COLOR, ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, ename:VK_BLEND_FACTOR_SRC1_ALPHA, or ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA * If the &lt;&lt;features-features-dualSrcBlend,dual source blending&gt;&gt; feature is not enabled, pname:dstColorBlendFactor must: not be ename:VK_BLEND_FACTOR_SRC1_COLOR, ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, ename:VK_BLEND_FACTOR_SRC1_ALPHA, or ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA * If the &lt;&lt;features-features-dualSrcBlend,dual source blending&gt;&gt; feature is not enabled, pname:srcAlphaBlendFactor must: not be ename:VK_BLEND_FACTOR_SRC1_COLOR, ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, ename:VK_BLEND_FACTOR_SRC1_ALPHA, or ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA * If the &lt;&lt;features-features-dualSrcBlend,dual source blending&gt;&gt; feature is not enabled, pname:dstAlphaBlendFactor must: not be ename:VK_BLEND_FACTOR_SRC1_COLOR, ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, ename:VK_BLEND_FACTOR_SRC1_ALPHA, or ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA ****</para>
      </description>
      <members>
        <member name="blendEnable">pname:blendEnable controls whether blending is enabled for the corresponding color attachment. If blending is not enabled, the source fragment's color for that attachment is passed through unmodified.</member>
        <member name="srcColorBlendFactor">pname:srcColorBlendFactor selects which blend factor is used to determine the source factors [eq]#(S~r~,S~g~,S~b~)#.</member>
        <member name="dstColorBlendFactor">pname:dstColorBlendFactor selects which blend factor is used to determine the destination factors [eq]#(D~r~,D~g~,D~b~)#.</member>
        <member name="colorBlendOp">pname:colorBlendOp selects which blend operation is used to calculate the RGB values to write to the color attachment.</member>
        <member name="srcAlphaBlendFactor">pname:srcAlphaBlendFactor selects which blend factor is used to determine the source factor [eq]#S~a~#.</member>
        <member name="dstAlphaBlendFactor">pname:dstAlphaBlendFactor selects which blend factor is used to determine the destination factor [eq]#D~a~#.</member>
        <member name="alphaBlendOp">pname:alphaBlendOp selects which blend operation is use to calculate the alpha values to write to the color attachment.</member>
        <member name="colorWriteMask">pname:colorWriteMask is a bitmask selecting which of the R, G, B, and/or A components are enabled for writing, as described later in this chapter.</member>
      </members>
    </type>
    <type name="VkPipelineColorBlendStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline color blend state.">
      <specification />
      <description>
        <para>Each element of the pname:pAttachments array is a slink:VkPipelineColorBlendAttachmentState structure specifying per-target blending state for each individual color attachment. If the &lt;&lt;features-features-independentBlend,independent blending&gt;&gt; feature is not enabled on the device, all slink:VkPipelineColorBlendAttachmentState elements in the pname:pAttachments array must: be identical.</para>
        <para>.Valid Usage **** * If the &lt;&lt;features-features-independentBlend,independent blending&gt;&gt; feature is not enabled, all elements of pname:pAttachments must: be identical * If the &lt;&lt;features-features-logicOp,logic operations&gt;&gt; feature is not enabled, pname:logicOpEnable must: be ename:VK_FALSE * If pname:logicOpEnable is ename:VK_TRUE, pname:logicOp must: be a valid elink:VkLogicOp value ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="logicOpEnable">pname:logicOpEnable controls whether to apply &lt;&lt;framebuffer-logicop, Logical Operations&gt;&gt;.</member>
        <member name="logicOp">pname:logicOp selects which logical operation to apply.</member>
        <member name="attachmentCount">pname:attachmentCount is the number of sname:VkPipelineColorBlendAttachmentState elements in pname:pAttachments. This value must: equal the pname:colorAttachmentCount for the subpass in which this pipeline is used.</member>
        <member name="pAttachments">pname:pAttachments: is a pointer to array of per target attachment states.</member>
        <member name="blendConstants">pname:blendConstants is an array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the &lt;&lt;framebuffer-blendfactors,blend factor&gt;&gt;.</member>
      </members>
    </type>
    <type name="VkPipelineCreateFlagBits" summary="Bitmask controlling how a pipeline is generated.">
      <specification />
      <description>
        <para>It is valid to set both ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT and ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT. This allows a pipeline to be both a parent and possibly a child in a pipeline hierarchy. See &lt;&lt;pipelines-pipeline-derivatives,Pipeline Derivatives&gt;&gt; for more information.</para>
        <para>pname:pDynamicState points to a structure of type sname:VkPipelineDynamicStateCreateInfo.</para>
        <para>ifdef::VK_NV_glsl_shader[] If any shader stage fails to compile, ifdef::VK_EXT_debug_report[] the compile log will be reported back to the application, and endif::VK_EXT_debug_report[] ename:VK_ERROR_INVALID_SHADER_NV will be generated. endif::VK_NV_glsl_shader[]</para>
        <para>.Valid Usage **** * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineIndex is not `-1`, pname:basePipelineHandle must: be dlink:VK_NULL_HANDLE * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineIndex is not `-1`, it must: be a valid index into the calling command's pname:pCreateInfos parameter * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineHandle is not dlink:VK_NULL_HANDLE, pname:basePipelineIndex must: be `-1` * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineHandle is not dlink:VK_NULL_HANDLE, pname:basePipelineHandle must: be a valid sname:VkPipeline handle * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineHandle is not dlink:VK_NULL_HANDLE, it must: be a valid handle to a graphics sname:VkPipeline * The pname:stage member of each element of pname:pStages must: be unique * The pname:stage member of one element of pname:pStages must: be ename:VK_SHADER_STAGE_VERTEX_BIT * The pname:stage member of any given element of pname:pStages must: not be ename:VK_SHADER_STAGE_COMPUTE_BIT * If pname:pStages includes a tessellation control shader stage, it must: include a tessellation evaluation shader stage * If pname:pStages includes a tessellation evaluation shader stage, it must: include a tessellation control shader stage * If pname:pStages includes a tessellation control shader stage and a tessellation evaluation shader stage, pname:pTessellationState must: not be `NULL` * If pname:pStages includes tessellation shader stages, the shader code of at least one stage must: contain an code:OpExecutionMode instruction that specifies the type of subdivision in the pipeline * If pname:pStages includes tessellation shader stages, and the shader code of both stages contain an code:OpExecutionMode instruction that specifies the type of subdivision in the pipeline, they must: both specify the same subdivision mode * If pname:pStages includes tessellation shader stages, the shader code of at least one stage must: contain an code:OpExecutionMode instruction that specifies the output patch size in the pipeline * If pname:pStages includes tessellation shader stages, and the shader code of both contain an code:OpExecutionMode instruction that specifies the out patch size in the pipeline, they must: both specify the same patch size * If pname:pStages includes tessellation shader stages, the pname:topology member of pname:pInputAssembly must: be ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST * If the pname:topology member of pname:pInputAssembly is ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, pname:pStages must: include tessellation shader stages * If pname:pStages includes a geometry shader stage, and does not include any tessellation shader stages, its shader code must: contain an code:OpExecutionMode instruction that specifies an input primitive type that is &lt;&lt;shaders-geometry-execution, compatible&gt;&gt; with the primitive topology specified in pname:pInputAssembly * If pname:pStages includes a geometry shader stage, and also includes tessellation shader stages, its shader code must: contain an code:OpExecutionMode instruction that specifies an input primitive type that is &lt;&lt;shaders-geometry-execution, compatible&gt;&gt; with the primitive topology that is output by the tessellation stages * If pname:pStages includes a fragment shader stage and a geometry shader stage, and the fragment shader code reads from an input variable that is decorated with code:PrimitiveID, then the geometry shader code must: write to a matching output variable, decorated with code:PrimitiveID, in all execution paths * If pname:pStages includes a fragment shader stage, its shader code must: not read from any input attachment that is defined as ename:VK_ATTACHMENT_UNUSED in pname:subpass * The shader code for the entry points identified by pname:pStages, and the rest of the state identified by this structure must: adhere to the pipeline linking rules described in the &lt;&lt;interfaces,Shader Interfaces&gt;&gt; chapter * If pname:subpass uses a depth/stencil attachment in pname:renderpass that has a layout of ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL in the sname:VkAttachmentReference defined by pname:subpass, and pname:pDepthStencilState is not `NULL`, the pname:depthWriteEnable member of pname:pDepthStencilState must: be ename:VK_FALSE * If pname:subpass uses a depth/stencil attachment in pname:renderpass that has a layout of ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL in the sname:VkAttachmentReference defined by pname:subpass, and pname:pDepthStencilState is not `NULL`, the pname:failOp, pname:passOp and pname:depthFailOp members of each of the pname:front and pname:back members of pname:pDepthStencilState must: be ename:VK_STENCIL_OP_KEEP * If pname:pColorBlendState is not `NULL`, the pname:blendEnable member of each element of the pname:pAttachment member of pname:pColorBlendState must: be ename:VK_FALSE if the pname:format of the attachment referred to in pname:subpass of pname:renderPass does not support color blend operations, as specified by the ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures or sname:VkFormatProperties::pname:optimalTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties * If pname:pColorBlendState is not `NULL`, The pname:attachmentCount member of pname:pColorBlendState must: be equal to the pname:colorAttachmentCount used to create pname:subpass * If no element of the pname:pDynamicStates member of pname:pDynamicState is ename:VK_DYNAMIC_STATE_VIEWPORT, the pname:pViewports member of pname:pViewportState must: be a pointer to an array of pname:pViewportState::pname:viewportCount sname:VkViewport structures * If no element of the pname:pDynamicStates member of pname:pDynamicState is ename:VK_DYNAMIC_STATE_SCISSOR, the pname:pScissors member of pname:pViewportState must: be a pointer to an array of pname:pViewportState::pname:scissorCount sname:VkRect2D structures * If the wide lines feature is not enabled, and no element of the pname:pDynamicStates member of pname:pDynamicState is ename:VK_DYNAMIC_STATE_LINE_WIDTH, the pname:lineWidth member of pname:pRasterizationState must: be `1.0` * If the pname:rasterizerDiscardEnable member of pname:pRasterizationState is ename:VK_FALSE, pname:pViewportState must: be a pointer to a valid sname:VkPipelineViewportStateCreateInfo structure * If the pname:rasterizerDiscardEnable member of pname:pRasterizationState is ename:VK_FALSE, pname:pMultisampleState must: be a pointer to a valid sname:VkPipelineMultisampleStateCreateInfo structure * If the pname:rasterizerDiscardEnable member of pname:pRasterizationState is ename:VK_FALSE, and pname:subpass uses a depth/stencil attachment, pname:pDepthStencilState must: be a pointer to a valid sname:VkPipelineDepthStencilStateCreateInfo structure * If the pname:rasterizerDiscardEnable member of pname:pRasterizationState is ename:VK_FALSE, and pname:subpass uses color attachments, pname:pColorBlendState must: be a pointer to a valid sname:VkPipelineColorBlendStateCreateInfo structure * If the depth bias clamping feature is not enabled, no element of the pname:pDynamicStates member of pname:pDynamicState is ename:VK_DYNAMIC_STATE_DEPTH_BIAS, and the pname:depthBiasEnable member of pname:pDepthStencil is ename:VK_TRUE, the pname:depthBiasClamp member of pname:pDepthStencil must: be `0.0` * If no element of the pname:pDynamicStates member of pname:pDynamicState is ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the pname:depthBoundsTestEnable member of pname:pDepthStencil is ename:VK_TRUE, the pname:minDepthBounds and pname:maxDepthBounds members of pname:pDepthStencil must: be between `0.0` and `1.0`, inclusive * pname:layout must: be &lt;&lt;descriptorsets-pipelinelayout-consistency,consistent&gt;&gt; with all shaders specified in pname:pStages * If pname:subpass uses color and/or depth/stencil attachments, then the pname:rasterizationSamples member of pname:pMultisampleState must: be the same as the sample count for those subpass attachments * If pname:subpass does not use any color and/or depth/stencil attachments, then the pname:rasterizationSamples member of pname:pMultisampleState must: follow the rules for a &lt;&lt;renderpass-noattachments, zero-attachment subpass&gt;&gt; * pname:subpass must: be a valid subpass within pname:renderpass ****</para>
      </description>
      <members>
        <member name="VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT">ename:VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT specifies that the created pipeline will not be optimized. Using this flag may: reduce the time taken to create the pipeline.</member>
        <member name="VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT">ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT specifies that the pipeline to be created is allowed to be the parent of a pipeline that will be created in a subsequent call to flink:vkCreateGraphicsPipelines.</member>
        <member name="VK_PIPELINE_CREATE_DERIVATIVE_BIT">ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT specifies that the pipeline to be created will be a child of a previously created parent pipeline.</member>
      </members>
    </type>
    <type name="VkPipelineDepthStencilStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline depth stencil state.">
      <specification />
      <description>
        <para>.Valid Usage **** * If the &lt;&lt;features-features-depthBounds,depth bounds testing&gt;&gt; feature is not enabled, pname:depthBoundsTestEnable must: be ename:VK_FALSE ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="depthTestEnable">pname:depthTestEnable controls whether &lt;&lt;fragops-depth,depth testing&gt;&gt; is enabled.</member>
        <member name="depthWriteEnable">pname:depthWriteEnable controls whether &lt;&lt;fragops-depth-write,depth writes&gt;&gt; are enabled.</member>
        <member name="depthCompareOp">pname:depthCompareOp is the comparison operator used in the &lt;&lt;fragops-depth,depth test&gt;&gt;.</member>
        <member name="depthBoundsTestEnable">pname:depthBoundsTestEnable controls whether &lt;&lt;fragops-dbt,depth bounds testing&gt;&gt; is enabled.</member>
        <member name="stencilTestEnable">pname:stencilTestEnable controls whether &lt;&lt;fragops-stencil,stencil testing&gt;&gt; is enabled.</member>
        <member name="front">pname:front and pname:back control the parameters of the &lt;&lt;fragops-stencil,stencil test&gt;&gt;.</member>
        <member name="minDepthBounds">pname:minDepthBounds and pname:maxDepthBounds define the range of values used in the &lt;&lt;fragops-dbt,depth bounds test&gt;&gt;.</member>
      </members>
    </type>
    <type name="VkPipelineDynamicStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline dynamic state.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="dynamicStateCount">pname:dynamicStateCount is the number of elements in the pname:pDynamicStates array.</member>
        <member name="pDynamicStates">pname:pDynamicStates is an array of elink:VkDynamicState enums which indicate which pieces of pipeline state will use the values from dynamic state commands rather than from the pipeline state creation info.</member>
      </members>
    </type>
    <type name="VkPipelineInputAssemblyStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline input assembly state.">
      <specification />
      <description>
        <para>Restarting the assembly of primitives discards the most recent index values if those elements formed an incomplete primitive, and restarts the primitive assembly using the subsequent indices, but only assembling the immediately following element through the end of the originally specified elements. The primitive restart index value comparison is performed before adding the pname:vertexOffset value to the index value.</para>
        <para>.Valid Usage **** * If pname:topology is ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST, ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST, ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, pname:primitiveRestartEnable must: be ename:VK_FALSE * If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:topology must: not be any of ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY, ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY * If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:topology must: not be ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="topology">pname:topology is a elink:VkPrimitiveTopology defining the primitive topology, as described below.</member>
        <member name="primitiveRestartEnable">pname:primitiveRestartEnable controls whether a special vertex index value is treated as restarting the assembly of primitives. This enable only applies to indexed draws (flink:vkCmdDrawIndexed and flink:vkCmdDrawIndexedIndirect), and the special index value is either 0xFFFFFFFF when the pname:indexType parameter of fname:vkCmdBindIndexBuffer is equal to ename:VK_INDEX_TYPE_UINT32, or 0xFFFF when pname:indexType is equal to ename:VK_INDEX_TYPE_UINT16. Primitive restart is not allowed for ``list'' topologies.</member>
      </members>
    </type>
    <type name="VkPipelineLayout" summary="Opaque handle to a pipeline layout object.">
      <specification>
        <para>Access to descriptor sets from a pipeline is accomplished through a _pipeline layout_. Zero or more descriptor set layouts and zero or more push constant ranges are combined to form a pipeline layout object which describes the complete set of resources that can: be accessed by a pipeline. The pipeline layout represents a sequence of descriptor sets with each having a specific layout. This sequence of layouts is used to determine the interface between shader stages and shader resources. Each pipeline is created using a pipeline layout.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkPipelineLayoutCreateInfo" summary="Structure specifying the parameters of a newly created pipeline layout object.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:setLayoutCount must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxBoundDescriptorSets * The total number of descriptors of the type ename:VK_DESCRIPTOR_TYPE_SAMPLER and ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any given shader stage across all elements of pname:pSetLayouts must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorSamplers * The total number of descriptors of the type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pname:pSetLayouts must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorUniformBuffers * The total number of descriptors of the type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pname:pSetLayouts must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorStorageBuffers * The total number of descriptors of the type ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any given shader stage across all elements of pname:pSetLayouts must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorSampledImages * The total number of descriptors of the type ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any given shader stage across all elements of pname:pSetLayouts must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorStorageImages * Any two elements of pname:pPushConstantRanges must: not include the same stage in pname:stageFlags ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="setLayoutCount">pname:setLayoutCount is the number of descriptor sets included in the pipeline layout.</member>
        <member name="pSetLayouts">pname:pSetLayouts is a pointer to an array of sname:VkDescriptorSetLayout objects.</member>
        <member name="pushConstantRangeCount">pname:pushConstantRangeCount is the number of push constant ranges included in the pipeline layout.</member>
        <member name="pPushConstantRanges">pname:pPushConstantRanges is a pointer to an array of sname:VkPushConstantRange structures defining a set of push constant ranges for use in a single pipeline layout. In addition to descriptor set layouts, a pipeline layout also describes how many push constants can: be accessed by each stage of the pipeline. + [NOTE] .Note ==== Push constants represent a high speed path to modify constant data in pipelines that is expected to outperform memory-backed resource updates. ====</member>
      </members>
    </type>
    <type name="VkPipelineMultisampleStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline multisample state.">
      <specification />
      <description>
        <para>.Valid Usage **** * If the &lt;&lt;features-features-sampleRateShading,sample rate shading&gt;&gt; feature is not enabled, pname:sampleShadingEnable must: be ename:VK_FALSE * If the &lt;&lt;features-features-alphaToOne,alpha to one&gt;&gt; feature is not enabled, pname:alphaToOneEnable must: be ename:VK_FALSE * pname:minSampleShading must: be in the range [eq]#[0,1]# ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="rasterizationSamples">pname:rasterizationSamples is a elink:VkSampleCountFlagBits specifying the number of samples per pixel used in rasterization.</member>
        <member name="sampleShadingEnable">pname:sampleShadingEnable specifies that fragment shading executes per-sample if ename:VK_TRUE, or per-fragment if ename:VK_FALSE, as described in &lt;&lt;primsrast-sampleshading,Sample Shading&gt;&gt;.</member>
        <member name="minSampleShading">pname:minSampleShading is the minimum fraction of sample shading, as described in &lt;&lt;primsrast-sampleshading,Sample Shading&gt;&gt;.</member>
        <member name="pSampleMask">pname:pSampleMask is a bitmask of static coverage information that is ANDed with the coverage information generated during rasterization, as described in &lt;&lt;fragops-samplemask,Sample Mask&gt;&gt;.</member>
        <member name="alphaToCoverageEnable">pname:alphaToCoverageEnable controls whether a temporary coverage value is generated based on the alpha component of the fragment's first color output as specified in the &lt;&lt;fragops-covg,Multisample Coverage&gt;&gt; section.</member>
        <member name="alphaToOneEnable">pname:alphaToOneEnable controls whether the alpha component of the fragment's first color output is replaced with one as described in &lt;&lt;fragops-covg,Multisample Coverage&gt;&gt;.</member>
      </members>
    </type>
    <type name="VkPipelineRasterizationStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline rasterization state.">
      <specification />
      <description>
        <para>ifdef::VK_AMD_rasterization_order[] The application can: also chain a sname:VkPipelineRasterizationStateRasterizationOrderAMD structure to the sname:VkPipelineRasterizationStateCreateInfo structure through its pname:pNext member. This structure enables selecting the rasterization order to use when rendering with the corresponding graphics pipeline as described in &lt;&lt;primrast-order, Rasterization Order&gt;&gt;. endif::VK_AMD_rasterization_order[]</para>
        <para>.Valid Usage **** * If the &lt;&lt;features-features-depthClamp,depth clamping&gt;&gt; feature is not enabled, pname:depthClampEnable must: be ename:VK_FALSE * If the &lt;&lt;features-features-fillModeNonSolid,non-solid fill modes&gt;&gt; feature is not enabled, pname:polygonMode must: be ename:VK_POLYGON_MODE_FILL ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="depthClampEnable">pname:depthClampEnable controls whether to clamp the fragment's depth values instead of clipping primitives to the z planes of the frustum, as described in &lt;&lt;vertexpostproc-clipping,Primitive Clipping&gt;&gt;.</member>
        <member name="rasterizerDiscardEnable">pname:rasterizerDiscardEnable controls whether primitives are discarded immediately before the rasterization stage.</member>
        <member name="polygonMode">pname:polygonMode is the triangle rendering mode. See elink:VkPolygonMode.</member>
        <member name="cullMode">pname:cullMode is the triangle facing direction used for primitive culling. See elink:VkCullModeFlagBits.</member>
        <member name="frontFace">pname:frontFace is the front-facing triangle orientation to be used for culling. See elink:VkFrontFace.</member>
        <member name="depthBiasEnable">pname:depthBiasEnable controls whether to bias fragment depth values.</member>
        <member name="depthBiasConstantFactor">pname:depthBiasConstantFactor is a scalar factor controlling the constant depth value added to each fragment.</member>
        <member name="depthBiasClamp">pname:depthBiasClamp is the maximum (or minimum) depth bias of a fragment.</member>
        <member name="depthBiasSlopeFactor">pname:depthBiasSlopeFactor is a scalar factor applied to a fragment's slope in depth bias calculations.</member>
        <member name="lineWidth">pname:lineWidth is the width of rasterized line segments.</member>
      </members>
    </type>
    <type name="VkPipelineShaderStageCreateInfo" summary="Structure specifying parameters of a newly created pipeline shader stage.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="stage">pname:stage names a single pipeline stage. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkPipelineStageFlagBits" summary="Bitmask specifying pipeline stages.">
      <specification />
      <description>
        <para>[NOTE] .Note ==== The ename:VK_PIPELINE_STAGE_ALL_COMMANDS_BIT and ename:VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT differ from ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT in that they correspond to all (or all graphics) stages, rather than to a specific stage at the end of the pipeline. An execution dependency with only ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT in pname:dstStageMask will not delay subsequent commands, while including either of the other two bits will. Similarly, when defining a memory dependency, if the stage mask(s) refer to all stages, then the indicated access types from all stages will be made available and/or visible, but using only ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT would not make any accesses available and/or visible because this stage does not access memory. The ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT is useful for accomplishing memory barriers and layout transitions when the next accesses will be done in a different queue or by a presentation engine; in these cases subsequent commands in the same queue do not need to wait, but the barrier or transition must: complete before semaphores associated with the batch signal. ====</para>
      </description>
      <members>
        <member name="VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT">ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT: Stage of the pipeline where commands are initially received by the queue.</member>
        <member name="VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT">ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT: Stage of the pipeline where Draw/DispatchIndirect data structures are consumed.</member>
        <member name="VK_PIPELINE_STAGE_VERTEX_INPUT_BIT">ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT: Stage of the pipeline where vertex and index buffers are consumed.</member>
        <member name="VK_PIPELINE_STAGE_VERTEX_SHADER_BIT">ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT: Vertex shader stage.</member>
        <member name="VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT">ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT: Tessellation control shader stage.</member>
        <member name="VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT">ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT: Tessellation evaluation shader stage.</member>
        <member name="VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT">ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT: Geometry shader stage.</member>
        <member name="VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT">ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT: Fragment shader stage.</member>
        <member name="VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT">ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT: Stage of the pipeline where early fragment tests (depth and stencil tests before fragment shading) are performed.</member>
        <member name="VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT">ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT: Stage of the pipeline where late fragment tests (depth and stencil tests after fragment shading) are performed.</member>
        <member name="VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT">ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT: Stage of the pipeline after blending where the final color values are output from the pipeline. This stage also includes resolve operations that occur at the end of a subpass. Note that this does not necessarily indicate that the values have been committed to memory.</member>
        <member name="VK_PIPELINE_STAGE_TRANSFER_BIT">ename:VK_PIPELINE_STAGE_TRANSFER_BIT: Execution of copy commands. This includes the operations resulting from all transfer commands. The set of transfer commands comprises fname:vkCmdCopyBuffer, fname:vkCmdCopyImage, fname:vkCmdBlitImage, fname:vkCmdCopyBufferToImage, fname:vkCmdCopyImageToBuffer, fname:vkCmdUpdateBuffer, fname:vkCmdFillBuffer, fname:vkCmdClearColorImage, fname:vkCmdClearDepthStencilImage, fname:vkCmdResolveImage, and fname:vkCmdCopyQueryPoolResults.</member>
        <member name="VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT">ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT: Execution of a compute shader.</member>
        <member name="VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT">ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: Final stage in the pipeline where commands complete execution.</member>
        <member name="VK_PIPELINE_STAGE_HOST_BIT">ename:VK_PIPELINE_STAGE_HOST_BIT: A pseudo-stage indicating execution on the host of reads/writes of device memory.</member>
        <member name="VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT">ename:VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT: Execution of all graphics pipeline stages.</member>
        <member name="VK_PIPELINE_STAGE_ALL_COMMANDS_BIT">ename:VK_PIPELINE_STAGE_ALL_COMMANDS_BIT: Execution of all stages supported on the queue.</member>
      </members>
    </type>
    <type name="VkPipelineTessellationStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline tessellation state.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:patchControlPoints must: be greater than zero and less than or equal to sname:VkPhysicalDeviceLimits::pname:maxTessellationPatchSize ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="patchControlPoints">pname:patchControlPoints number of control points per patch.</member>
      </members>
    </type>
    <type name="VkPipelineVertexInputStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline vertex input state.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:vertexBindingDescriptionCount must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxVertexInputBindings * pname:vertexAttributeDescriptionCount must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxVertexInputAttributes * For every pname:binding specified by any given element of pname:pVertexAttributeDescriptions, a sname:VkVertexInputBindingDescription must: exist in pname:pVertexBindingDescriptions with the same value of pname:binding * All elements of pname:pVertexBindingDescriptions must: describe distinct binding numbers * All elements of pname:pVertexAttributeDescriptions must: describe distinct attribute locations ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="vertexBindingDescriptionCount">pname:vertexBindingDescriptionCount is the number of vertex binding descriptions provided in pname:pVertexBindingDescriptions.</member>
        <member name="pVertexBindingDescriptions">pname:pVertexBindingDescriptions is a pointer to an array of sname:VkVertexInputBindingDescription structures.</member>
        <member name="vertexAttributeDescriptionCount">pname:vertexAttributeDescriptionCount is the number of vertex attribute descriptions provided in pname:pVertexAttributeDescriptions.</member>
        <member name="pVertexAttributeDescriptions">pname:pVertexAttributeDescriptions is a pointer to an array of sname:VkVertexInputAttributeDescription structures.</member>
      </members>
    </type>
    <type name="VkPipelineViewportStateCreateInfo" summary="Structure specifying parameters of a newly created pipeline viewport state.">
      <specification />
      <description>
        <para>.Valid Usage **** * If the &lt;&lt;features-features-multiViewport,multiple viewports&gt;&gt; feature is not enabled, pname:viewportCount must: be `1` * If the &lt;&lt;features-features-multiViewport,multiple viewports&gt;&gt; feature is not enabled, pname:scissorCount must: be `1` * pname:viewportCount must: be between `1` and sname:VkPhysicalDeviceLimits::pname:maxViewports, inclusive * pname:scissorCount must: be between `1` and sname:VkPhysicalDeviceLimits::pname:maxViewports, inclusive * pname:scissorCount and pname:viewportCount must: be identical ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="viewportCount">pname:viewportCount is the number of viewports used by the pipeline.</member>
        <member name="pViewports">pname:pViewports is a pointer to an array of slink:VkViewport structures, defining the viewport transforms. If the viewport state is dynamic, this member is ignored.</member>
        <member name="scissorCount">pname:scissorCount is the number of &lt;&lt;fragops-scissor,scissors&gt;&gt; and must: match the number of viewports.</member>
        <member name="pScissors">pname:pScissors is a pointer to an array of sname:VkRect2D structures which define the rectangular bounds of the scissor for the corresponding viewport. If the scissor state is dynamic, this member is ignored.</member>
      </members>
    </type>
    <type name="VkPolygonMode" summary="Control polygon rasterization mode.">
      <specification />
      <description>
        <para>The pname:polygonMode selects which method of rasterization is used for polygons. If pname:polygonMode is ename:VK_POLYGON_MODE_POINT, then the vertices of polygons are treated, for rasterization purposes, as if they had been drawn as points. ename:VK_POLYGON_MODE_LINE causes polygon edges to be drawn as line segments. ename:VK_POLYGON_MODE_FILL causes polygons to render using the polygon rasterization rules in this section.</para>
        <para>Note that these modes affect only the final rasterization of polygons: in particular, a polygon's vertices are shaded and the polygon is clipped and possibly culled before these modes are applied.</para>
      </description>
      <members />
    </type>
    <type name="VkPresentInfoKHR" summary="Structure describing parameters of a queue presentation.">
      <specification />
      <description>
        <para>.Valid Usage **** * Any given element of pname:pImageIndices must: be the index of a presentable image acquired from the swapchain specified by the corresponding element of the pname:pSwapchains array * Any given element of sname:VkSemaphore in pname:pWaitSemaphores must: refer to a prior signal of that sname:VkSemaphore that will not be consumed by any other wait on that semaphore ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_PRESENT_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="waitSemaphoreCount">pname:waitSemaphoreCount is the number of semaphores to wait for before issuing the present request. The number may: be zero.</member>
        <member name="pWaitSemaphores">pname:pWaitSemaphores, if not code:VK_NULL_HANDLE, is an array of sname:VkSemaphore objects with pname:waitSemaphoreCount entries, and specifies the semaphores to wait for before issuing the present request.</member>
        <member name="swapchainCount">pname:swapchainCount is the number of swapchains being presented to by this command.</member>
        <member name="pSwapchains">pname:pSwapchains is an array of sname:VkSwapchainKHR objects with pname:swapchainCount entries. A given swapchain must: not appear in this list more than once.</member>
        <member name="pImageIndices">pname:pImageIndices is an array of indices into the array of each swapchain's presentable images, with pname:swapchainCount entries. Each entry in this array identifies the image to present on the corresponding entry in the pname:pSwapchains array.</member>
        <member name="pResults">pname:pResults is an array of ename:VkResult typed elements with pname:swapchainCount entries. Applications that do not need per-swapchain results can: use `NULL` for pname:pResults. If non-`NULL`, each entry in pname:pResults will be set to the ename:VkResult for presenting the swapchain corresponding to the same index in pname:pSwapchains.</member>
      </members>
    </type>
    <type name="VkPresentModeKHR" summary="Presentation mode supported for a surface.">
      <specification />
      <description>
        <para>[NOTE] .Note ==== For reference, the mode indicated by ename:VK_PRESENT_MODE_FIFO_KHR is equivalent to the behavior of {wgl|glX|egl}SwapBuffers with a swap interval of 1, while the mode indicated by ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR is equivalent to the behavior of {wgl|glX}SwapBuffers with a swap interval of -1 (from the {WGL|GLX}_EXT_swap_control_tear extensions). ====</para>
      </description>
      <members>
        <member name="VK_PRESENT_MODE_IMMEDIATE_KHR">ename:VK_PRESENT_MODE_IMMEDIATE_KHR: The presentation engine does not wait for a vertical blanking period to update the current image, meaning this mode may: result in visible tearing. No internal queuing of presentation requests is needed, as the requests are applied immediately.</member>
        <member name="VK_PRESENT_MODE_MAILBOX_KHR">ename:VK_PRESENT_MODE_MAILBOX_KHR: The presentation engine waits for the next vertical blanking period to update the current image. Tearing cannot: be observed. An internal single-entry queue is used to hold pending presentation requests. If the queue is full when a new presentation request is received, the new request replaces the existing entry, and any images associated with the prior entry become available for re-use by the application. One request is removed from the queue and processed during each vertical blanking period in which the queue is non-empty.</member>
        <member name="VK_PRESENT_MODE_FIFO_KHR">ename:VK_PRESENT_MODE_FIFO_KHR: The presentation engine waits for the next vertical blanking period to update the current image. Tearing cannot: be observed. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during each vertical blanking period in which the queue is non-empty. This is the only value of pname:presentMode that is required: to be supported.</member>
        <member name="VK_PRESENT_MODE_FIFO_RELAXED_KHR">ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR: The presentation engine generally waits for the next vertical blanking period to update the current image. If a vertical blanking period has already passed since the last update of the current image then the presentation engine does not wait for another vertical blanking period for the update, meaning this mode may: result in visible tearing in this case. This mode is useful for reducing visual stutter with an application that will mostly present a new image before the next vertical blanking period, but may occasionally be late, and present a new image just after the next vertical blanking period. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during or after each vertical blanking period in which the queue is non-empty.</member>
      </members>
    </type>
    <type name="VkPrimitiveTopology" summary="Supported primitive topologies.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkPushConstantRange" summary="Structure specifying a push constant range.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:offset must: be less than sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize * pname:size must: be greater than `0` * pname:size must: be a multiple of `4` * pname:size must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize minus pname:offset ****</para>
      </description>
      <members>
        <member name="stageFlags">pname:stageFlags is a set of stage flags describing the shader stages that will access a range of push constants. If a particular stage is not included in the range, then accessing members of that range of push constants from the corresponding shader stage will result in undefined data being read.</member>
        <member name="offset">pname:offset and pname:size are the start offset and size, respectively, consumed by the range. Both pname:offset and pname:size are in units of bytes and must: be a multiple of 4. The layout of the push constant variables is specified in the shader.</member>
      </members>
    </type>
    <type name="VkQueryControlFlagBits" summary="Bitmask specifying constraints on a query.">
      <specification />
      <description>
        <para>If the pname:queryType of the pool is ename:VK_QUERY_TYPE_OCCLUSION and pname:flags contains ename:VK_QUERY_CONTROL_PRECISE_BIT, an implementation must: return a result that matches the actual number of samples passed. This is described in more detail in &lt;&lt;queries-occlusion,Occlusion Queries&gt;&gt;.</para>
        <para>After beginning a query, that query is considered _active_ within the command buffer it was called in until that same query is ended. Queries active in a primary command buffer when secondary command buffers are executed are considered active for those secondary command buffers.</para>
        <para>.Valid Usage **** * The query identified by pname:queryPool and pname:query must: currently not be &lt;&lt;queries-operation-active,active&gt;&gt; * The query identified by pname:queryPool and pname:query must: be unavailable * If the &lt;&lt;features-features-occlusionQueryPrecise,precise occlusion queries&gt;&gt; feature is not enabled, or the pname:queryType used to create pname:queryPool was not ename:VK_QUERY_TYPE_OCCLUSION, pname:flags must: not contain ename:VK_QUERY_CONTROL_PRECISE_BIT * pname:queryPool must: have been created with a pname:queryType that differs from that of any other queries that have been made &lt;&lt;queries-operation-active,active&gt;&gt;, and are currently still active within pname:commandBuffer * pname:query must: be less than the number of queries in pname:queryPool * If the pname:queryType used to create pname:queryPool was ename:VK_QUERY_TYPE_OCCLUSION, the sname:VkCommandPool that pname:commandBuffer was allocated from must: support graphics operations * If the pname:queryType used to create pname:queryPool was ename:VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pname:pipelineStatistics indicate graphics operations, the sname:VkCommandPool that pname:commandBuffer was allocated from must: support graphics operations * If the pname:queryType used to create pname:queryPool was ename:VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pname:pipelineStatistics indicate compute operations, the sname:VkCommandPool that pname:commandBuffer was allocated from must: support compute operations ****</para>
      </description>
      <members />
    </type>
    <type name="VkQueryPipelineStatisticFlagBits" summary="Bitmask specifying queried pipeline statistics.">
      <specification />
      <description>
        <para>These bits have the following meanings:</para>
        <para>* If ename:VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT is set, queries managed by the pool will count the number of vertices processed by the &lt;&lt;drawing,input assembly&gt;&gt; stage. Vertices corresponding to incomplete primitives may: contribute to the count. * If ename:VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT is set, queries managed by the pool will count the number of primitives processed by the &lt;&lt;drawing,input assembly&gt;&gt; stage. If primitive restart is enabled, restarting the primitive topology has no effect on the count. Incomplete primitives may: be counted. * If ename:VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT is set, queries managed by the pool will count the number of vertex shader invocations. This counter's value is incremented each time a vertex shader is &lt;&lt;shaders-vertex-execution,invoked&gt;&gt;. * If ename:VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT is set, queries managed by the pool will count the number of geometry shader invocations. This counter's value is incremented each time a geometry shader is &lt;&lt;shaders-geometry-execution,invoked&gt;&gt;. In the case of &lt;&lt;geometry-invocations,instanced geometry shaders&gt;&gt;, the geometry shader invocations count is incremented for each separate instanced invocation. * If ename:VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT is set, queries managed by the pool will count the number of primitives generated by geometry shader invocations. The counter's value is incremented each time the geometry shader emits a primitive. Restarting primitive topology using the SPIR-V instructions code:OpEndPrimitive or code:OpEndStreamPrimitive has no effect on the geometry shader output primitives count. * If ename:VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT is set, queries managed by the pool will count the number of primitives processed by the &lt;&lt;vertexpostproc-clipping,Primitive Clipping&gt;&gt; stage of the pipeline. The counter's value is incremented each time a primitive reaches the primitive clipping stage. * If ename:VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT is set, queries managed by the pool will count the number of primitives output by the &lt;&lt;vertexpostproc-clipping,Primitive Clipping&gt;&gt; stage of the pipeline. The counter's value is incremented each time a primitive passes the primitive clipping stage. The actual number of primitives output by the primitive clipping stage for a particular input primitive is implementation-dependent but must: satisfy the following conditions: ** If at least one vertex of the input primitive lies inside the clipping volume, the counter is incremented by one or more. ** Otherwise, the counter is incremented by zero or more. * If ename:VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT is set, queries managed by the pool will count the number of fragment shader invocations. The counter's value is incremented each time the fragment shader is &lt;&lt;shaders-fragment-execution,invoked&gt;&gt;. * If ename:VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT is set, queries managed by the pool will count the number of patches processed by the tessellation control shader. The counter's value is incremented once for each patch for which a tessellation control shader is &lt;&lt;shaders-tessellation-control-execution,invoked&gt;&gt;. * If ename:VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT is set, queries managed by the pool will count the number of invocations of the tessellation evaluation shader. The counter's value is incremented each time the tessellation evaluation shader is &lt;&lt;shaders-tessellation-evaluation-execution,invoked&gt;&gt;. * If ename:VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT is set, queries managed by the pool will count the number of compute shader invocations. The counter's value is incremented every time the compute shader is invoked. Implementations may: skip the execution of certain compute shader invocations or execute additional compute shader invocations for implementation-dependent reasons as long as the results of rendering otherwise remain unchanged.</para>
        <para>These values are intended to measure relative statistics on one implementation. Various device architectures will count these values differently. Any or all counters may: be affected by the issues described in &lt;&lt;queries-operation-undefined,Query Operation&gt;&gt;.</para>
        <para>[NOTE] .Note ==== For example, tile-based rendering devices may: need to replay the scene multiple times, affecting some of the counts. ====</para>
        <para>If a pipeline has pname:rasterizerDiscardEnable enabled, implementations may: discard primitives after the final vertex processing stage. As a result, if pname:rasterizerDiscardEnable is enabled, the clipping input and output primitives counters may: not be incremented.</para>
        <para>When a pipeline statistics query finishes, the result for that query is marked as available. The application can: copy the result to a buffer (via fname:vkCmdCopyQueryPoolResults), or request it be put into host memory (via fname:vkGetQueryPoolResults).</para>
      </description>
      <members />
    </type>
    <type name="VkQueryPool" summary="Opaque handle to a query pool object.">
      <specification>
        <para>Queries are managed using _query pool_ objects. Each query pool is a collection of a specific number of queries of a particular type.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkQueryPoolCreateInfo" summary="Structure specifying parameters of a newly created query pool.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="queryType">pname:queryType is the type of queries managed by the pool, and must: be one of the values + --</member>
      </members>
    </type>
    <type name="VkQueryResultFlagBits" summary="Bitmask specifying how and when query results are returned.">
      <specification />
      <description>
        <para>If no bits are set in pname:flags, and all requested queries are in the available state, results are written as an array of 32-bit unsigned integer values. The behavior when not all queries are available, is described &lt;&lt;queries-wait-bit-not-set, below&gt;&gt;.</para>
        <para>If ename:VK_QUERY_RESULT_64_BIT is not set and the result overflows a 32-bit value, the value may: either wrap or saturate. Similarly, if ename:VK_QUERY_RESULT_64_BIT is set and the result overflows a 64-bit value, the value may: either wrap or saturate.</para>
        <para>If ename:VK_QUERY_RESULT_WAIT_BIT is set, Vulkan will wait for each query to be in the available state before retrieving the numerical results for that query. In this case, fname:vkGetQueryPoolResults is guaranteed to succeed and return ename:VK_SUCCESS if the queries become available in a finite time (i.e. if they have been issued and not reset). If queries will never finish (e.g. due to being reset but not issued), then fname:vkGetQueryPoolResults may: not return in finite time.</para>
        <para>If ename:VK_QUERY_RESULT_WAIT_BIT and ename:VK_QUERY_RESULT_PARTIAL_BIT are both not set then no result values are written to pname:pData for queries that are in the unavailable state at the time of the call, and fname:vkGetQueryPoolResults returns ename:VK_NOT_READY. However, availability state is still written to pname:pData for those queries if ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT is set.</para>
        <para>[NOTE] .Note ==== Applications must: take care to ensure that use of the ename:VK_QUERY_RESULT_WAIT_BIT bit has the desired effect.</para>
        <para>For example, if a query has been used previously and a command buffer records the commands fname:vkCmdResetQueryPool, fname:vkCmdBeginQuery, and fname:vkCmdEndQuery for that query, then the query will remain in the available state until the fname:vkCmdResetQueryPool command executes on a queue. Applications can: use fences or events to ensure that a query has already been reset before checking for its results or availability status. Otherwise, a stale value could be returned from a previous use of the query.</para>
        <para>The above also applies when ename:VK_QUERY_RESULT_WAIT_BIT is used in combination with ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT. In this case, the returned availability status may: reflect the result of a previous use of the query unless the fname:vkCmdResetQueryPool command has been executed since the last use of the query. ====</para>
        <para>[NOTE] .Note ==== Applications can: double-buffer query pool usage, with a pool per frame, and reset queries at the end of the frame in which they are read. ====</para>
        <para>If ename:VK_QUERY_RESULT_PARTIAL_BIT is set, ename:VK_QUERY_RESULT_WAIT_BIT is not set, and the query's status is unavailable, an intermediate result value between zero and the final result value is written to pname:pData for that query.</para>
        <para>ename:VK_QUERY_RESULT_PARTIAL_BIT must: not be used if the pool's pname:queryType is ename:VK_QUERY_TYPE_TIMESTAMP.</para>
        <para>If ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT is set, the final integer value written for each query is non-zero if the query's status was available or zero if the status was unavailable. When ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT is used, implementations must: guarantee that if they return a non-zero availability value then the numerical results must: be valid, assuming the results are not reset by a subsequent command.</para>
        <para>[NOTE] .Note ==== Satisfying this guarantee may: require careful ordering by the application, e.g. to read the availability status before reading the results. ====</para>
        <para>.Valid Usage **** * pname:firstQuery must: be less than the number of queries in pname:queryPool * If ename:VK_QUERY_RESULT_64_BIT is not set in pname:flags then pname:pData and pname:stride must: be multiples of `4` * If ename:VK_QUERY_RESULT_64_BIT is set in pname:flags then pname:pData and pname:stride must: be multiples of `8` * The sum of pname:firstQuery and pname:queryCount must: be less than or equal to the number of queries in pname:queryPool * pname:dataSize must: be large enough to contain the result of each query, as described &lt;&lt;queries-operation-memorylayout,here&gt;&gt; * If the pname:queryType used to create pname:queryPool was ename:VK_QUERY_TYPE_TIMESTAMP, pname:flags must: not contain ename:VK_QUERY_RESULT_PARTIAL_BIT ****</para>
      </description>
      <members />
    </type>
    <type name="VkQueryType" summary="Specify the type of queries managed by a query pool.">
      <specification />
      <description>
        <para>.Valid Usage **** * If the &lt;&lt;features-features-pipelineStatisticsQuery,pipeline statistics queries&gt;&gt; feature is not enabled, pname:queryType must: not be ename:VK_QUERY_TYPE_PIPELINE_STATISTICS * If pname:queryType is ename:VK_QUERY_TYPE_PIPELINE_STATISTICS, pname:pipelineStatistics must: be a valid combination of elink:VkQueryPipelineStatisticFlagBits values ****</para>
      </description>
      <members />
    </type>
    <type name="VkQueue" summary="Opaque handle to a queue object.">
      <specification>
        <para>Creating a logical device also creates the queues associated with that device. The queues to create are described by a set of slink:VkDeviceQueueCreateInfo structures that are passed to flink:vkCreateDevice in pname:pQueueCreateInfos.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkQueueFamilyProperties" summary="Structure providing information about a queue family.">
      <specification />
      <description>
        <para>The bits specified in pname:queueFlags are:</para>
      </description>
      <members>
        <member name="queueFlags">pname:queueFlags contains flags indicating the capabilities of the queues in this queue family.</member>
        <member name="queueCount">pname:queueCount is the unsigned integer count of queues in this queue family.</member>
        <member name="timestampValidBits">pname:timestampValidBits is the unsigned integer count of meaningful bits in the timestamps written via fname:vkCmdWriteTimestamp. The valid range for the count is 36..64 bits, or a value of 0, indicating no support for timestamps. Bits outside the valid range are guaranteed to be zeros.</member>
        <member name="minImageTransferGranularity">pname:minImageTransferGranularity is the minimum granularity supported for image transfer operations on the queues in this queue family.</member>
      </members>
    </type>
    <type name="VkQueueFlagBits" summary="Bitmask specifying capabilities of queues in a queue family.">
      <specification />
      <description>
        <para>If an implementation exposes any queue family that supports graphics operations, at least one queue family of at least one physical device exposed by the implementation must: support both graphics and compute operations.</para>
        <para>[NOTE] .Note ==== All commands that are allowed on a queue that supports transfer operations are also allowed on a queue that supports either graphics or compute operations thus if the capabilities of a queue family include ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT then reporting the ename:VK_QUEUE_TRANSFER_BIT capability separately for that queue family is optional:. ====</para>
        <para>For further details see &lt;&lt;devsandqueues-queues,Queues&gt;&gt;.</para>
        <para>The value returned in pname:minImageTransferGranularity has a unit of compressed texel blocks for images having a block-compressed format, and a unit of texels otherwise.</para>
        <para>Possible values of pname:minImageTransferGranularity are:</para>
        <para>* [eq]#(0,0,0)# which indicates that only whole mip levels must: be transferred using the image transfer operations on the corresponding queues. In this case, the following restrictions apply to all offset and extent parameters of image transfer operations:</para>
        <para>** The pname:x, pname:y, and pname:z members of a slink:VkOffset3D parameter must: always be zero. ** The pname:width, pname:height, and pname:depth members of a slink:VkExtent3D parameter must: always match the width, height, and depth of the image subresource corresponding to the parameter, respectively.</para>
        <para>* [eq]#(A~x~, A~y~, A~z~)# where [eq]#A~x~#, [eq]#A~y~#, and [eq]#A~z~# are all integer powers of two. In this case the following restrictions apply to all image transfer operations:</para>
        <para>** pname:x, pname:y, and pname:z of a slink:VkOffset3D parameter must: be integer multiples of [eq]#A~x~#, [eq]#A~y~#, and [eq]#A~z~#, respectively. ** pname:width of a slink:VkExtent3D parameter must: be an integer multiple of [eq]#A~x~#, or else [eq]#pname:x + pname:width# must: equal the width of the image subresource corresponding to the parameter. ** pname:height of a slink:VkExtent3D parameter must: be an integer multiple of [eq]#A~y~#, or else [eq]#pname:y + pname:height# must: equal the height of the image subresource corresponding to the parameter. ** pname:depth of a slink:VkExtent3D parameter must: be an integer multiple of [eq]#A~z~#, or else [eq]#pname:z + pname:depth# must: equal the depth of the image subresource corresponding to the parameter. ** If the format of the image corresponding to the parameters is one of the block-compressed formats then for the purposes of the above calculations the granularity must: be scaled up by the compressed texel block dimensions.</para>
        <para>Queues supporting graphics and/or compute operations must: report [eq]#(1,1,1)# in pname:minImageTransferGranularity, meaning that there are no additional restrictions on the granularity of image transfer operations for these queues. Other queues supporting image transfer operations are only required: to support whole mip level transfers, thus pname:minImageTransferGranularity for queues belonging to such queue families may: be [eq]#(0,0,0)#.</para>
      </description>
      <members>
        <member name="VK_QUEUE_GRAPHICS_BIT">if ename:VK_QUEUE_GRAPHICS_BIT is set, then the queues in this queue family support graphics operations.</member>
        <member name="VK_QUEUE_COMPUTE_BIT">if ename:VK_QUEUE_COMPUTE_BIT is set, then the queues in this queue family support compute operations.</member>
        <member name="VK_QUEUE_TRANSFER_BIT">if ename:VK_QUEUE_TRANSFER_BIT is set, then the queues in this queue family support transfer operations.</member>
        <member name="VK_QUEUE_SPARSE_BINDING_BIT">if ename:VK_QUEUE_SPARSE_BINDING_BIT is set, then the queues in this queue family support sparse memory management operations (see &lt;&lt;sparsememory,Sparse Resources&gt;&gt;). If any of the sparse resource features are enabled, then at least one queue family must: support this bit.</member>
      </members>
    </type>
    <type name="VkRect2D" summary="Structure specifying a two-dimensional subregion.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkRenderPass" summary="Opaque handle to a render pass object.">
      <specification>
        <para>A _render pass_ represents a collection of attachments, subpasses, and dependencies between the subpasses, and describes how the attachments are used over the course of the subpasses. The use of a render pass in a command buffer is a _render pass instance_.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkRenderPassBeginInfo" summary="Structure specifying render pass begin info.">
      <specification />
      <description>
        <para>pname:renderArea is the render area that is affected by the render pass instance. The effects of attachment load, store and resolve operations are restricted to the pixels whose x and y coordinates fall within the render area on all attachments. The render area extends to all layers of pname:framebuffer. The application must: ensure (using scissor if necessary) that all rendering is contained within the render area, otherwise the pixels outside of the render area become undefined and shader side effects may: occur for fragments outside the render area. The render area must: be contained within the framebuffer dimensions.</para>
        <para>[NOTE] .Note ==== There may: be a performance cost for using a render area smaller than the framebuffer, unless it matches the render area granularity for the render pass. ====</para>
        <para>.Valid Usage **** * pname:clearValueCount must: be greater than the largest attachment index in pname:renderPass that specifies a pname:loadOp (or pname:stencilLoadOp, if the attachment has a depth/stencil format) of ename:VK_ATTACHMENT_LOAD_OP_CLEAR * pname:renderPass must: be &lt;&lt;renderpass-compatibility,compatible&gt;&gt; with the pname:renderPass member of the sname:VkFramebufferCreateInfo structure specified when creating pname:framebuffer. ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="renderPass">pname:renderPass is the render pass to begin an instance of.</member>
        <member name="framebuffer">pname:framebuffer is the framebuffer containing the attachments that are used with the render pass.</member>
        <member name="renderArea">pname:renderArea is the render area that is affected by the render pass instance, and is described in more detail below.</member>
        <member name="clearValueCount">pname:clearValueCount is the number of elements in pname:pClearValues.</member>
        <member name="pClearValues">pname:pClearValues is an array of slink:VkClearValue structures that contains clear values for each attachment, if the attachment uses a pname:loadOp value of ename:VK_ATTACHMENT_LOAD_OP_CLEAR or if the attachment has a depth/stencil format and uses a pname:stencilLoadOp value of ename:VK_ATTACHMENT_LOAD_OP_CLEAR. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of pname:pClearValues are ignored.</member>
      </members>
    </type>
    <type name="VkRenderPassCreateInfo" summary="Structure specifying parameters of a newly created render pass.">
      <specification />
      <description>
        <para>.Valid Usage **** * If any two subpasses operate on attachments with overlapping ranges of the same sname:VkDeviceMemory object, and at least one subpass writes to that area of sname:VkDeviceMemory, a subpass dependency must: be included (either directly or via some intermediate subpasses) between them * If the pname:attachment member of any element of pname:pInputAttachments, pname:pColorAttachments, pname:pResolveAttachments or pname:pDepthStencilAttachment, or the attachment indexed by any element of pname:pPreserveAttachments in any given element of pname:pSubpasses is bound to a range of a sname:VkDeviceMemory object that overlaps with any other attachment in any subpass (including the same subpass), the sname:VkAttachmentDescription structures describing them must: include ename:VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT in pname:flags * If the pname:attachment member of any element of pname:pInputAttachments, pname:pColorAttachments, pname:pResolveAttachments or pname:pDepthStencilAttachment, or any element of pname:pPreserveAttachments in any given element of pname:pSubpasses is not ename:VK_ATTACHMENT_UNUSED, it must: be less than pname:attachmentCount * The value of any element of the pname:pPreserveAttachments member in any given element of pname:pSubpasses must: not be ename:VK_ATTACHMENT_UNUSED ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="attachmentCount">pname:attachmentCount is the number of attachments used by this render pass, or zero indicating no attachments. Attachments are referred to by zero-based indices in the range [0,pname:attachmentCount).</member>
        <member name="pAttachments">pname:pAttachments points to an array of pname:attachmentCount number of slink:VkAttachmentDescription structures describing properties of the attachments, or `NULL` if pname:attachmentCount is zero.</member>
        <member name="subpassCount">pname:subpassCount is the number of subpasses to create for this render pass. Subpasses are referred to by zero-based indices in the range [0,pname:subpassCount). A render pass must: have at least one subpass.</member>
        <member name="pSubpasses">pname:pSubpasses points to an array of pname:subpassCount number of slink:VkSubpassDescription structures describing properties of the subpasses.</member>
        <member name="dependencyCount">pname:dependencyCount is the number of dependencies between pairs of subpasses, or zero indicating no dependencies.</member>
        <member name="pDependencies">pname:pDependencies points to an array of pname:dependencyCount number of slink:VkSubpassDependency structures describing dependencies between pairs of subpasses, or `NULL` if pname:dependencyCount is zero.</member>
      </members>
    </type>
    <type name="VkResult" summary="Vulkan command return codes.">
      <specification>
        <para>While the core Vulkan API is not designed to capture incorrect usage, some circumstances still require return codes. Commands in Vulkan return their status via return codes that are in one of two categories:</para>
        <para>* Successful completion codes are returned when a command needs to communicate success or status information. All successful completion codes are non-negative values. * Run time error codes are returned when a command needs to communicate a failure that could only be detected at run time. All run time error codes are negative values.</para>
      </specification>
      <description>
        <para>.Success Codes * ename:VK_SUCCESS Command successfully completed * ename:VK_NOT_READY A fence or query has not yet completed * ename:VK_TIMEOUT A wait operation has not completed in the specified time * ename:VK_EVENT_SET An event is signaled * ename:VK_EVENT_RESET An event is unsignaled * ename:VK_INCOMPLETE A return array was too small for the result ifdef::VK_KHR_swapchain[] * ename:VK_SUBOPTIMAL_KHR A swapchain no longer matches the surface properties exactly, but can: still be used to present to the surface successfully. endif::VK_KHR_swapchain[]</para>
        <para>.Error codes * ename:VK_ERROR_OUT_OF_HOST_MEMORY A host memory allocation has failed. * ename:VK_ERROR_OUT_OF_DEVICE_MEMORY A device memory allocation has failed. * ename:VK_ERROR_INITIALIZATION_FAILED Initialization of an object could not be completed for implementation-specific reasons. * ename:VK_ERROR_DEVICE_LOST The logical or physical device has been lost. See &lt;&lt;devsandqueues-lost-device,Lost Device&gt;&gt; * ename:VK_ERROR_MEMORY_MAP_FAILED Mapping of a memory object has failed. * ename:VK_ERROR_LAYER_NOT_PRESENT A requested layer is not present or could not be loaded. * ename:VK_ERROR_EXTENSION_NOT_PRESENT A requested extension is not supported. * ename:VK_ERROR_FEATURE_NOT_PRESENT A requested feature is not supported. * ename:VK_ERROR_INCOMPATIBLE_DRIVER The requested version of Vulkan is not supported by the driver or is otherwise incompatible for implementation-specific reasons. * ename:VK_ERROR_TOO_MANY_OBJECTS Too many objects of the type have already been created. * ename:VK_ERROR_FORMAT_NOT_SUPPORTED A requested format is not supported on this device. * ename:VK_ERROR_FRAGMENTED_POOL A requested pool allocation has failed due to fragmentation of the pool's memory. ifdef::VK_KHR_surface[] * ename:VK_ERROR_SURFACE_LOST_KHR A surface is no longer available. * ename:VK_ERROR_NATIVE_WINDOW_IN_USE_KHR The requested window is already in use by Vulkan or another API in a manner which prevents it from being used again. endif::VK_KHR_surface[] ifdef::VK_KHR_swapchain[] * ename:VK_ERROR_OUT_OF_DATE_KHR A surface has changed in such a way that it is no longer compatible with the swapchain, and further presentation requests using the swapchain will fail. Applications must: query the new surface properties and recreate their swapchain if they wish to continue presenting to the surface. endif::VK_KHR_swapchain[] ifdef::VK_KHR_display_swapchain[] * ename:VK_ERROR_INCOMPATIBLE_DISPLAY_KHR The display used by a swapchain does not use the same presentable image layout, or is incompatible in a way that prevents sharing an image. endif::VK_KHR_display_swapchain[] ifdef::VK_NV_glsl_shader[] * ename:VK_ERROR_INVALID_SHADER_NV One or more shaders failed to compile or link. More details are reported back to the application via +VK_EXT_debug_report+ if enabled. endif::VK_NV_glsl_shader[]</para>
        <para>If a command returns a run time error, it will leave any result pointers unmodified, unless other behavior is explicitly defined in the specification.</para>
        <para>Out of memory errors do not damage any currently existing Vulkan objects. Objects that have already been successfully created can: still be used by the application.</para>
        <para>Performance-critical commands generally do not have return codes. If a run time error occurs in such commands, the implementation will defer reporting the error until a specified point. For commands that record into command buffers (ftext:vkCmd*) run time errors are reported by fname:vkEndCommandBuffer.</para>
      </description>
      <members />
    </type>
    <type name="VkSampleCountFlagBits" summary="Bitmask specifying sample counts supported for an image used for storage operations.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkSampleMask" summary="Mask of sample coverage information.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkSampler" summary="Opaque handle to a sampler object.">
      <specification>
        <para>sname:VkSampler objects represent the state of an image sampler which is used by the implementation to read image data and apply filtering and other transformations for the shader.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkSamplerAddressMode" summary="Specify behavior of sampling with texture coordinates outside an image.">
      <specification />
      <description>
        <para>The maximum number of sampler objects which can: be simultaneously created on a device is implementation-dependent and specified by the &lt;&lt;features-limits-maxSamplerAllocationCount,pname:maxSamplerAllocationCount&gt;&gt; member of the sname:VkPhysicalDeviceLimits structure. If pname:maxSamplerAllocationCount is exceeded, fname:vkCreateSampler will return ename:VK_ERROR_TOO_MANY_OBJECTS.</para>
        <para>Since sname:VkSampler is a non-dispatchable handle type, implementations may: return the same handle for sampler state vectors that are identical. In such cases, all such objects would only count once against the pname:maxSamplerAllocationCount limit.</para>
        <para>.Valid Usage **** * The absolute value of pname:mipLodBias must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxSamplerLodBias * If the &lt;&lt;features-features-samplerAnisotropy,anisotropic sampling&gt;&gt; feature is not enabled, pname:anisotropyEnable must: be ename:VK_FALSE * If pname:anisotropyEnable is ename:VK_TRUE, pname:maxAnisotropy must: be between `1.0` and sname:VkPhysicalDeviceLimits::pname:maxSamplerAnisotropy, inclusive * If pname:unnormalizedCoordinates is ename:VK_TRUE, pname:minFilter and pname:magFilter must: be equal * If pname:unnormalizedCoordinates is ename:VK_TRUE, pname:mipmapMode must: be ename:VK_SAMPLER_MIPMAP_MODE_NEAREST * If pname:unnormalizedCoordinates is ename:VK_TRUE, pname:minLod and pname:maxLod must: be zero * If pname:unnormalizedCoordinates is ename:VK_TRUE, pname:addressModeU and pname:addressModeV must: each be either ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE or ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER * If pname:unnormalizedCoordinates is ename:VK_TRUE, pname:anisotropyEnable must: be ename:VK_FALSE * If pname:unnormalizedCoordinates is ename:VK_TRUE, pname:compareEnable must: be ename:VK_FALSE * If any of pname:addressModeU, pname:addressModeV or pname:addressModeW are ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER, pname:borderColor must: be a valid elink:VkBorderColor value * If the +VK_KHR_sampler_mirror_clamp_to_edge+ extension is not enabled, pname:addressModeU, pname:addressModeV and pname:addressModeW must: not be ename:VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE * If pname:compareEnable is ename:VK_TRUE, pname:compareOp must: be a valid elink:VkCompareOp value ifdef::VK_IMG_filter_cubic[] * If either pname:magFilter or pname:minFilter is ename:VK_FILTER_CUBIC_IMG, pname:anisotropyEnable must: be ename:VK_FALSE endif::VK_IMG_filter_cubic[] ****</para>
      </description>
      <members>
        <member name="VK_SAMPLER_ADDRESS_MODE_REPEAT">ename:VK_SAMPLER_ADDRESS_MODE_REPEAT indicates that the repeat wrap mode will be used.</member>
        <member name="VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT">ename:VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT indicates that the mirrored repeat wrap mode will be used.</member>
        <member name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE">ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE indicates that the clamp to edge wrap mode will be used.</member>
        <member name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER">ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER indicates that the clamp to border wrap mode will be used.</member>
        <member name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE">ename:VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE indicates that the mirror clamp to edge wrap mode will be used. This is only valid if the +VK_KHR_mirror_clamp_to_edge+ extension is enabled.</member>
      </members>
    </type>
    <type name="VkSamplerCreateInfo" summary="Structure specifying parameters of a newly created sampler.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="magFilter">pname:magFilter is the magnification filter to apply to lookups, and is of type: + --</member>
      </members>
    </type>
    <type name="VkSamplerMipmapMode" summary="Specify mipmap mode used for texture lookups.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkSemaphore" summary="Opaque handle to a semaphore object.">
      <specification>
        <para>Semaphores are used to coordinate queue operations both within a queue and between different queues. A semaphore's status is always either _signaled_ or _unsignaled_.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkSemaphoreCreateInfo" summary="Structure specifying parameters of a newly created semaphore.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
      </members>
    </type>
    <type name="VkShaderModule" summary="Opaque handle to a shader module object.">
      <specification>
        <para>_Shader modules_ contain _shader code_ and one or more entry points. Shaders are selected from a shader module by specifying an entry point as part of &lt;&lt;pipelines,pipeline&gt;&gt; creation. The stages of a pipeline can: use shaders that come from different modules. The shader code defining a shader module must: be in the SPIR-V format, as described by the &lt;&lt;spirvenv,Vulkan Environment for SPIR-V&gt;&gt; appendix.</para>
      </specification>
      <description />
      <members />
    </type>
    <type name="VkShaderModuleCreateInfo" summary="Structure specifying parameters of a newly created shader module.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:codeSize must: be greater than 0 * pname:codeSize must: be a multiple of 4. If the +VK_NV_glsl_shader extension+ is enabled and pname:pCode references GLSL code pname:codeSize can be a multiple of 1 * pname:pCode must: point to valid SPIR-V code, formatted and packed as described by the &lt;&lt;spirv-spec,Khronos SPIR-V Specification&gt;&gt;. If the +VK_NV_glsl_shader+ extension is enabled pname:pCode can instead reference valid GLSL code and must: be written to the +GL_KHR_vulkan_glsl+ extension specification * pname:pCode must: adhere to the validation rules described by the &lt;&lt;spirvenv-module-validation, Validation Rules within a Module&gt;&gt; section of the &lt;&lt;spirvenv-capabilities,SPIR-V Environment&gt;&gt; appendix. If the +VK_NV_glsl_shader+ extension is enabled pname:pCode can be valid GLSL code with respect to the +GL_KHR_vulkan_glsl+ GLSL extension specification * pname:pCode must: declare the code:Shader capability for SPIR-V code * pname:pCode must: not declare any capability that is not supported by the API, as described by the &lt;&lt;spirvenv-module-validation, Capabilities&gt;&gt; section of the &lt;&lt;spirvenv-capabilities,SPIR-V Environment&gt;&gt; appendix * If pname:pCode declares any of the capabilities that are listed as not required by the implementation, the relevant feature must: be enabled, as listed in the &lt;&lt;spirvenv-capabilities-table,SPIR-V Environment&gt;&gt; appendix ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="codeSize">pname:codeSize is the size, in bytes, of the code pointed to by pname:pCode.</member>
        <member name="pCode">pname:pCode points to code that is used to create the shader module. The type and format of the code is determined from the content of the memory addressed by pname:pCode.</member>
      </members>
    </type>
    <type name="VkShaderStageFlagBits" summary="Bitmask specifying a pipeline stage.">
      <specification />
      <description>
        <para>.Valid Usage **** * If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:stage must: not be ename:VK_SHADER_STAGE_GEOMETRY_BIT * If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:stage must: not be ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT * pname:stage must: not be ename:VK_SHADER_STAGE_ALL_GRAPHICS, or ename:VK_SHADER_STAGE_ALL * pname:pName must: be the name of an code:OpEntryPoint in pname:module with an execution model that matches pname:stage * If the identified entry point includes any variable in its interface that is declared with the code:ClipDistance code:BuiltIn decoration, that variable must: not have an array size greater than sname:VkPhysicalDeviceLimits::pname:maxClipDistances * If the identified entry point includes any variable in its interface that is declared with the code:CullDistance code:BuiltIn decoration, that variable must: not have an array size greater than sname:VkPhysicalDeviceLimits::pname:maxCullDistances * If the identified entry point includes any variables in its interface that are declared with the code:ClipDistance or code:CullDistance code:BuiltIn decoration, those variables must: not have array sizes which sum to more than sname:VkPhysicalDeviceLimits::pname:maxCombinedClipAndCullDistances * If the identified entry point includes any variable in its interface that is declared with the code:SampleMask code:BuiltIn decoration, that variable must: not have an array size greater than sname:VkPhysicalDeviceLimits::pname:maxSampleMaskWords * If pname:stage is ename:VK_SHADER_STAGE_VERTEX_BIT, the identified entry point must: not include any input variable in its interface that is decorated with code:CullDistance * If pname:stage is ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, and the identified entry point has an code:OpExecutionMode instruction that specifies a patch size with code:OutputVertices, the patch size must: be greater than `0` and less than or equal to sname:VkPhysicalDeviceLimits::pname:maxTessellationPatchSize * If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, the identified entry point must: have an code:OpExecutionMode instruction that specifies a maximum output vertex count that is greater than `0` and less than or equal to sname:VkPhysicalDeviceLimits::pname:maxGeometryOutputVertices * If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, the identified entry point must: have an code:OpExecutionMode instruction that specifies an invocation count that is greater than `0` and less than or equal to sname:VkPhysicalDeviceLimits::pname:maxGeometryShaderInvocations * If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, and the identified entry point writes to code:Layer for any primitive, it must: write the same value to code:Layer for all vertices of a given primitive * If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, and the identified entry point writes to code:ViewportIndex for any primitive, it must: write the same value to code:ViewportIndex for all vertices of a given primitive * If pname:stage is ename:VK_SHADER_STAGE_FRAGMENT_BIT, the identified entry point must: not include any output variables in its interface decorated with code:CullDistance * If pname:stage is ename:VK_SHADER_STAGE_FRAGMENT_BIT, and the identified entry point writes to code:FragDepth in any execution path, it must: write to code:FragDepth in all execution paths ****</para>
      </description>
      <members />
    </type>
    <type name="VkSharingMode" summary="Buffer and image sharing modes.">
      <specification />
      <description>
        <para>[NOTE] .Note ==== ename:VK_SHARING_MODE_CONCURRENT may: result in lower performance access to the buffer or image than ename:VK_SHARING_MODE_EXCLUSIVE. ====</para>
        <para>Ranges of buffers and image subresources of image objects created using ename:VK_SHARING_MODE_EXCLUSIVE must: only be accessed by queues in the same queue family at any given time. In order for a different queue family to be able to interpret the memory contents of a range or image subresource, the application must: transfer exclusive ownership of the range or image subresource between the source and destination queue families with the following sequence of operations:</para>
        <para>. Release exclusive ownership from the source queue family to the destination queue family. . Use semaphores to ensure proper execution control for the ownership transfer. . Acquire exclusive ownership for the destination queue family from the source queue family.</para>
        <para>To release exclusive ownership of a range of a buffer or image subresource of an image object, the application must: execute a buffer or image memory barrier, respectively (see slink:VkBufferMemoryBarrier and slink:VkImageMemoryBarrier) on a queue from the source queue family. The pname:srcQueueFamilyIndex parameter of the barrier must: be set to the source queue family index, and the pname:dstQueueFamilyIndex parameter to the destination queue family index.</para>
        <para>To acquire exclusive ownership, the application must: execute the same buffer or image memory barrier (i.e. an identically defined instance of the slink:VkBufferMemoryBarrier or slink:VkImageMemoryBarrier structure that was used for the exclusive ownership release) on a queue from the destination queue family.</para>
        <para>Upon creation, resources using ename:VK_SHARING_MODE_EXCLUSIVE are not owned by any queue family. A buffer or image memory barrier is not required to acquire ownership when no queue family owns the resource - it is implicitly acquired upon first use within a queue. However, images still require a &lt;&lt;resources-image-layouts,layout transition&gt;&gt; from ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED before being used on the first queue. This layout transition can: either be accomplished by an image memory barrier or by use in a render pass instance.</para>
        <para>Once a queue family has used a range or image subresource of an ename:VK_SHARING_MODE_EXCLUSIVE resource, its contents are undefined to other queue families unless ownership is transferred. The contents may: also become undefined for other reasons, e.g. as a result of writes to an image subresource that aliases the same memory. A queue family can: take ownership of a range or image subresource without an ownership transfer in the same way as for a resource that was just created, however doing so means any contents written by other queue families or via incompatible aliases are undefined.</para>
      </description>
      <members>
        <member name="VK_SHARING_MODE_EXCLUSIVE">ename:VK_SHARING_MODE_EXCLUSIVE specifies that access to any range or image subresource of the object will be exclusive to a single queue family at a time.</member>
        <member name="VK_SHARING_MODE_CONCURRENT">ename:VK_SHARING_MODE_CONCURRENT specifies that concurrent access to any range or image subresource of the object from multiple queue families is supported.</member>
      </members>
    </type>
    <type name="VkSparseBufferMemoryBindInfo" summary="Structure specifying a sparse buffer memory bind operation.">
      <specification />
      <description />
      <members>
        <member name="buffer">pname:buffer is the sname:VkBuffer object to be bound.</member>
        <member name="bindCount">pname:bindCount is the number of sname:VkSparseMemoryBind structures in the pname:pBinds array.</member>
        <member name="pBinds">pname:pBinds is a pointer to array of sname:VkSparseMemoryBind structures.</member>
      </members>
    </type>
    <type name="VkSparseImageFormatFlagBits" summary="Bitmask specifying additional information about a sparse image resource.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkSparseImageFormatProperties" summary="Structure specifying sparse image format properties.">
      <specification />
      <description />
      <members>
        <member name="aspectMask">pname:aspectMask is a bitmask of elink:VkImageAspectFlagBits specifying which aspects of the image the properties apply to.</member>
        <member name="imageGranularity">pname:imageGranularity is the width, height, and depth of the sparse image block in texels or compressed texel blocks.</member>
        <member name="flags">pname:flags is a bitmask specifying additional information about the sparse resource. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkSparseImageMemoryBind" summary="Structure specifying sparse image memory bind.">
      <specification />
      <description>
        <para>.Valid Usage **** * If the &lt;&lt;features-features-sparseResidencyAliased,sparse aliased residency&gt;&gt; feature is not enabled, and if any other resources are bound to ranges of pname:memory, the range of pname:memory being bound must: not overlap with those bound ranges * pname:memory and pname:memoryOffset must: match the memory requirements of the calling command's pname:image, as described in section &lt;&lt;resources-association&gt;&gt; * pname:subresource must: be a valid image subresource for pname:image (see &lt;&lt;resources-image-views&gt;&gt;) * pname:offset.x must: be a multiple of the sparse image block width (sname:VkSparseImageFormatProperties::pname:imageGranularity.width) of the image * pname:extent.width must: either be a multiple of the sparse image block width of the image, or else pname:extent.width + pname:offset.x must: equal the width of the image subresource * pname:offset.y must: be a multiple of the sparse image block height (sname:VkSparseImageFormatProperties::pname:imageGranularity.height) of the image * pname:extent.height must: either be a multiple of the sparse image block height of the image, or else pname:extent.height + pname:offset.y must: equal the height of the image subresource * pname:offset.z must: be a multiple of the sparse image block depth (sname:VkSparseImageFormatProperties::pname:imageGranularity.depth) of the image * pname:extent.depth must: either be a multiple of the sparse image block depth of the image, or else pname:extent.depth + pname:offset.z must: equal the depth of the image subresource ****</para>
      </description>
      <members>
        <member name="subresource">pname:subresource is the aspectMask and region of interest in the image.</member>
        <member name="offset">pname:offset are the coordinates of the first texel within the image subresource to bind.</member>
        <member name="extent">pname:extent is the size in texels of the region within the image subresource to bind. The extent must: be a multiple of the sparse image block dimensions, except when binding sparse image blocks along the edge of an image subresource it can: instead be such that any coordinate of [eq]#pname:offset + pname:extent# equals the corresponding dimensions of the image subresource.</member>
        <member name="memory">pname:memory is the sname:VkDeviceMemory object that the sparse image blocks of the image are bound to. If pname:memory is dlink:VK_NULL_HANDLE, the sparse image blocks are unbound.</member>
        <member name="memoryOffset">pname:memoryOffset is an offset into sname:VkDeviceMemory object. If pname:memory is dlink:VK_NULL_HANDLE, this value is ignored.</member>
        <member name="flags">pname:flags are sparse memory binding flags.</member>
      </members>
    </type>
    <type name="VkSparseImageMemoryBindInfo" summary="Structure specifying sparse image memory bind info.">
      <specification />
      <description />
      <members>
        <member name="image">pname:image is the sname:VkImage object to be bound</member>
        <member name="bindCount">pname:bindCount is the number of sname:VkSparseImageMemoryBind structures in pBinds array</member>
        <member name="pBinds">pname:pBinds is a pointer to array of sname:VkSparseImageMemoryBind structures</member>
      </members>
    </type>
    <type name="VkSparseImageMemoryRequirements" summary="Structure specifying sparse image memory requirements.">
      <specification />
      <description />
      <members>
        <member name="formatProperties.aspectMask">pname:formatProperties.aspectMask is the set of aspects of the image that this sparse memory requirement applies to. This will usually have a single aspect specified. However, depth/stencil images may: have depth and stencil data interleaved in the same sparse block, in which case both ename:VK_IMAGE_ASPECT_DEPTH_BIT and ename:VK_IMAGE_ASPECT_STENCIL_BIT would be present.</member>
        <member name="formatProperties.imageGranularity">pname:formatProperties.imageGranularity describes the dimensions of a single bindable sparse image block in pixel units. For aspect ename:VK_IMAGE_ASPECT_METADATA_BIT, all dimensions will be zero pixels. All metadata is located in the mip tail region.</member>
        <member name="formatProperties.flags">pname:formatProperties.flags is a bitmask of elink:VkSparseImageFormatFlagBits:</member>
        <member name="VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT">* If ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT is set the image uses a single mip tail region for all array layers.</member>
        <member name="VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT">* If ename:VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT is set the dimensions of mip levels must: be integer multiples of the corresponding dimensions of the sparse image block for levels not located in the mip tail.</member>
        <member name="VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT">* If ename:VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT is set the image uses non-standard sparse image block dimensions. The pname:formatProperties.imageGranularity values do not match the standard sparse image block dimension corresponding to the image's pixel format.</member>
        <member name="imageMipTailFirstLod">pname:imageMipTailFirstLod is the first mip level at which image subresources are included in the mip tail region.</member>
        <member name="imageMipTailSize">pname:imageMipTailSize is the memory size (in bytes) of the mip tail region. If pname:formatProperties.flags contains ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT, this is the size of the whole mip tail, otherwise this is the size of the mip tail of a single array layer. This value is guaranteed to be a multiple of the sparse block size in bytes.</member>
        <member name="imageMipTailOffset">pname:imageMipTailOffset is the opaque memory offset used with slink:VkSparseImageOpaqueMemoryBindInfo to bind the mip tail region(s).</member>
        <member name="imageMipTailStride">pname:imageMipTailStride is the offset stride between each array-layer's mip tail, if pname:formatProperties.flags does not contain ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT (otherwise the value is undefined).</member>
      </members>
    </type>
    <type name="VkSparseImageOpaqueMemoryBindInfo" summary="Structure specifying sparse image opaque memory bind info.">
      <specification />
      <description>
        <para>.Valid Usage **** * For any given element of pname:pBinds, if the pname:flags member of that element contains ename:VK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range defined must: be within the mip tail region of the metadata aspect of pname:image ****</para>
      </description>
      <members>
        <member name="image">pname:image is the sname:VkImage object to be bound.</member>
        <member name="bindCount">pname:bindCount is the number of sname:VkSparseMemoryBind structures in the pname:pBinds array.</member>
        <member name="pBinds">pname:pBinds is a pointer to array of sname:VkSparseMemoryBind structures.</member>
      </members>
    </type>
    <type name="VkSparseMemoryBind" summary="Structure specifying a sparse memory bind operation.">
      <specification />
      <description />
      <members>
        <member name="resourceOffset">pname:resourceOffset is the offset into the resource.</member>
        <member name="size">pname:size is the size of the memory region to be bound.</member>
        <member name="memory">pname:memory is the sname:VkDeviceMemory object that the range of the resource is bound to. If pname:memory is dlink:VK_NULL_HANDLE, the range is unbound.</member>
        <member name="memoryOffset">pname:memoryOffset is the offset into the sname:VkDeviceMemory object to bind the resource range to. If pname:memory is dlink:VK_NULL_HANDLE, this value is ignored.</member>
        <member name="flags">pname:flags is a bitmask specifying usage of the binding operation. Bits which can: be set include: + --</member>
      </members>
    </type>
    <type name="VkSparseMemoryBindFlagBits" summary="Bitmask specifying usage of a sparse memory binding operation.">
      <specification />
      <description>
        <para>The _binding range_ [eq]#[pname:resourceOffset, pname:resourceOffset {plus} pname:size)# has different constraints based on pname:flags. If pname:flags contains ename:VK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range must: be within the mip tail region of the metadata aspect. This metadata region is defined by:</para>
        <para>:: [eq]#metadataRegion = [base, base + pname:imageMipTailSize)# :: [eq]#base = pname:imageMipTailOffset + pname:imageMipTailStride {times} n#</para>
        <para>and pname:imageMipTailOffset, pname:imageMipTailSize, and pname:imageMipTailStride values are from the slink:VkSparseImageMemoryRequirements corresponding to the metadata aspect of the image, and [eq]#n# is a valid array layer index for the image,</para>
        <para>pname:imageMipTailStride is considered to be zero for aspects where sname:VkSparseImageMemoryRequirements::pname:formatProperties.flags contains ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT.</para>
        <para>If pname:flags does not contain ename:VK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range must: be within the range [eq]#[0,slink:VkMemoryRequirements::pname:size)#.</para>
        <para>.Valid Usage **** * If pname:memory is not dlink:VK_NULL_HANDLE, pname:memory and pname:memoryOffset must: match the memory requirements of the resource, as described in section &lt;&lt;resources-association&gt;&gt; * If pname:memory is not dlink:VK_NULL_HANDLE, pname:memory must: not have been created with a memory type that reports ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set * pname:size must: be greater than `0` * pname:resourceOffset must: be less than the size of the resource * pname:size must: be less than or equal to the size of the resource minus pname:resourceOffset * pname:memoryOffset must: be less than the size of pname:memory * pname:size must: be less than or equal to the size of pname:memory minus pname:memoryOffset ****</para>
      </description>
      <members />
    </type>
    <type name="VkSpecializationInfo" summary="Structure specifying specialization info.">
      <specification />
      <description>
        <para>pname:pMapEntries points to a structure of type slink:VkSpecializationMapEntry.</para>
        <para>.Valid Usage **** * The pname:offset member of any given element of pname:pMapEntries must: be less than pname:dataSize * For any given element of pname:pMapEntries, pname:size must: be less than or equal to pname:dataSize minus pname:offset ****</para>
      </description>
      <members>
        <member name="mapEntryCount">pname:mapEntryCount is the number of entries in the pname:pMapEntries array.</member>
        <member name="pMapEntries">pname:pMapEntries is a pointer to an array of sname:VkSpecializationMapEntry which maps constant IDs to offsets in pname:pData.</member>
        <member name="dataSize">pname:dataSize is the byte size of the pname:pData buffer.</member>
        <member name="pData">pname:pData contains the actual constant values to specialize with.</member>
      </members>
    </type>
    <type name="VkSpecializationMapEntry" summary="Structure specifying a specialization map entry.">
      <specification />
      <description>
        <para>If a pname:constantID value is not a specialization constant ID used in the shader, that map entry does not affect the behavior of the pipeline.</para>
        <para>.Valid Usage **** * For a pname:constantID specialization constant declared in a shader, pname:size must: match the byte size of the pname:constantID. If the specialization constant is of type code:boolean, pname:size must: be the byte size of basetype:VkBool32 ****</para>
      </description>
      <members>
        <member name="constantID">pname:constantID is the ID of the specialization constant in SPIR-V.</member>
        <member name="offset">pname:offset is the byte offset of the specialization constant value within the supplied data buffer.</member>
        <member name="size">pname:size is the byte size of the specialization constant value within the supplied data buffer.</member>
      </members>
    </type>
    <type name="VkStencilFaceFlagBits" summary="Bitmask specifying sets of stencil state for which to update the compare mask.">
      <specification />
      <description>
        <para>.Valid Usage **** * The currently bound graphics pipeline must: have been created with the ename:VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK dynamic state enabled ****</para>
      </description>
      <members />
    </type>
    <type name="VkStencilOp" summary="Stencil comparison function.">
      <specification />
      <description>
        <para>For purposes of increment and decrement, the stencil bits are considered as an unsigned integer.</para>
        <para>If the stencil test fails, the sample's coverage bit is cleared in the fragment. If there is no stencil framebuffer attachment, stencil modification cannot: occur, and it is as if the stencil tests always pass.</para>
        <para>If the stencil test passes, the pname:writeMask member of the slink:VkStencilOpState structures controls how the updated stencil value is written to the stencil framebuffer attachment.</para>
        <para>The least significant [eq]#s# bits of pname:writeMask, where [eq]#s# is the number of bits in the stencil framebuffer attachment, specify an integer mask. Where a [eq]#1# appears in this mask, the corresponding bit in the stencil value in the depth/stencil attachment is written; where a [eq]#0# appears, the bit is not written. The pname:writeMask value uses either the front-facing or back-facing state based on the facing-ness of the fragment. Fragments generated by front-facing primitives use the front mask and fragments generated by back-facing primitives use the back mask.</para>
      </description>
      <members>
        <member name="VK_STENCIL_OP_KEEP">ename:VK_STENCIL_OP_KEEP keeps the current value.</member>
        <member name="VK_STENCIL_OP_ZERO">ename:VK_STENCIL_OP_ZERO sets the value to 0.</member>
        <member name="VK_STENCIL_OP_REPLACE">ename:VK_STENCIL_OP_REPLACE sets the value to pname:reference.</member>
        <member name="VK_STENCIL_OP_INCREMENT_AND_CLAMP">ename:VK_STENCIL_OP_INCREMENT_AND_CLAMP increments the current value and clamps to the maximum representable unsigned value.</member>
        <member name="VK_STENCIL_OP_DECREMENT_AND_CLAMP">ename:VK_STENCIL_OP_DECREMENT_AND_CLAMP decrements the current value and clamps to 0.</member>
        <member name="VK_STENCIL_OP_INVERT">ename:VK_STENCIL_OP_INVERT bitwise-inverts the current value.</member>
        <member name="VK_STENCIL_OP_INCREMENT_AND_WRAP">ename:VK_STENCIL_OP_INCREMENT_AND_WRAP increments the current value and wraps to 0 when the maximum value would have been exceeded.</member>
        <member name="VK_STENCIL_OP_DECREMENT_AND_WRAP">ename:VK_STENCIL_OP_DECREMENT_AND_WRAP decrements the current value and wraps to the maximum possible value when the value would go below 0.</member>
      </members>
    </type>
    <type name="VkStencilOpState" summary="Structure specifying stencil operation state.">
      <specification />
      <description />
      <members>
        <member name="failOp">pname:failOp is the action performed on samples that fail the stencil test.</member>
        <member name="passOp">pname:passOp is the action performed on samples that pass both the depth and stencil tests.</member>
        <member name="depthFailOp">pname:depthFailOp is the action performed on samples that pass the stencil test and fail the depth test.</member>
        <member name="compareOp">pname:compareOp is the comparison operator used in the stencil test.</member>
        <member name="compareMask">pname:compareMask selects the bits of the unsigned integer stencil values participating in the stencil test.</member>
        <member name="writeMask">pname:writeMask selects the bits of the unsigned integer stencil values updated by the stencil test in the stencil framebuffer attachment.</member>
        <member name="reference">pname:reference is an integer reference value that is used in the unsigned stencil comparison.</member>
      </members>
    </type>
    <type name="VkSubmitInfo" summary="Structure specifying a queue submit operation.">
      <specification />
      <description>
        <para>.Valid Usage **** * Any given element of pname:pSignalSemaphores must: currently be unsignaled * Any given element of pname:pCommandBuffers must: either have been recorded with the ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, or not currently be executing on the device * Any given element of pname:pCommandBuffers must: be in the executable state * If any given element of pname:pCommandBuffers contains commands that execute secondary command buffers, those secondary command buffers must: have been recorded with the ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, or not currently be executing on the device * If any given element of pname:pCommandBuffers was recorded with ename:VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, it must: not have been previously submitted without re-recording that command buffer * If any given element of pname:pCommandBuffers contains commands that execute secondary command buffers recorded with ename:VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, each such secondary command buffer must: not have been previously submitted without re-recording that command buffer * Any given element of pname:pCommandBuffers must: not contain commands that execute a secondary command buffer, if that secondary command buffer has been recorded in another primary command buffer after it was recorded into this sname:VkCommandBuffer * Any given element of pname:pCommandBuffers must: have been allocated from a sname:VkCommandPool that was created for the same queue family that the calling command's pname:queue belongs to * Any given element of pname:pCommandBuffers must: not have been allocated with ename:VK_COMMAND_BUFFER_LEVEL_SECONDARY * Any given element of sname:VkSemaphore in pname:pWaitSemaphores must: refer to a prior signal of that sname:VkSemaphore that will not be consumed by any other wait on that semaphore * If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, any given element of pname:pWaitDstStageMask must: not contain ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT * If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, any given element of pname:pWaitDstStageMask must: not contain ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="waitSemaphoreCount">pname:waitSemaphoreCount is the number of semaphores upon which to wait before executing the command buffers for the batch.</member>
        <member name="pWaitSemaphores">pname:pWaitSemaphores is a pointer to an array of semaphores upon which to wait before the command buffers for this batch begin execution. If semaphores to wait on are provided, they define a &lt;&lt;synchronization-semaphores-waiting, semaphore wait operation&gt;&gt;.</member>
        <member name="pWaitDstStageMask">pname:pWaitDstStageMask is a pointer to an array of pipeline stages at which each corresponding semaphore wait will occur.</member>
        <member name="commandBufferCount">pname:commandBufferCount is the number of command buffers to execute in the batch.</member>
        <member name="pCommandBuffers">pname:pCommandBuffers is a pointer to an array of command buffers to execute in the batch. The command buffers submitted in a batch begin execution in the order they appear in pname:pCommandBuffers, but may: complete out of order.</member>
        <member name="signalSemaphoreCount">pname:signalSemaphoreCount is the number of semaphores to be signaled once the commands specified in pname:pCommandBuffers have completed execution.</member>
        <member name="pSignalSemaphores">pname:pSignalSemaphores is a pointer to an array of semaphores which will be signaled when the command buffers for this batch have completed execution. If semaphores to be signaled are provided, they define a &lt;&lt;synchronization-semaphores-signaling, semaphore signal operation&gt;&gt;.</member>
      </members>
    </type>
    <type name="VkSubpassContents" summary="Specify how commands in the first subpass of a render pass are provided.">
      <specification />
      <description>
        <para>After beginning a render pass instance, the command buffer is ready to record the commands for the first subpass of that render pass.</para>
        <para>.Valid Usage **** * If any of the pname:initialLayout or pname:finalLayout member of the sname:VkAttachmentDescription structures or the pname:layout member of the sname:VkAttachmentReference structures specified when creating the render pass specified in the pname:renderPass member of pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the pname:framebuffer member of pname:pRenderPassBegin must: have been created with ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT set * If any of the pname:initialLayout or pname:finalLayout member of the sname:VkAttachmentDescription structures or the pname:layout member of the sname:VkAttachmentReference structures specified when creating the render pass specified in the pname:renderPass member of pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the pname:framebuffer member of pname:pRenderPassBegin must: have been created with ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set * If any of the pname:initialLayout or pname:finalLayout member of the sname:VkAttachmentDescription structures or the pname:layout member of the sname:VkAttachmentReference structures specified when creating the render pass specified in the pname:renderPass member of pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the pname:framebuffer member of pname:pRenderPassBegin must: have been created with ename:VK_IMAGE_USAGE_SAMPLED_BIT or ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set * If any of the pname:initialLayout or pname:finalLayout member of the sname:VkAttachmentDescription structures or the pname:layout member of the sname:VkAttachmentReference structures specified when creating the render pass specified in the pname:renderPass member of pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the pname:framebuffer member of pname:pRenderPassBegin must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT set * If any of the pname:initialLayout or pname:finalLayout member of the sname:VkAttachmentDescription structures or the pname:layout member of the sname:VkAttachmentReference structures specified when creating the render pass specified in the pname:renderPass member of pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the pname:framebuffer member of pname:pRenderPassBegin must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT set * If any of the pname:initialLayout members of the sname:VkAttachmentDescription structures specified when creating the render pass specified in the pname:renderPass member of pname:pRenderPassBegin is not ename:VK_IMAGE_LAYOUT_UNDEFINED, then each such pname:initialLayout must: be equal to the current layout of the corresponding attachment image subresource of the framebuffer specified in the pname:framebuffer member of pname:pRenderPassBegin ****</para>
      </description>
      <members />
    </type>
    <type name="VkSubpassDependency" summary="Structure specifying a subpass dependency.">
      <specification />
      <description />
      <members>
        <member name="srcSubpass">pname:srcSubpass and pname:dstSubpass are the subpass indices of the producer and consumer subpasses, respectively. pname:srcSubpass and pname:dstSubpass can: also have the special value ename:VK_SUBPASS_EXTERNAL. The source subpass must: always be a lower numbered subpass than the destination subpass (excluding external subpasses and &lt;&lt;synchronization-pipeline-barriers-subpass-self-dependencies, self-dependencies&gt;&gt;), so that the order of subpass descriptions is a valid execution ordering, avoiding cycles in the dependency graph.</member>
        <member name="srcStageMask">pname:srcStageMask, pname:dstStageMask, pname:srcAccessMask, pname:dstAccessMask, and pname:dependencyFlags describe an &lt;&lt;synchronization-execution-and-memory-dependencies,execution and memory dependency&gt;&gt; between subpasses. The bits that can: be included in pname:dependencyFlags are: + --</member>
      </members>
    </type>
    <type name="VkSubpassDescription" summary="Structure specifying a subpass description.">
      <specification />
      <description>
        <para>The contents of an attachment within the render area become undefined at the start of a subpass S if all of the following conditions are true:</para>
        <para>* The attachment is used as a color, depth/stencil, or resolve attachment in any subpass in the render pass. * There is a subpass S1 that uses or preserves the attachment, and a subpass dependency from S1 to S. * The attachment is not used or preserved in subpass S.</para>
        <para>Once the contents of an attachment become undefined in subpass S, they remain undefined for subpasses in subpass dependency chains starting with subpass S until they are written again. However, they remain valid for subpasses in other subpass dependency chains starting with subpass S1 if those subpasses use or preserve the attachment.</para>
        <para>.Valid Usage **** * pname:pipelineBindPoint must: be ename:VK_PIPELINE_BIND_POINT_GRAPHICS * pname:colorAttachmentCount must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxColorAttachments * If the first use of an attachment in this render pass is as an input attachment, and the attachment is not also used as a color or depth/stencil attachment in the same subpass, then pname:loadOp must: not be ename:VK_ATTACHMENT_LOAD_OP_CLEAR * If pname:pResolveAttachments is not `NULL`, for each resolve attachment that does not have the value ename:VK_ATTACHMENT_UNUSED, the corresponding color attachment must: not have the value ename:VK_ATTACHMENT_UNUSED * If pname:pResolveAttachments is not `NULL`, the sample count of each element of pname:pColorAttachments must: be anything other than ename:VK_SAMPLE_COUNT_1_BIT * Any given element of pname:pResolveAttachments must: have a sample count of ename:VK_SAMPLE_COUNT_1_BIT * Any given element of pname:pResolveAttachments must: have the same elink:VkFormat as its corresponding color attachment * All attachments in pname:pColorAttachments and pname:pDepthStencilAttachment that are not ename:VK_ATTACHMENT_UNUSED must: have the same sample count * If any input attachments are ename:VK_ATTACHMENT_UNUSED, then any pipelines bound during the subpass must: not access those input attachments from the fragment shader * The pname:attachment member of any element of pname:pPreserveAttachments must: not be ename:VK_ATTACHMENT_UNUSED * Any given element of pname:pPreserveAttachments must: not also be an element of any other member of the subpass description * If any attachment is used as both an input attachment and a color or depth/stencil attachment, then each use must: use the same pname:layout ****</para>
      </description>
      <members>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="pipelineBindPoint">pname:pipelineBindPoint is a elink:VkPipelineBindPoint value specifying whether this is a compute or graphics subpass. Currently, only graphics subpasses are supported.</member>
        <member name="inputAttachmentCount">pname:inputAttachmentCount is the number of input attachments.</member>
        <member name="pInputAttachments">pname:pInputAttachments is an array of slink:VkAttachmentReference structures (defined below) that lists which of the render pass's attachments can: be read in the shader during the subpass, and what layout each attachment will be in during the subpass. Each element of the array corresponds to an input attachment unit number in the shader, i.e. if the shader declares an input variable `layout(input_attachment_index=X, set=Y, binding=Z)` then it uses the attachment provided in pname:pInputAttachments[X]. Input attachments must: also be bound to the pipeline with a descriptor set, with the input attachment descriptor written in the location (set=Y, binding=Z).</member>
        <member name="colorAttachmentCount">pname:colorAttachmentCount is the number of color attachments.</member>
        <member name="pColorAttachments">pname:pColorAttachments is an array of pname:colorAttachmentCount slink:VkAttachmentReference structures that lists which of the render pass's attachments will be used as color attachments in the subpass, and what layout each attachment will be in during the subpass. Each element of the array corresponds to a fragment shader output location, i.e. if the shader declared an output variable `layout(location=X)` then it uses the attachment provided in pname:pColorAttachments[X].</member>
        <member name="pResolveAttachments">pname:pResolveAttachments is `NULL` or an array of pname:colorAttachmentCount slink:VkAttachmentReference structures that lists which of the render pass's attachments are resolved to at the end of the subpass, and what layout each attachment will be in during the resolve. If pname:pResolveAttachments is not `NULL`, each of its elements corresponds to a color attachment (the element in pname:pColorAttachments at the same index). At the end of each subpass, the subpass's color attachments are resolved to corresponding resolve attachments, unless the resolve attachment index is ename:VK_ATTACHMENT_UNUSED or pname:pResolveAttachments is `NULL`. If the first use of an attachment in a render pass is as a resolve attachment, then the pname:loadOp is effectively ignored as the resolve is guaranteed to overwrite all pixels in the render area.</member>
        <member name="pDepthStencilAttachment">pname:pDepthStencilAttachment is a pointer to a slink:VkAttachmentReference specifying which attachment will be used for depth/stencil data and the layout it will be in during the subpass. Setting the attachment index to ename:VK_ATTACHMENT_UNUSED or leaving this pointer as `NULL` indicates that no depth/stencil attachment will be used in the subpass.</member>
        <member name="preserveAttachmentCount">pname:preserveAttachmentCount is the number of preserved attachments.</member>
        <member name="pPreserveAttachments">pname:pPreserveAttachments is an array of pname:preserveAttachmentCount render pass attachment indices describing the attachments that are not used by a subpass, but whose contents must: be preserved throughout the subpass.</member>
      </members>
    </type>
    <type name="VkSubresourceLayout" summary="Structure specifying subresource layout.">
      <specification />
      <description>
        <para>For images created with linear tiling, pname:rowPitch, pname:arrayPitch and pname:depthPitch describe the layout of the image subresource in linear memory. For uncompressed formats, pname:rowPitch is the number of bytes between texels with the same x coordinate in adjacent rows (y coordinates differ by one). pname:arrayPitch is the number of bytes between texels with the same x and y coordinate in adjacent array layers of the image (array layer values differ by one). pname:depthPitch is the number of bytes between texels with the same x and y coordinate in adjacent slices of a 3D image (z coordinates differ by one). Expressed as an addressing formula, the starting byte of a texel in the image subresource has address:</para>
        <para>[source,c] --------------------------------------------------- // (x,y,z,layer) are in texel coordinates address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*elementSize + offset ---------------------------------------------------</para>
        <para>For compressed formats, the pname:rowPitch is the number of bytes between compressed texel blocks in adjacent rows. pname:arrayPitch is the number of bytes between compressed texel blocks in adjacent array layers. pname:depthPitch is the number of bytes between compressed texel blocks in adjacent slices of a 3D image.</para>
        <para>[source,c] --------------------------------------------------- // (x,y,z,layer) are in compressed texel block coordinates address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*compressedTexelBlockByteSize + offset; ---------------------------------------------------</para>
        <para>pname:arrayPitch is undefined for images that were not created as arrays. pname:depthPitch is defined only for 3D images.</para>
        <para>For color formats, the pname:aspectMask member of sname:VkImageSubresource must: be ename:VK_IMAGE_ASPECT_COLOR_BIT. For depth/stencil formats, pname:aspectMask must: be either ename:VK_IMAGE_ASPECT_DEPTH_BIT or ename:VK_IMAGE_ASPECT_STENCIL_BIT. On implementations that store depth and stencil aspects separately, querying each of these image subresource layouts will return a different pname:offset and pname:size representing the region of memory used for that aspect. On implementations that store depth and stencil aspects interleaved, the same pname:offset and pname:size are returned and represent the interleaved memory allocation.</para>
      </description>
      <members>
        <member name="offset">pname:offset is the byte offset from the start of the image where the image subresource begins.</member>
        <member name="size">pname:size is the size in bytes of the image subresource. pname:size includes any extra memory that is required based on pname:rowPitch.</member>
        <member name="rowPitch">pname:rowPitch describes the number of bytes between each row of texels in an image.</member>
        <member name="arrayPitch">pname:arrayPitch describes the number of bytes between each array layer of an image.</member>
        <member name="depthPitch">pname:depthPitch describes the number of bytes between each slice of 3D image.</member>
      </members>
    </type>
    <type name="VkSurfaceCapabilitiesKHR" summary="Structure describing capabilities of a surface.">
      <specification />
      <description>
        <para>[NOTE] .Note ==== Formulas such as [eq]#min(N, pname:maxImageCount)# are not correct, since pname:maxImageCount may: be zero. ====</para>
      </description>
      <members>
        <member name="minImageCount">pname:minImageCount is the minimum number of images the specified device supports for a swapchain created for the surface.</member>
        <member name="maxImageCount">pname:maxImageCount is the maximum number of images the specified device supports for a swapchain created for the surface. A value of 0 means that there is no limit on the number of images, though there may: be limits related to the total amount of memory used by swapchain images.</member>
        <member name="currentExtent">pname:currentExtent is the current width and height of the surface, or the special value [eq]#(0xFFFFFFFF, 0xFFFFFFFF)# indicating that the surface size will be determined by the extent of a swapchain targeting the surface.</member>
        <member name="minImageExtent">pname:minImageExtent contains the smallest valid swapchain extent for the surface on the specified device.</member>
        <member name="maxImageExtent">pname:maxImageExtent contains the largest valid swapchain extent for the surface on the specified device.</member>
        <member name="maxImageArrayLayers">pname:maxImageArrayLayers is the maximum number of layers swapchain images can: have for a swapchain created for this device and surface.</member>
        <member name="supportedTransforms">pname:supportedTransforms is a bitmask of elink:VkSurfaceTransformFlagBitsKHR, describing the presentation transforms supported for the surface on the specified device.</member>
        <member name="currentTransform">pname:currentTransform is a bitmask of elink:VkSurfaceTransformFlagBitsKHR, describing the surface's current transform relative to the presentation engine's natural orientation.</member>
        <member name="supportedCompositeAlpha">pname:supportedCompositeAlpha is a bitmask of elink:VkCompositeAlphaFlagBitsKHR, representing the alpha compositing modes supported by the presentation engine for the surface on the specified device. Opaque composition can: be achieved in any alpha compositing mode by either using a swapchain image format that has no alpha component, or by ensuring that all pixels in the swapchain images have an alpha value of 1.0.</member>
        <member name="supportedUsageFlags">pname:supportedUsageFlags is a bitmask of elink:VkImageUsageFlagBits representing the ways the application can: use the presentable images of a swapchain created for the surface on the specified device. ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT must: be included in the set but implementations may: support additional usages.</member>
      </members>
    </type>
    <type name="VkSurfaceFormatKHR" summary="Structure describing a supported swapchain format-color space pair.">
      <specification />
      <description />
      <members>
        <member name="format">pname:format is a ename:VkFormat that is compatible with the specified surface.</member>
        <member name="colorSpace">pname:colorSpace is a presentation ename:VkColorSpaceKHR that is compatible with the surface.</member>
      </members>
    </type>
    <type name="VkSurfaceTransformFlagBitsKHR" summary="Presentation transforms supported on a device.">
      <specification />
      <description />
      <members>
        <member name="VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR">ename:VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR: The image content is presented without being transformed.</member>
        <member name="VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR">ename:VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR: The image content is rotated 90 degrees clockwise.</member>
        <member name="VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR">ename:VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR: The image content is rotated 180 degrees clockwise.</member>
        <member name="VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR">ename:VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR: The image content is rotated 270 degrees clockwise.</member>
        <member name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR">ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR: The image content is mirrored horizontally.</member>
        <member name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR">ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR: The image content is mirrored horizontally, then rotated 90 degrees clockwise.</member>
        <member name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR">ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR: The image content is mirrored horizontally, then rotated 180 degrees clockwise.</member>
        <member name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR">ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR: The image content is mirrored horizontally, then rotated 270 degrees clockwise.</member>
        <member name="VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR">ename:VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR: The presentation transform is not specified, and is instead determined by platform-specific considerations and mechanisms outside Vulkan.</member>
      </members>
    </type>
    <type name="VkSwapchainCreateInfoKHR" summary="Structure specifying parameters of a newly created swapchain object.">
      <specification />
      <description>
        <para>[NOTE] .Note ==== Applications should: set this value to ename:VK_TRUE if they do not expect to read back the content of presentable images before presenting them or after reacquiring them and if their pixel shaders do not have any side effects that require them to run for all pixels in the presentable image. ====</para>
        <para>* pname:oldSwapchain, if not code:VK_NULL_HANDLE, specifies the swapchain that will be replaced by the new swapchain being created. The new swapchain will be a descendant of pname:oldSwapchain. Further, any descendants of the new swapchain will also be descendants of pname:oldSwapchain. Upon calling fname:vkCreateSwapchainKHR with a pname:oldSwapchain that is not code:VK_NULL_HANDLE, any images not acquired by the application may: be freed by the implementation, which may: occur even if creation of the new swapchain fails. The application must: destroy the old swapchain to free all memory associated with the old swapchain. The application must: wait for the completion of any outstanding rendering to images it currently has acquired at the time the swapchain is destroyed. The application can: continue to present any images it acquired and has not yet presented using the old swapchain, as long as it has not entered a state that causes it to return ename:VK_ERROR_OUT_OF_DATE_KHR. However, the application cannot: acquire any more images from the old swapchain regardless of whether or not creation of the new swapchain succeeds.</para>
        <para>.Valid Usage **** * pname:surface must: be a surface that is supported by the device as determined using fname:vkGetPhysicalDeviceSurfaceSupportKHR * pname:minImageCount must: be greater than or equal to the value returned in the pname:minImageCount member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface * pname:minImageCount must: be less than or equal to the value returned in the pname:maxImageCount member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface if the returned pname:maxImageCount is not zero * pname:imageFormat and pname:imageColorSpace must: match the pname:format and pname:colorSpace members, respectively, of one of the sname:VkSurfaceFormatKHR structures returned by fname:vkGetPhysicalDeviceSurfaceFormatsKHR for the surface * pname:imageExtent must: be between pname:minImageExtent and pname:maxImageExtent, inclusive, where pname:minImageExtent and pname:maxImageExtent are members of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface * pname:imageArrayLayers must: be greater than `0` and less than or equal to the pname:maxImageArrayLayers member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface * pname:imageUsage must: be a subset of the supported usage flags present in the pname:supportedUsageFlags member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface * If pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:pQueueFamilyIndices must: be a pointer to an array of pname:queueFamilyIndexCount basetype:uint32_t values * If pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:queueFamilyIndexCount must: be greater than `1` * pname:preTransform must: be one of the bits present in the pname:supportedTransforms member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface * pname:compositeAlpha must: be one of the bits present in the pname:supportedCompositeAlpha member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface * pname:presentMode must: be one of the ename:VkPresentModeKHR values returned by fname:vkGetPhysicalDeviceSurfacePresentModesKHR for the surface ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use, and must: be zero.</member>
        <member name="surface">pname:surface is the surface that the swapchain will present images to.</member>
        <member name="minImageCount">pname:minImageCount is the minimum number of presentable images that the application needs. The platform will either create the swapchain with at least that many images, or will fail to create the swapchain.</member>
        <member name="imageFormat">pname:imageFormat is a slink:VkFormat that is valid for swapchains on the specified surface.</member>
        <member name="imageColorSpace">pname:imageColorSpace is a slink:VkColorSpaceKHR that is valid for swapchains on the specified surface.</member>
        <member name="imageExtent">pname:imageExtent is the size (in pixels) of the swapchain. Behavior is platform-dependent when the image extent does not match the surface's pname:currentExtent as returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR.</member>
        <member name="imageArrayLayers">pname:imageArrayLayers is the number of views in a multiview/stereo surface. For non-stereoscopic-3D applications, this value is 1.</member>
        <member name="imageUsage">pname:imageUsage is a bitmask of elink:VkImageUsageFlagBits, indicating how the application will use the swapchain's presentable images.</member>
        <member name="imageSharingMode">pname:imageSharingMode is the sharing mode used for the images of the swapchain.</member>
        <member name="queueFamilyIndexCount">pname:queueFamilyIndexCount is the number of queue families having access to the images of the swapchain in case pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT.</member>
        <member name="pQueueFamilyIndices">pname:pQueueFamilyIndices is an array of queue family indices having access to the images of the swapchain in case pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT.</member>
        <member name="preTransform">pname:preTransform is a bitmask of elink:VkSurfaceTransformFlagBitsKHR, describing the transform, relative to the presentation engine's natural orientation, applied to the image content prior to presentation. If it does not match the pname:currentTransform value returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR, the presentation engine will transform the image content as part of the presentation operation.</member>
        <member name="compositeAlpha">pname:compositeAlpha is a bitmask of elink:VkCompositeAlphaFlagBitsKHR, indicating the alpha compositing mode to use when this surface is composited together with other surfaces on certain window systems.</member>
        <member name="presentMode">pname:presentMode is the presentation mode the swapchain will use. A swapchain's present mode determines how incoming present requests will be processed and queued internally.</member>
        <member name="clipped">pname:clipped indicates whether the Vulkan implementation is allowed to discard rendering operations that affect regions of the surface which are not visible.</member>
        <member name="VK_TRUE">* If set to ename:VK_TRUE, the presentable images associated with the swapchain may: not own all of their pixels. Pixels in the presentable images that correspond to regions of the target surface obscured by another window on the desktop or subject to some other clipping mechanism will have undefined content when read back. Pixel shaders may: not execute for these pixels, and thus any side affects they would have had will not occur.</member>
        <member name="VK_FALSE">* If set to ename:VK_FALSE, presentable images associated with the swapchain will own all the pixels they contain. Setting this value to ename:VK_TRUE does not guarantee any clipping will occur, but allows more optimal presentation methods to be used on some platforms.</member>
      </members>
    </type>
    <type name="VkSystemAllocationScope" summary="Allocation scope.">
      <specification />
      <description>
        <para>Most Vulkan commands operate on a single object, or there is a sole object that is being created or manipulated. When an allocation uses an allocation scope of ename:VK_SYSTEM_ALLOCATION_SCOPE_OBJECT or ename:VK_SYSTEM_ALLOCATION_SCOPE_CACHE, the allocation is scoped to the object being created or manipulated.</para>
        <para>When an implementation requires host memory, it will make callbacks to the application using the most specific allocator and allocation scope available:</para>
        <para>* If an allocation is scoped to the duration of a command, the allocator will use the ename:VK_SYSTEM_ALLOCATION_SCOPE_COMMAND allocation scope. The most specific allocator available is used: if the object being created or manipulated has an allocator, that object's allocator will be used, else if the parent sname:VkDevice has an allocator it will be used, else if the parent sname:VkInstance has an allocator it will be used. Else, * If an allocation is associated with an object of type sname:VkPipelineCache, the allocator will use the ename:VK_SYSTEM_ALLOCATION_SCOPE_CACHE allocation scope. The most specific allocator available is used (pipeline cache, else device, else instance). Else, * If an allocation is scoped to the lifetime of an object, that object is being created or manipulated by the command, and that object's type is not sname:VkDevice or sname:VkInstance, the allocator will use an allocation scope of ename:VK_SYSTEM_ALLOCATION_SCOPE_OBJECT. The most specific allocator available is used (object, else device, else instance). Else, * If an allocation is scoped to the lifetime of a device, the allocator will use an allocation scope of ename VK_SYSTEM_ALLOCATION_SCOPE_DEVICE. The most specific allocator available is used (device, else instance). Else, * If the allocation is scoped to the lifetime of an instance and the instance has an allocator, its allocator will be used with an allocation scope of ename:VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE. * Otherwise an implementation will allocate memory through an alternative mechanism that is unspecified.</para>
      </description>
      <members>
        <member name="VK_SYSTEM_ALLOCATION_SCOPE_COMMAND">ename:VK_SYSTEM_ALLOCATION_SCOPE_COMMAND - The allocation is scoped to the duration of the Vulkan command.</member>
        <member name="VK_SYSTEM_ALLOCATION_SCOPE_OBJECT">ename:VK_SYSTEM_ALLOCATION_SCOPE_OBJECT - The allocation is scoped to the lifetime of the Vulkan object that is being created or used.</member>
        <member name="VK_SYSTEM_ALLOCATION_SCOPE_CACHE">ename:VK_SYSTEM_ALLOCATION_SCOPE_CACHE - The allocation is scoped to the lifetime of a sname:VkPipelineCache object.</member>
        <member name="VK_SYSTEM_ALLOCATION_SCOPE_DEVICE">ename:VK_SYSTEM_ALLOCATION_SCOPE_DEVICE - The allocation is scoped to the lifetime of the Vulkan device.</member>
        <member name="VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE">ename:VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - The allocation is scoped to the lifetime of the Vulkan instance.</member>
      </members>
    </type>
    <type name="VkValidationCheckEXT" summary="Specify validation checks to disable.">
      <specification />
      <description />
      <members />
    </type>
    <type name="VkValidationFlagsEXT" summary="Specify validation checks to disable for a Vulkan instance.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="disabledValidationCheckCount">pname:disabledValidationCheckCount is the number of checks to disable.</member>
        <member name="pDisabledValidationChecks">pname:pDisabledValidationChecks is a pointer to an array of values specifying the validation checks to be disabled. Checks which may: be specified include: + --</member>
      </members>
    </type>
    <type name="VkVertexInputAttributeDescription" summary="Structure specifying vertex input attribute description.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:location must: be less than sname:VkPhysicalDeviceLimits::pname:maxVertexInputAttributes * pname:binding must: be less than sname:VkPhysicalDeviceLimits::pname:maxVertexInputBindings * pname:offset must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxVertexInputAttributeOffset * pname:format must: be allowed as a vertex buffer format, as specified by the ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT flag in sname:VkFormatProperties::pname:bufferFeatures returned by fname:vkGetPhysicalDeviceFormatProperties ****</para>
      </description>
      <members>
        <member name="location">pname:location is the shader binding location number for this attribute.</member>
        <member name="binding">pname:binding is the binding number which this attribute takes its data from.</member>
        <member name="format">pname:format is the size and type of the vertex attribute data.</member>
        <member name="offset">pname:offset is a byte offset of this attribute relative to the start of an element in the vertex input binding.</member>
      </members>
    </type>
    <type name="VkVertexInputBindingDescription" summary="Structure specifying vertex input binding description.">
      <specification />
      <description />
      <members>
        <member name="binding">pname:binding is the binding number that this structure describes.</member>
        <member name="stride">pname:stride is the distance in bytes between two consecutive elements within the buffer.</member>
        <member name="inputRate">pname:inputRate specifies whether vertex attribute addressing is a function of the vertex index or of the instance index. Possible values include: + --</member>
      </members>
    </type>
    <type name="VkVertexInputRate" summary="Specify rate at which vertex attributes are pulled from buffers.">
      <specification />
      <description>
        <para>.Valid Usage **** * pname:binding must: be less than sname:VkPhysicalDeviceLimits::pname:maxVertexInputBindings * pname:stride must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxVertexInputBindingStride ****</para>
      </description>
      <members />
    </type>
    <type name="VkViewport" summary="Structure specifying a viewport.">
      <specification />
      <description>
        <para>The framebuffer depth coordinate [eq]#pname:z~f~# may: be represented using either a fixed-point or floating-point representation. However, a floating-point representation must: be used if the depth/stencil attachment has a floating-point depth component. If an [eq]#m#-bit fixed-point representation is used, we assume that it represents each value latexmath:[$\frac{k}{2^m - 1}$], where [eq]#k {elem} { 0, 1, ..., 2^m^-1 }#, as [eq]#k# (e.g. 1.0 is represented in binary as a string of all ones).</para>
        <para>The viewport parameters shown in the above equations are found from these values as</para>
        <para>:: [eq]#o~x~ = pname:x + pname:width / 2# :: [eq]#o~y~ = pname:y + pname:height / 2# :: [eq]#o~z~ = pname:minDepth# :: [eq]#p~x~ = pname:width# :: [eq]#p~y~ = pname:height# :: [eq]#p~z~ = pname:maxDepth - pname:minDepth#.</para>
        <para>The width and height of the &lt;&lt;features-limits-maxViewportDimensions, implementation-dependent maximum viewport dimensions&gt;&gt; must: be greater than or equal to the width and height of the largest image which can: be created and attached to a framebuffer.</para>
        <para>The floating-point viewport bounds are represented with an &lt;&lt;features-limits-viewportSubPixelBits,implementation-dependent precision&gt;&gt;.</para>
        <para>.Valid Usage **** * pname:width must: be greater than `0.0` and less than or equal to sname:VkPhysicalDeviceLimits::pname:maxViewportDimensions[0] * pname:height must: be greater than `0.0` and less than or equal to sname:VkPhysicalDeviceLimits::pname:maxViewportDimensions[1] ifdef::VK_AMD_negative_viewport_height[] * If the VK_AMD_negative_viewport_height extension is enabled, pname:height can: also be negative. endif::VK_AMD_negative_viewport_height[] * pname:x and pname:y must: each be between pname:viewportBoundsRange[0] and pname:viewportBoundsRange[1], inclusive * pname:x + pname:width must: be less than or equal to pname:viewportBoundsRange[1] * pname:y + pname:height must: be less than or equal to pname:viewportBoundsRange[1] * pname:minDepth must: be between `0.0` and `1.0`, inclusive * pname:maxDepth must: be between `0.0` and `1.0`, inclusive ****</para>
      </description>
      <members>
        <member name="x">pname:x and pname:y are the viewport's upper left corner [eq]#(x,y)#.</member>
        <member name="width">pname:width and pname:height are the viewport's width and height, respectively.</member>
        <member name="minDepth">pname:minDepth and pname:maxDepth are the depth range for the viewport. It is valid for pname:minDepth to be greater than or equal to pname:maxDepth.</member>
      </members>
    </type>
    <type name="VkWaylandSurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created Wayland surface object.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="display">pname:display and pname:surface are pointers to the Wayland code:wl_display and code:wl_surface to associate the surface with.</member>
      </members>
    </type>
    <type name="VkWin32KeyedMutexAcquireReleaseInfoNV" summary="Use Windows keyex mutex mechanism to synchronize work.">
      <specification>
        <para>When submitting work that operates on memory imported from a Direct3D 11 resource to a queue, the keyed mutex mechanism may: be used in addition to Vulkan semaphores to synchronize the work. Keyed mutexes are a property of a properly created shareable Direct3D 11 resource. They can: only be used if the imported resource was created with the etext:D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX flag.</para>
        <para>To acquire keyed mutexes before submitted work and/or release them after, add a slink:VkWin32KeyedMutexAcquireReleaseInfoNV structure to the pname:pNext chain of the slink:VkSubmitInfo structure.</para>
      </specification>
      <description>
        <para>* pname:acquireCount is the number of entries in the pname:pAcquireSyncs, pname:pAcquireKeys, and pname:pAcquireTimeoutMilliseconds arrays. * pname:pAcquireSyncs is a pointer to an array of slink:VkDeviceMemory objects which were imported from Direct3D 11 resources. * pname:pAcquireKeys is a pointer to an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in pname:pAcquireSyncs. * pname:pAcquireTimeoutMilliseconds is an array of timeout values, in millisecond units, for each acquire specified in pname:pAcquireKeys. * pname:releaseCount is the number of entries in the pname:pReleaseSyncs and pname:pReleaseKeys arrays. * pname:pReleaseSyncs is a pointer to an array of slink:VkDeviceMemory objects which were imported from Direct3D 11 resources. * pname:pReleaseKeys is a pointer to an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in pname:pReleaseSyncs.</para>
      </description>
      <members />
    </type>
    <type name="VkWin32SurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created Win32 surface object.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="hinstance">pname:hinstance and pname:hwnd are the Win32 code:HINSTANCE and code:HWND for the window to associate the surface with.</member>
      </members>
    </type>
    <type name="VkWriteDescriptorSet" summary="Structure specifying the parameters of a descriptor set write operation.">
      <specification />
      <description>
        <para>Only one of pname:pImageInfo, pname:pBufferInfo, or pname:pTexelBufferView members is used according to the descriptor type specified in the pname:descriptorType member of the containing sname:VkWriteDescriptorSet structure, as specified below.</para>
        <para>[[descriptorsets-updates-consecutive, consecutive binding updates]] If the pname:dstBinding has fewer than pname:descriptorCount array elements remaining starting from pname:dstArrayElement, then the remainder will be used to update the subsequent binding - pname:dstBinding+1 starting at array element zero. This behavior applies recursively, with the update affecting consecutive bindings as needed to update all pname:descriptorCount descriptors. All consecutive bindings updated via a single sname:VkWriteDescriptorSet structure must: have identical pname:descriptorType and pname:stageFlags, and must: all either use immutable samplers or must: all not use immutable samplers.</para>
        <para>.Valid Usage **** * pname:dstBinding must: be a valid binding point within pname:dstSet * pname:descriptorType must: match the type of pname:dstBinding within pname:dstSet * The sum of pname:dstArrayElement and pname:descriptorCount must: be less than or equal to the number of array elements in the descriptor set binding specified by pname:dstBinding, and all applicable consecutive bindings, as described by &lt;&lt;descriptorsets-updates-consecutive&gt;&gt; * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, pname:pImageInfo must: be a pointer to an array of pname:descriptorCount valid sname:VkDescriptorImageInfo structures * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, pname:pTexelBufferView must: be a pointer to an array of pname:descriptorCount valid sname:VkBufferView handles * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, pname:pBufferInfo must: be a pointer to an array of pname:descriptorCount valid sname:VkDescriptorBufferInfo structures * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and pname:dstSet was not allocated with a layout that included immutable samplers for pname:dstBinding with pname:descriptorType, the pname:sampler member of any given element of pname:pImageInfo must: be a valid sname:VkSampler object * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the pname:imageView and pname:imageLayout members of any given element of pname:pImageInfo must: be a valid sname:VkImageView and elink:VkImageLayout, respectively * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the pname:offset member of any given element of pname:pBufferInfo must: be a multiple of sname:VkPhysicalDeviceLimits::pname:minUniformBufferOffsetAlignment * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the pname:offset member of any given element of pname:pBufferInfo must: be a multiple of sname:VkPhysicalDeviceLimits::pname:minStorageBufferOffsetAlignment * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the pname:buffer member of any given element of pname:pBufferInfo must: have been created with ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT set * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the pname:buffer member of any given element of pname:pBufferInfo must: have been created with ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT set * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the pname:range member of any given element of pname:pBufferInfo, or the effective range if pname:range is ename:VK_WHOLE_SIZE, must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxUniformBufferRange * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the pname:range member of any given element of pname:pBufferInfo, or the effective range if pname:range is ename:VK_WHOLE_SIZE, must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxStorageBufferRange * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, the sname:VkBuffer that any given element of pname:pTexelBufferView was created from must: have been created with ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT set * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, the sname:VkBuffer that any given element of pname:pTexelBufferView was created from must: have been created with ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the pname:imageView member of any given element of pname:pImageInfo must: have been created with the identity swizzle ****</para>
      </description>
      <members>
        <member name="sType">pname:sType is the type of this structure.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="dstSet">pname:dstSet is the destination descriptor set to update.</member>
        <member name="dstBinding">pname:dstBinding is the descriptor binding within that set.</member>
        <member name="dstArrayElement">pname:dstArrayElement is the starting element in that array.</member>
        <member name="descriptorCount">pname:descriptorCount is the number of descriptors to update (the number of elements in pname:pImageInfo, pname:pBufferInfo, or pname:pTexelBufferView).</member>
        <member name="descriptorType">pname:descriptorType is a elink:VkDescriptorType specifying the type of each descriptor in pname:pImageInfo, pname:pBufferInfo, or pname:pTexelBufferView, as described below. It must: be the same type as that specified in sname:VkDescriptorSetLayoutBinding for pname:dstSet at pname:dstBinding. The type of the descriptor also controls which array the descriptors are taken from.</member>
        <member name="pImageInfo">pname:pImageInfo points to an array of slink:VkDescriptorImageInfo structures or is ignored, as described below.</member>
        <member name="pBufferInfo">pname:pBufferInfo points to an array of slink:VkDescriptorBufferInfo structures or is ignored, as described below.</member>
        <member name="pTexelBufferView">pname:pTexelBufferView points to an array of slink:VkBufferView handles as described in the &lt;&lt;resources-buffer-views,Buffer Views&gt;&gt; section or is ignored, as described below.</member>
      </members>
    </type>
    <type name="VkXcbSurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created Xcb surface object.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="connection">pname:connection is a pointer to an code:xcb_connection_t to the X server.</member>
        <member name="window">pname:window is the code:xcb_window_t for the X11 window to associate the surface with.</member>
      </members>
    </type>
    <type name="VkXlibSurfaceCreateInfoKHR" summary="Structure specifying parameters of a newly created Xlib surface object.">
      <specification />
      <description />
      <members>
        <member name="sType">pname:sType is the type of this structure and must: be ename:VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR.</member>
        <member name="pNext">pname:pNext is `NULL` or a pointer to an extension-specific structure.</member>
        <member name="flags">pname:flags is reserved for future use.</member>
        <member name="dpy">pname:dpy is a pointer to an Xlib code:Display connection to the X server.</member>
        <member name="window">pname:window is an Xlib code:Window to associate the surface with.</member>
      </members>
    </type>
  </types>
  <commands>
    <command name="vkAcquireNextImageKHR" summary="Retrieve the index of the next available presentable image." />
    <command name="vkAllocateCommandBuffers" summary="Allocate command buffers from an existing command pool." />
    <command name="vkAllocateDescriptorSets" summary="Allocate one or more descriptor sets." />
    <command name="vkAllocateMemory" summary="Allocate GPU memory." />
    <command name="vkBeginCommandBuffer" summary="Start recording a command buffer." />
    <command name="vkBindBufferMemory" summary="Bind device memory to a buffer object." />
    <command name="vkBindImageMemory" summary="Bind device memory to an image object." />
    <command name="vkCmdBeginQuery" summary="Begin a query." />
    <command name="vkCmdBeginRenderPass" summary="Begin a new render pass." />
    <command name="vkCmdBindDescriptorSets" summary="Binds descriptor sets to a command buffer." />
    <command name="vkCmdBindIndexBuffer" summary="Bind an index buffer to a command buffer." />
    <command name="vkCmdBindPipeline" summary="Bind a pipeline object to a command buffer." />
    <command name="vkCmdBindVertexBuffers" summary="Bind vertex buffers to a command buffer." />
    <command name="vkCmdBlitImage" summary="Copy regions of an image, potentially performing format conversion,." />
    <command name="vkCmdClearAttachments" summary="Clear regions within currently bound framebuffer attachments." />
    <command name="vkCmdClearColorImage" summary="Clear regions of a color image." />
    <command name="vkCmdClearDepthStencilImage" summary="Fill regions of a combined depth-stencil image." />
    <command name="vkCmdCopyBuffer" summary="Copy data between buffer regions." />
    <command name="vkCmdCopyBufferToImage" summary="Copy data from a buffer into an image." />
    <command name="vkCmdCopyImage" summary="Copy data between images." />
    <command name="vkCmdCopyImageToBuffer" summary="Copy image data into a buffer." />
    <command name="vkCmdCopyQueryPoolResults" summary="Copy the results of queries in a query pool to a buffer object." />
    <command name="vkCmdDebugMarkerBeginEXT" summary="Open a command buffer marker region." />
    <command name="vkCmdDebugMarkerEndEXT" summary="Close a command buffer marker region." />
    <command name="vkCmdDebugMarkerInsertEXT" summary="Insert a marker label into a command buffer." />
    <command name="vkCmdDispatch" summary="Dispatch compute work items." />
    <command name="vkCmdDispatchIndirect" summary="Dispatch compute work items using indirect parameters." />
    <command name="vkCmdDraw" summary="Draw primitives." />
    <command name="vkCmdDrawIndexed" summary="Issue an indexed draw into a command buffer." />
    <command name="vkCmdDrawIndexedIndirect" summary="Perform an indexed indirect draw." />
    <command name="vkCmdDrawIndexedIndirectCountAMD" summary="Perform an indexed indirect draw with the draw count sourced from a buffer." />
    <command name="vkCmdDrawIndirect" summary="Issue an indirect draw into a command buffer." />
    <command name="vkCmdDrawIndirectCountAMD" summary="Perform an indirect draw with the draw count sourced from a buffer." />
    <command name="vkCmdEndQuery" summary="Ends a query." />
    <command name="vkCmdEndRenderPass" summary="End the current render pass." />
    <command name="vkCmdExecuteCommands" summary="Execute a secondary command buffer from a primary command buffer." />
    <command name="vkCmdFillBuffer" summary="Fill a region of a buffer with a fixed value." />
    <command name="vkCmdNextSubpass" summary="Transition to the next subpass of a render pass." />
    <command name="vkCmdPipelineBarrier" summary="Insert a set of execution and memory barriers." />
    <command name="vkCmdPushConstants" summary="Update the values of push constants." />
    <command name="vkCmdResetEvent" summary="Reset an event object to non-signaled state." />
    <command name="vkCmdResetQueryPool" summary="Reset queries in a query pool." />
    <command name="vkCmdResolveImage" summary="Resolve regions of an image." />
    <command name="vkCmdSetBlendConstants" summary="Set the values of blend constants." />
    <command name="vkCmdSetDepthBias" summary="Set the depth bias dynamic state." />
    <command name="vkCmdSetDepthBounds" summary="Set the depth bounds test values for a command buffer." />
    <command name="vkCmdSetEvent" summary="Set an event object to signaled state." />
    <command name="vkCmdSetLineWidth" summary="Set the dynamic line width state." />
    <command name="vkCmdSetScissor" summary="Set the dynamic scissor rectangles on a command buffer." />
    <command name="vkCmdSetStencilCompareMask" summary="Set the stencil compare mask dynamic state." />
    <command name="vkCmdSetStencilReference" summary="Set the stencil reference dynamic state." />
    <command name="vkCmdSetStencilWriteMask" summary="Set the stencil write mask dynamic state." />
    <command name="vkCmdSetViewport" summary="Set the viewport on a command buffer." />
    <command name="vkCmdUpdateBuffer" summary="Update a buffer's contents from host memory." />
    <command name="vkCmdWaitEvents" summary="Wait for one or more events and insert a set of memory." />
    <command name="vkCmdWriteTimestamp" summary="Write a device timestamp into a query object." />
    <command name="vkCreateAndroidSurfaceKHR" summary="Create a slink:VkSurfaceKHR object for an Android native window." />
    <command name="vkCreateBuffer" summary="Create a new buffer object." />
    <command name="vkCreateBufferView" summary="Create a new buffer view object." />
    <command name="vkCreateCommandPool" summary="Create a new command pool object." />
    <command name="vkCreateComputePipelines" summary="Creates a new compute pipeline object." />
    <command name="vkCreateDebugReportCallbackEXT" summary="Create a debug report callback object." />
    <command name="vkCreateDescriptorPool" summary="Creates a descriptor pool object." />
    <command name="vkCreateDescriptorSetLayout" summary="Create a new descriptor set layout." />
    <command name="vkCreateDevice" summary="Create a new device instance." />
    <command name="vkCreateDisplayModeKHR" summary="Create a display mode." />
    <command name="vkCreateDisplayPlaneSurfaceKHR" summary="Create a slink:VkSurfaceKHR structure representing a display plane and mode." />
    <command name="vkCreateEvent" summary="Create a new event object." />
    <command name="vkCreateFence" summary="Create a new fence object." />
    <command name="vkCreateFramebuffer" summary="Create a new framebuffer object." />
    <command name="vkCreateGraphicsPipelines" summary="Create graphics pipelines." />
    <command name="vkCreateImage" summary="Create a new image object." />
    <command name="vkCreateImageView" summary="Create an image view from an existing image." />
    <command name="vkCreateInstance" summary="Create a new Vulkan instance." />
    <command name="vkCreateMirSurfaceKHR" summary="Create a slink:VkSurfaceKHR object for a Mir window." />
    <command name="vkCreatePipelineCache" summary="Creates a new pipeline cache." />
    <command name="vkCreatePipelineLayout" summary="Creates a new pipeline layout object." />
    <command name="vkCreateQueryPool" summary="Create a new query pool object." />
    <command name="vkCreateRenderPass" summary="Create a new render pass object." />
    <command name="vkCreateSampler" summary="Create a new sampler object." />
    <command name="vkCreateSemaphore" summary="Create a new queue semaphore object." />
    <command name="vkCreateShaderModule" summary="Creates a new shader module object." />
    <command name="vkCreateSharedSwapchainsKHR" summary="Create multiple swapchains that share presentable images." />
    <command name="vkCreateSwapchainKHR" summary="Create a swapchain." />
    <command name="vkCreateWaylandSurfaceKHR" summary="Create a slink:VkSurfaceKHR object for a Wayland window." />
    <command name="vkCreateWin32SurfaceKHR" summary="Create a slink:VkSurfaceKHR object for an Win32 native window." />
    <command name="vkCreateXcbSurfaceKHR" summary="Create a slink:VkSurfaceKHR object for a X11 window, using the XCB client-side library." />
    <command name="vkCreateXlibSurfaceKHR" summary="Create a slink:VkSurfaceKHR object for an X11 window, using the Xlib client-side library." />
    <command name="vkDebugMarkerSetObjectNameEXT" summary="Give a user-friendly name to an object." />
    <command name="vkDebugMarkerSetObjectTagEXT" summary="Attach arbitrary data to an object." />
    <command name="vkDestroyBuffer" summary="Destroy a buffer object." />
    <command name="vkDestroyBufferView" summary="Destroy a buffer view object." />
    <command name="vkDestroyCommandPool" summary="Destroy a command pool object." />
    <command name="vkDestroyDebugReportCallbackEXT" summary="Destroy a debug report callback object." />
    <command name="vkDestroyDescriptorPool" summary="Destroy a descriptor pool object." />
    <command name="vkDestroyDescriptorSetLayout" summary="Destroy a descriptor set layout object." />
    <command name="vkDestroyDevice" summary="Destroy a logical device." />
    <command name="vkDestroyEvent" summary="Destroy an event object." />
    <command name="vkDestroyFence" summary="Destroy a fence object." />
    <command name="vkDestroyFramebuffer" summary="Destroy a framebuffer object." />
    <command name="vkDestroyImage" summary="Destroy an image object." />
    <command name="vkDestroyImageView" summary="Destroy an image view object." />
    <command name="vkDestroyInstance" summary="Destroy an instance of Vulkan." />
    <command name="vkDestroyPipeline" summary="Destroy a pipeline object." />
    <command name="vkDestroyPipelineCache" summary="Destroy a pipeline cache object." />
    <command name="vkDestroyPipelineLayout" summary="Destroy a pipeline layout object." />
    <command name="vkDestroyQueryPool" summary="Destroy a query pool object." />
    <command name="vkDestroyRenderPass" summary="Destroy a render pass object." />
    <command name="vkDestroySampler" summary="Destroy a sampler object." />
    <command name="vkDestroySemaphore" summary="Destroy a semaphore object." />
    <command name="vkDestroyShaderModule" summary="Destroy a shader module module." />
    <command name="vkDestroySurfaceKHR" summary="Destroy a VkSurfaceKHR object." />
    <command name="vkDestroySwapchainKHR" summary="Destroy a swapchain object." />
    <command name="vkDeviceWaitIdle" summary="Wait for a device to become idle." />
    <command name="vkEndCommandBuffer" summary="Finish recording a command buffer." />
    <command name="vkEnumerateDeviceExtensionProperties" summary="Returns properties of available physical device extensions." />
    <command name="vkEnumerateDeviceLayerProperties" summary="Returns properties of available physical device layers." />
    <command name="vkEnumerateInstanceExtensionProperties" summary="Returns up to requested number of global extension properties." />
    <command name="vkEnumerateInstanceLayerProperties" summary="Returns up to requested number of global layer properties." />
    <command name="vkEnumeratePhysicalDevices" summary="Enumerates the physical devices accessible to a Vulkan instance." />
    <command name="vkFlushMappedMemoryRanges" summary="Flush mapped memory ranges." />
    <command name="vkFreeCommandBuffers" summary="Free command buffers." />
    <command name="vkFreeDescriptorSets" summary="Free one or more descriptor sets." />
    <command name="vkFreeMemory" summary="Free GPU memory." />
    <command name="vkGetBufferMemoryRequirements" summary="Returns the memory requirements for specified Vulkan object." />
    <command name="vkGetDeviceMemoryCommitment" summary="Query the current commitment for a VkDeviceMemory." />
    <command name="vkGetDeviceProcAddr" summary="Return a function pointer for a command." />
    <command name="vkGetDeviceQueue" summary="Get a queue handle from a device." />
    <command name="vkGetDisplayModePropertiesKHR" summary="Query the set of mode properties supported by the display." />
    <command name="vkGetDisplayPlaneCapabilitiesKHR" summary="Query capabilities of a mode and plane combination." />
    <command name="vkGetDisplayPlaneSupportedDisplaysKHR" summary="Query the list of displays a plane supports." />
    <command name="vkGetEventStatus" summary="Retrieve the status of an event object." />
    <command name="vkGetFenceStatus" summary="Return the status of a fence." />
    <command name="vkGetImageMemoryRequirements" summary="Returns the memory requirements for specified Vulkan object." />
    <command name="vkGetImageSparseMemoryRequirements" summary="Query the memory requirements for a sparse image." />
    <command name="vkGetImageSubresourceLayout" summary="Retrieve information about an image subresource." />
    <command name="vkGetInstanceProcAddr" summary="Return a function pointer for a command." />
    <command name="vkGetMemoryWin32HandleNV" summary="Retrieve Win32 handle to a device memory object." />
    <command name="vkGetPhysicalDeviceDisplayPlanePropertiesKHR" summary="Query the plane properties." />
    <command name="vkGetPhysicalDeviceDisplayPropertiesKHR" summary="Query information about the available displays." />
    <command name="vkGetPhysicalDeviceExternalImageFormatPropertiesNV" summary="Determine image capabilities compatible with external memory handle types." />
    <command name="vkGetPhysicalDeviceFeatures" summary="Reports capabilities of a physical device." />
    <command name="vkGetPhysicalDeviceFormatProperties" summary="Lists physical device's format capabilities." />
    <command name="vkGetPhysicalDeviceImageFormatProperties" summary="Lists physical device's image format capabilities." />
    <command name="vkGetPhysicalDeviceMemoryProperties" summary="Reports memory information for the specified physical device." />
    <command name="vkGetPhysicalDeviceMirPresentationSupportKHR" summary="Query physical device for presentation to Mir." />
    <command name="vkGetPhysicalDeviceProperties" summary="Returns properties of a physical device." />
    <command name="vkGetPhysicalDeviceQueueFamilyProperties" summary="Reports properties of the queues of the specified physical device." />
    <command name="vkGetPhysicalDeviceSparseImageFormatProperties" summary="Retrieve properties of an image format applied to sparse images." />
    <command name="vkGetPhysicalDeviceSurfaceCapabilitiesKHR" summary="Query surface capabilities." />
    <command name="vkGetPhysicalDeviceSurfaceFormatsKHR" summary="Query color formats supported by surface." />
    <command name="vkGetPhysicalDeviceSurfacePresentModesKHR" summary="Query supported presentation modes." />
    <command name="vkGetPhysicalDeviceSurfaceSupportKHR" summary="Query if presentation is supported." />
    <command name="vkGetPhysicalDeviceWaylandPresentationSupportKHR" summary="Query physical device for presentation to Wayland." />
    <command name="vkGetPhysicalDeviceWin32PresentationSupportKHR" summary="Query queue family support for presentation on a Win32 display." />
    <command name="vkGetPhysicalDeviceXcbPresentationSupportKHR" summary="Query physical device for presentation to X11 server using XCB." />
    <command name="vkGetPhysicalDeviceXlibPresentationSupportKHR" summary="Query physical device for presentation to X11 server using Xlib." />
    <command name="vkGetPipelineCacheData" summary="Get the data store from a pipeline cache." />
    <command name="vkGetQueryPoolResults" summary="Copy results of queries in a query pool to a host memory region." />
    <command name="vkGetRenderAreaGranularity" summary="Returns the granularity for optimal render area." />
    <command name="vkGetSwapchainImagesKHR" summary="Obtain the array of presentable images associated with a swapchain." />
    <command name="vkInvalidateMappedMemoryRanges" summary="Invalidate ranges of mapped memory objects." />
    <command name="vkMapMemory" summary="Map a memory object into application address space." />
    <command name="vkMergePipelineCaches" summary="Combine the data stores of pipeline caches." />
    <command name="vkQueueBindSparse" summary="Bind device memory to a sparse resource object." />
    <command name="vkQueuePresentKHR" summary="Queue an image for presentation." />
    <command name="vkQueueSubmit" summary="Submits a sequence of semaphores or command buffers to a queue." />
    <command name="vkQueueWaitIdle" summary="Wait for a queue to become idle." />
    <command name="vkResetCommandBuffer" summary="Reset a command buffer." />
    <command name="vkResetCommandPool" summary="Reset a command pool." />
    <command name="vkResetDescriptorPool" summary="Resets a descriptor pool object." />
    <command name="vkResetEvent" summary="Reset an event to non-signaled state." />
    <command name="vkResetFences" summary="Resets one or more fence objects." />
    <command name="vkSetEvent" summary="Set an event to signaled state." />
    <command name="vkUnmapMemory" summary="Unmap a previously mapped memory object." />
    <command name="vkUpdateDescriptorSets" summary="Update the contents of a descriptor set object." />
    <command name="vkWaitForFences" summary="Wait for one or more fences to become signaled." />
  </commands>
</docs>